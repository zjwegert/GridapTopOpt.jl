using Pkg
Pkg.activate()
using Mustache

# These are generated by solving
# Minimise X + Y + Z s.t. X*Y*Z=i*128 for X,Y,Z∈ℤ⁺ (See bottom)
mesh_partitions = [(4,4,8),(4,8,8),(6,8,8),(8,8,8),(10,8,8),(12,8,8),(14,8,8),
  (16,8,8),(12,12,8),(8,10,16),(16,8,11),(8,12,16),(16,8,13),(8,14,16),
  (10,12,16),(16,16,8),(8,16,17),(12,12,16),(8,16,19),(16,16,10)]

@assert Int.(prod.(mesh_partitions)/48) == collect(1:length(mesh_partitions))

function generate(
    template,
    name,
    type,
    bmark_type,
    cputype,
    wallhr,
    mesh_partition,
    n_el_size,
    fe_order,
    verbose,
    dir_name,
    write_dir,
    nreps
  )

  ncpus = prod(mesh_partition)
  wallhr = occursin("STRONG",name) && ncpus == 1 ? 100 :
           occursin("STRONG",name) && ncpus == 8 ? 24 :
           occursin("STRONG",name) && ncpus == 27 ? 10 : wallhr
  mem = occursin("STRONG",name) && ncpus == 1 ? 100 :
        occursin("STRONG",name) && ncpus == 8 ? 128 :
        occursin("STRONG",name) && ncpus == 27 ? 192 : Int(gb_per_node*ncpus/cps_per_node);
  Nx_partition, Ny_partition, Nz_partition = mesh_partition

  settings = (;name,type,bmark_type,cputype,wallhr,ncpus,mem,
    Nx_partition,Ny_partition,Nz_partition,n_el_size,fe_order,verbose,dir_name,write_dir,nreps)
  Mustache.render(template, settings)
end

function generate_jobs(template,phys_type,ndof_per_node,bmark_types)
  npart = prod.(parts)
  weak_el_x = @. floor(Int,(dofs_per_proc*npart/ndof_per_node)^(1/3)-1);
  dof_sanity_check = @.(floor(Int,ndof_per_node*(weak_el_x+1)^3/npart)),
    maximum(abs,@. ndof_per_node*(weak_el_x+1)^3/npart/dofs_per_proc - 1)

  sname(phys_type,ndof_per_node,n,elx) = "STRONG_$(phys_type)_dof$(ndof_per_node)_N$(prod(n))_elx$(elx)"
  wname(phys_type,ndof_per_node,n,elx) = "WEAK_$(phys_type)_dof$(ndof_per_node)_N$(prod(n))_elx$(elx)"

  strong_el_x = ceil(Int,(strong_dof/ndof_per_node)^(1/3));

  strong_jobs = map(n->(sname(phys_type,ndof_per_node,n,strong_el_x),
    generate(template,sname(phys_type,ndof_per_node,n,strong_el_x),phys_type,bmark_types,
    cputype,wallhr,n,strong_el_x,fe_order,verbose,dir_name,write_dir,nreps)),parts)
  weak_jobs = map((n,elx)->(wname(phys_type,ndof_per_node,n,elx),
    generate(template,wname(phys_type,ndof_per_node,n,elx),phys_type,bmark_types,
    cputype,wallhr,n,elx,fe_order,verbose,dir_name,write_dir,nreps)),parts,weak_el_x)

  strong_jobs,weak_jobs,dof_sanity_check
end

dir_name= "GridapTopOpt";
job_output_path = "$(ENV["MYSCRATCH"])/$dir_name/scripts/Benchmarks/jobs-setonix/";
mkpath(job_output_path);

# SETUP PARAMETERS
cputype=""; # Not needed here
gb_per_node = 256 # GB
cps_per_node = 128
wallhr = 3 ; # Hours (Note may want to manually change some afterwards)

nreps = 10; # Number of benchmark repetitions
dofs_per_proc = 32000;
fe_order= 1;
verbose= 1;
write_dir = "\$SCRATCH/$dir_name/results/benchmarks/"

parts = mesh_partitions[1:4]
strong_dof=(100+1)^3*3; # Number of dofs for strong scaling

# Phys type and number of dofs per node, and what to benchmark
phys_types = [
  ("THERM",1,"bopt0,bopt1,bfwd,badv,breinit,bvelext"),
  ("ELAST",3,"bopt0,bopt1,bfwd,badv,breinit,bvelext"),
  ("NLELAST",3,"bopt0,bopt1,bfwd"),
  # ("INVERTER_HPM",3,"bhpm"),
];

# Template
template = read("$(ENV["SCRATCH"])/$dir_name/scripts/Benchmarks/jobtemplate_gadi.sh",String)

## Generate Jobs
jobs_by_phys = map(x->(x[1],generate_jobs(template,x[1],x[2],x[3])),phys_types);

for jobs in jobs_by_phys
  strong_jobs,weak_jobs,dof_sanity_check = jobs[2]

  println("$(jobs[1]): Weak dofs = $(dof_sanity_check[1])\n     Error = $(dof_sanity_check[2])\n")
  for job in vcat(strong_jobs,weak_jobs)
    name = job[1]
    content = job[2]
    open(job_output_path*"$name.pbs","w") do f
      write(f,content)
    end
  end
end

# Mathematica code:
# F[N_]:=Minimize[{X+Y+Z,X*Y*Z==N*128, X>0, Y>0, Z>0,X\[Element] Integers,Y\[Element] Integers,Z\[Element] Integers},{X,Y,Z}]
# nn = 20;
# For[i=1,i<=nn,i++,X[i]=F[i]];
# For[i=1,i<=nn,i++,Print[{X[i][[2]][[1]][[2]],X[i][[2]][[2]][[2]],X[i][[2]][[3]][[2]]}]]