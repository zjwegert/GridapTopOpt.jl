using Pkg
Pkg.activate()
using Mustache

# These are generated by solving
# Minimise X + Y + Z s.t. X*Y*Z=i*48 for X,Y,Z∈ℤ⁺ (See bottom)
mesh_partitions = [(4, 4, 3),(4, 4, 6),(4, 6, 6),(4, 6, 8),(5, 6, 8),(6, 6, 8),(7, 6, 8),(6, 8, 8),(6, 9, 8),(10, 6, 8),
  (11, 6, 8),(9, 8, 8),(13, 6, 8),(12, 7, 8),(10, 9, 8),(12, 8, 8),(6, 8, 17),(12, 9, 8),(6, 8, 19),
  (10, 12, 8),(14, 9, 8),(11, 12, 8),(6, 8, 23),(12, 12, 8),(10, 10, 12),(13, 12, 8),(12, 12, 9),(12, 14, 8),
  (6, 8, 29),(10, 12, 12),(6, 8, 31),(8, 12, 16),(11, 12, 12),(8, 12, 17),(10, 12, 14),(12, 12, 12),(6, 8, 37),
  (8, 12, 19),(13, 12, 12),(10, 12, 16),(6, 8, 41),(12, 12, 14),(6, 8, 43),(11, 12, 16),(12, 12, 15),(8, 12, 23),
  (6, 8, 47),(12, 12, 16),(12, 14, 14),(10, 15, 16),(12, 12, 17),(12, 13, 16),(6, 8, 53),(12, 12, 18),(11, 15, 16),
  (12, 14, 16),(12, 12, 19),(8, 12, 29),(6, 8, 59),(12, 15, 16),(6, 8, 61),(8, 12, 31),(12, 14, 18),(12, 16, 16),
  (13, 15, 16),(11, 16, 18),(6, 8, 67),(12, 16, 17),(12, 12, 23),(14, 15, 16),(6, 8, 71),(12, 16, 18),(6, 8, 73),
  (8, 12, 37),(15, 15, 16),(12, 16, 19),(11, 16, 21),(13, 16, 18),(6, 8, 79),(15, 16, 16),(12, 18, 18),(8, 12, 41),
  (6, 8, 83),(14, 16, 18),(15, 16, 17),(8, 12, 43),(12, 12, 29),(12, 16, 22),(6, 8, 89),(15, 16, 18)]

@assert Int.(prod.(mesh_partitions)/48) == collect(1:length(mesh_partitions))

function generate(
    template,
    name,
    type,
    bmark_type,
    cputype,
    wallhr,
    mesh_partition,
    n_el_size,
    fe_order,
    verbose,
    dir_name,
    write_dir,
    nreps
  )

  ncpus = prod(mesh_partition)
  wallhr = occursin("STRONG",name) && ncpus <= 8 ? 100 : wallhr
  mem = occursin("STRONG",name) && ncpus == 1 ? 100 : 
        occursin("STRONG",name) && ncpus == 8 ? 32 : Int(gb_per_node*ncpus/cps_per_node);
  Nx_partition, Ny_partition, Nz_partition = mesh_partition

  settings = (;name,type,bmark_type,cputype,wallhr,ncpus,mem,
    Nx_partition,Ny_partition,Nz_partition,n_el_size,fe_order,verbose,dir_name,write_dir,nreps)
  Mustache.render(template, settings)
end

function generate_jobs(template,phys_type,ndof_per_node,bmark_types)
  npart = prod.(parts)
  weak_el_x = @. floor(Int,(dofs_per_proc*npart/ndof_per_node)^(1/3)-1);
  dof_sanity_check = @.(floor(Int,ndof_per_node*(weak_el_x+1)^3/npart)),
    maximum(abs,@. ndof_per_node*(weak_el_x+1)^3/npart/dofs_per_proc - 1)

  sname(phys_type,ndof_per_node,n,elx) = "STRONG_$(phys_type)_dof$(ndof_per_node)_N$(prod(n))_elx$(elx)"
  wname(phys_type,ndof_per_node,n,elx) = "WEAK_$(phys_type)_dof$(ndof_per_node)_N$(prod(n))_elx$(elx)"

  strong_el_x = ceil(Int,(strong_dof/ndof_per_node)^(1/3));

  strong_jobs = map(n->(sname(phys_type,ndof_per_node,n,strong_el_x),
    generate(template,sname(phys_type,ndof_per_node,n,strong_el_x),phys_type,bmark_types,
    cputype,wallhr,n,strong_el_x,fe_order,verbose,dir_name,write_dir,nreps)),parts)
  weak_jobs = map((n,elx)->(wname(phys_type,ndof_per_node,n,elx),
    generate(template,wname(phys_type,ndof_per_node,n,elx),phys_type,bmark_types,
    cputype,wallhr,n,elx,fe_order,verbose,dir_name,write_dir,nreps)),parts,weak_el_x)

  strong_jobs,weak_jobs,dof_sanity_check
end

dir_name= "LevelSetTopOpt";
job_output_path = "$(ENV["SCRATCH"])/$dir_name/scripts/Benchmarks/jobs-gadi/";
mkpath(job_output_path);

# SETUP PARAMETERS
cputype=""; # Not needed here
gb_per_node = 192 # GB
cps_per_node = 48
wallhr = 3 ; # Hours (Note may want to manually change some afterwards)

nreps = 10; # Number of benchmark repetitions
dofs_per_proc = 32000;
fe_order= 1;
verbose= 1;
write_dir = "\$SCRATCH/$dir_name/results/benchmarks/"

# parts = [(1,1,1);(2,2,2);(3,3,3);mesh_partitions[1:3:22]] # Mesh partitions
# parts = [(1,1,1);mesh_partitions[1:2:20]]
# parts = [(1,1,1);mesh_partitions[[1,2,3,4,5]];mesh_partitions[8:4:20]]
parts = [(1,1,1);mesh_partitions[[1,2,3,5]];mesh_partitions[8:5:23]]
strong_dof=(100+1)^3*3; # Number of dofs for strong scaling

# Phys type and number of dofs per node, and what to benchmark
phys_types = [
  ("THERM",1,"bopt0,bopt1,bfwd,badv,breinit,bvelext"),
  ("ELAST",3,"bopt0,bopt1,bfwd,badv,breinit,bvelext"),
  ("NLELAST",3,"bopt0,bopt1,bfwd"),
  # ("INVERTER_HPM",3,"bhpm"),
];

# Template
template = read("$(ENV["SCRATCH"])/$dir_name/scripts/Benchmarks/jobtemplate_gadi.sh",String)

## Generate Jobs
jobs_by_phys = map(x->(x[1],generate_jobs(template,x[1],x[2],x[3])),phys_types);

for jobs in jobs_by_phys
  strong_jobs,weak_jobs,dof_sanity_check = jobs[2]
  
  println("$(jobs[1]): Weak dofs = $(dof_sanity_check[1])\n     Error = $(dof_sanity_check[2])\n")
  for job in vcat(strong_jobs,weak_jobs)
    name = job[1]
    content = job[2]
    open(job_output_path*"$name.pbs","w") do f
      write(f,content)
    end
  end
end

# Mathematica code:
#   F[N_]:=Minimize[{X+Y+Z,X*Y*Z==N*48, X>0, Y>0, Z>0,X\[Element] Integers,Y\[Element] Integers,Z\[Element] Integers},{X,Y,Z}]
#   For[i=1,i<=50,i++,X[i]=F[i]];
#   For[i=1,i<=90,i++,Print[{X[i][[2]][[1]][[2]],X[i][[2]][[2]][[2]],X[i][[2]][[3]][[2]]}]]