<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Optimisers · GridapTopOpt.jl</title><meta name="title" content="Optimisers · GridapTopOpt.jl"/><meta property="og:title" content="Optimisers · GridapTopOpt.jl"/><meta property="twitter:title" content="Optimisers · GridapTopOpt.jl"/><meta name="description" content="Documentation for GridapTopOpt.jl."/><meta property="og:description" content="Documentation for GridapTopOpt.jl."/><meta property="twitter:description" content="Documentation for GridapTopOpt.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">GridapTopOpt.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../getting-started/">Getting Started</a></li><li><span class="tocitem">Reference</span><ul><li class="is-active"><a class="tocitem" href>Optimisers</a><ul class="internal"><li><a class="tocitem" href="#Lagrangian-and-Augmented-Lagrangian-method"><span>Lagrangian &amp; Augmented Lagrangian method</span></a></li><li><a class="tocitem" href="#Hilbertian-projection-method"><span>Hilbertian projection method</span></a></li><li><a class="tocitem" href="#Optimiser-history"><span>Optimiser history</span></a></li><li><a class="tocitem" href="#Custom-optimiser"><span>Custom optimiser</span></a></li></ul></li><li><a class="tocitem" href="../chainrules/">ChainRules</a></li><li><a class="tocitem" href="../levelsetevolution/">LevelSetEvolution</a></li><li><a class="tocitem" href="../velext/">Velocity extension</a></li><li><a class="tocitem" href="../io/">IO</a></li><li><a class="tocitem" href="../utilities/">Utilities</a></li><li><a class="tocitem" href="../benchmarking/">Benchmarking</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>Optimisers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Optimisers</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/zjwegert/GridapTopOpt.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/zjwegert/GridapTopOpt.jl/blob/main/docs/src/reference/optimisers.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Optimisers"><a class="docs-heading-anchor" href="#Optimisers">Optimisers</a><a id="Optimisers-1"></a><a class="docs-heading-anchor-permalink" href="#Optimisers" title="Permalink"></a></h1><p>In GridapTopOpt we implement optimisation algorithms as <a href="https://docs.julialang.org/en/v1/manual/interfaces/">iterators</a> that inherit from an abstract type <code>Optimiser</code>. A concrete <code>Optimiser</code> implementation, say <code>OptEg</code>, then implements <code>iterate(m::OptEg) ↦ (var,state)</code> and <code>iterate(m::OptEg,state) ↦ (var,state)</code>, where <code>var</code> and <code>state</code> are the available items in the outer loop and internal state of the iterator, respectively. As a result we can iterate over the object <code>m=OptEg(...)</code> using <code>for var in m</code>. The benefit of this implementation is that the internals of the optimisation method can be hidden in the source code while the explicit <code>for</code> loop is still visible to the user. The body of the loop can then be used for auxiliary operations such as writing the optimiser history and other files.</p><p>The below describes the implemented optimisers along with the <code>OptimiserHistory</code> type. Custom optimisers can be implemented by creating types that inherit from <code>Optimiser</code> and extending the interfaces in <a href="#Custom-optimiser">Custom optimiser</a>.</p><h2 id="Lagrangian-and-Augmented-Lagrangian-method"><a class="docs-heading-anchor" href="#Lagrangian-and-Augmented-Lagrangian-method">Lagrangian &amp; Augmented Lagrangian method</a><a id="Lagrangian-and-Augmented-Lagrangian-method-1"></a><a class="docs-heading-anchor-permalink" href="#Lagrangian-and-Augmented-Lagrangian-method" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GridapTopOpt.AugmentedLagrangian" href="#GridapTopOpt.AugmentedLagrangian"><code>GridapTopOpt.AugmentedLagrangian</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct AugmentedLagrangian &lt;: Optimiser</code></pre><p>An augmented Lagrangian method based on Nocedal and Wright, 2006 (<a href="https://doi.org/10.1007/978-0-387-40065-5">link</a>). Note that this method will function as a Lagrangian method if no constraints are defined in <code>problem::PDEConstrainedFunctionals</code>.</p><p><strong>Parameters</strong></p><ul><li><code>problem::PDEConstrainedFunctionals</code>: The objective and constraint setup.</li><li><code>ls_evolver::LevelSetEvolution</code>: Solver for the evolution and reinitisation equations.</li><li><code>vel_ext::VelocityExtension</code>: The velocity-extension method for extending  shape sensitivities onto the computational domain.</li><li><code>history::OptimiserHistory{Float64}</code>: Historical information for optimisation problem.</li><li><code>converged::Function</code>: A function to check optimiser convergence. </li><li><code>has_oscillations::Function</code>: A function to check for oscillations.</li><li><code>params::NamedTuple</code>: Optimisation parameters.</li></ul><p>The <code>has_oscillations</code> function has been added to avoid oscillations in the  iteration history. By default this uses a mean zero crossing algorithm as implemented in ChaosTools. Oscillations checking can be disabled by taking <code>has_oscillations = (args...) -&gt; false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zjwegert/GridapTopOpt.jl/blob/78474ca09366934fd6cc603408f07ba85a1d4aa6/src/Optimisers/AugmentedLagrangian.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GridapTopOpt.AugmentedLagrangian-Union{Tuple{N}, Tuple{PDEConstrainedFunctionals{N}, GridapTopOpt.LevelSetEvolution, VelocityExtension, Any}} where N" href="#GridapTopOpt.AugmentedLagrangian-Union{Tuple{N}, Tuple{PDEConstrainedFunctionals{N}, GridapTopOpt.LevelSetEvolution, VelocityExtension, Any}} where N"><code>GridapTopOpt.AugmentedLagrangian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AugmentedLagrangian(
  problem    :: PDEConstrainedFunctionals{N},
  ls_evolver :: LevelSetEvolution,
  vel_ext    :: VelocityExtension,
  φ0;
  Λ_max = 10^10, ζ = 1.1, update_mod = 5, γ = 0.1, γ_reinit = 0.5, os_γ_mult = 0.75,
  maxiter = 1000, verbose=false, constraint_names = map(i -&gt; Symbol(&quot;C_$i&quot;),1:N),
  converged::Function = default_al_converged, debug = false,
  has_oscillations::Function = default_has_oscillations
) where {N,O}</code></pre><p>Create an instance of <code>AugmentedLagrangian</code> with several adjustable defaults.</p><p><strong>Required</strong></p><ul><li><code>problem::PDEConstrainedFunctionals</code>: The objective and constraint setup.</li><li><code>ls_evolver::LevelSetEvolution</code>: Solver for the evolution and reinitisation equations.</li><li><code>vel_ext::VelocityExtension</code>: The velocity-extension method for extending  shape sensitivities onto the computational domain.</li><li><code>φ0</code>: An initial level-set function defined as a FEFunction or GridapDistributed equivilent.</li></ul><p><strong>Optional defaults</strong></p><ul><li><code>γ = 0.1</code>: Initial coeffient on the time step size for solving the Hamilton-Jacobi evolution equation.</li><li><code>γ_reinit = 0.5</code>: Coeffient on the time step size for solving the reinitisation equation.</li><li><code>ζ = 1.1</code>: Increase multiplier on Λ every <code>update_mod</code> iterations.</li><li><code>Λ_max = 5.0</code>: Maximum value on any entry in Λ.</li><li><code>update_mod = 5</code>: Number of iterations before increasing <code>Λ</code>.</li><li><code>reinit_mod = 1</code>: How often we solve reinitialisation equation.</li><li><code>maxiter = 1000</code>: Maximum number of algorithm iterations.</li><li><code>verbose=false</code>: Verbosity flag.</li><li><code>constraint_names = map(i -&gt; Symbol(&quot;C_$i&quot;),1:N)</code>: Constraint names for history output.</li><li><code>has_oscillations::Function = default_has_oscillations</code>: Function to check for oscillations  in the history.</li><li><code>initial_parameters::Function = default_al_init_params</code>: Function to generate initial λ, Λ. This can be replaced to inject different λ and Λ, for example.</li><li><code>os_γ_mult = 0.75</code>: Decrease multiplier for <code>γ</code> when <code>has_oscillations</code> returns true</li><li><code>converged::Function = default_hp_converged</code>: Convergence criteria.</li><li><code>debug = false</code>: Debug flag.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zjwegert/GridapTopOpt.jl/blob/78474ca09366934fd6cc603408f07ba85a1d4aa6/src/Optimisers/AugmentedLagrangian.jl#L34-L74">source</a></section></article><h2 id="Hilbertian-projection-method"><a class="docs-heading-anchor" href="#Hilbertian-projection-method">Hilbertian projection method</a><a id="Hilbertian-projection-method-1"></a><a class="docs-heading-anchor-permalink" href="#Hilbertian-projection-method" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GridapTopOpt.HilbertianProjection" href="#GridapTopOpt.HilbertianProjection"><code>GridapTopOpt.HilbertianProjection</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct HilbertianProjection &lt;: Optimiser</code></pre><p>A Hilbertian projection method as described by Wegert et al., 2023  (<a href="https://doi.org/10.1007/s00158-023-03663-0">link</a>).</p><p><strong>Parameters</strong></p><ul><li><code>problem::PDEConstrainedFunctionals{N}</code>: The objective and constraint setup.</li><li><code>ls_evolver::LevelSetEvolution</code>: Solver for the evolution and reinitisation equations.</li><li><code>vel_ext::VelocityExtension</code>: The velocity-extension method for extending  shape sensitivities onto the computational domain.</li><li><code>projector::HilbertianProjectionMap</code>: Sensitivity information projector</li><li><code>history::OptimiserHistory{Float64}</code>: Historical information for optimisation problem.</li><li><code>converged::Function</code>: A function to check optimiser convergence. </li><li><code>has_oscillations::Function</code>: A function to check for oscillations.</li><li><code>params::NamedTuple</code>: Optimisation parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zjwegert/GridapTopOpt.jl/blob/78474ca09366934fd6cc603408f07ba85a1d4aa6/src/Optimisers/HilbertianProjection.jl#L126-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GridapTopOpt.HilbertianProjection-Union{Tuple{N}, Tuple{PDEConstrainedFunctionals{N}, GridapTopOpt.LevelSetEvolution, VelocityExtension, Any}} where N" href="#GridapTopOpt.HilbertianProjection-Union{Tuple{N}, Tuple{PDEConstrainedFunctionals{N}, GridapTopOpt.LevelSetEvolution, VelocityExtension, Any}} where N"><code>GridapTopOpt.HilbertianProjection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HilbertianProjection(
  problem :: PDEConstrainedFunctionals{N},
  ls_evolver :: LevelSetEvolution,
  vel_ext :: VelocityExtension,
  φ0;
  orthog = HPModifiedGramSchmidt(),
  λ=0.5, α_min=0.1, α_max=1.0, γ=0.1, γ_reinit=0.5,
  ls_max_iters = 10, ls_δ_inc = 1.1, ls_δ_dec = 0.7,
  ls_ξ = 0.0025, ls_ξ_reduce_coef = 0.1, ls_ξ_reduce_abs_tol = 0.01,
  ls_γ_min = 0.001, ls_γ_max = 0.1,
  maxiter = 1000, verbose=false, constraint_names = map(i -&gt; Symbol(&quot;C_$i&quot;),1:N),
  converged::Function = default_hp_converged, debug = false
) where {N}</code></pre><p>Create an instance of <code>HilbertianProjection</code> with several adjustable defaults including the orthogonalisation method. By default the later is <a href="#GridapTopOpt.HPModifiedGramSchmidt"><code>HPModifiedGramSchmidt</code></a>.</p><p><strong>Required</strong></p><ul><li><code>problem::PDEConstrainedFunctionals{N}</code>: The objective and constraint setup.</li><li><code>ls_evolver::LevelSetEvolution</code>: Solver for the evolution and reinitisation equations.</li><li><code>vel_ext::VelocityExtension</code>: The velocity-extension method for extending  shape sensitivities onto the computational domain.</li><li><code>φ0</code>: An initial level-set function defined as a FEFunction or GridapDistributed equivilent.</li></ul><p><strong>Algorithm defaults</strong></p><ul><li><code>γ = 0.1</code>: Initial coeffient on the time step size for solving the Hamilton-Jacobi evolution equation.</li><li><code>γ_reinit = 0.5</code>: Coeffient on the time step size for solving the reinitisation equation.</li><li><code>maxiter = 1000</code>: Maximum number of algorithm iterations.</li><li><code>verbose=false</code>: Verbosity flag.</li><li><code>constraint_names = map(i -&gt; Symbol(&quot;C_$i&quot;),1:N)</code>: Constraint names for history output.</li><li><code>converged::Function = default_hp_converged</code>: Convergence criteria.</li><li><code>has_oscillations::Function = (ls_enabled ? (args...)-&gt;false : default_has_oscillations</code>: By default this is disabled when a line search in enabled.</li><li><code>os_γ_mult = 0.5</code>: Decrease multiplier for <code>γ</code> when <code>has_oscillations</code> returns true</li><li><code>debug = false</code>: Debug flag.</li><li><code>α_min ∈ [0,1] = 0.1</code>: Controls lower bound on on the projected objective descent coefficent. <code>α_min = 1</code> ignores the objective function and instead solves a constraint satisfaction problem. </li><li><code>α_max ∈ [0,1] = 1.0</code>: Controls the upper bound on the projected objective descent coeffient. Typically this shouldn&#39;t change unless wanting to approach the optimum &#39;slower&#39;.</li><li><code>λ = 0.5</code>: The rate of contraint decrease.</li></ul><p>Note that in practice we usually only adjust <code>α_min</code> to control the balance between improving the  objective or constraints. </p><p><strong>Line search defaults</strong></p><ul><li><code>ls_enabled = true</code>: Set whether a line search is used.</li><li><code>ls_max_iters = 10</code>: Maximum number of line search iterations. </li><li><code>ls_δ_inc = 1.1</code>: Increase multiplier for <code>γ</code> on acceptance.</li><li><code>ls_δ_dec = 0.7</code>: Decrease multiplier for <code>γ</code> on rejection.</li><li><code>ls_ξ = 0.0025</code>: Line search tolerance for objective reduction. </li><li><code>ls_ξ_reduce_coef = 0.1</code>: Coeffient on <code>ls_ξ</code> if constraints within tolerance (see below).</li><li><code>ls_ξ_reduce_abs_tol = 0.01</code>: Tolerance on constraints to reduce <code>ls_ξ</code> via <code>ls_ξ_reduce_coef</code>.</li><li><code>ls_γ_min = 0.001</code>: Minimum coeffient on the time step size for solving the HJ evolution equation.</li><li><code>ls_γ_max = 0.1</code>: Maximum coeffient on the time step size for solving the HJ evolution equation.</li></ul><p>A more concervative evolution of the boundary can be achieved by decreasing <code>ls_γ_max</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For some problems (e.g., inverter mechanism), we have observed that a simple oscillation detection algorithm leads to better convergence compared to the line search. By default  disabling the line search via <code>ls_enabled = false</code> will enable oscillation detection. </p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zjwegert/GridapTopOpt.jl/blob/78474ca09366934fd6cc603408f07ba85a1d4aa6/src/Optimisers/HilbertianProjection.jl#L155-L220">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GridapTopOpt.HPModifiedGramSchmidt" href="#GridapTopOpt.HPModifiedGramSchmidt"><code>GridapTopOpt.HPModifiedGramSchmidt</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HPModifiedGramSchmidt</code></pre><p>High performance modified Gram-Schmidt. Based on Algorithm 6 in this <a href="https://doi.org/10.1007/s13160-019-00356-4">paper</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zjwegert/GridapTopOpt.jl/blob/78474ca09366934fd6cc603408f07ba85a1d4aa6/src/Optimisers/OrthogonalisationMaps.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GridapTopOpt.OrthogonalisationMap" href="#GridapTopOpt.OrthogonalisationMap"><code>GridapTopOpt.OrthogonalisationMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OrthogonalisationMap</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zjwegert/GridapTopOpt.jl/blob/78474ca09366934fd6cc603408f07ba85a1d4aa6/src/Optimisers/OrthogonalisationMaps.jl#L2-L4">source</a></section></article><h2 id="Optimiser-history"><a class="docs-heading-anchor" href="#Optimiser-history">Optimiser history</a><a id="Optimiser-history-1"></a><a class="docs-heading-anchor-permalink" href="#Optimiser-history" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GridapTopOpt.OptimiserHistory" href="#GridapTopOpt.OptimiserHistory"><code>GridapTopOpt.OptimiserHistory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct OptimiserHistory{T}</code></pre><p>Track historical information on optimisation problem iteration history.</p><p><strong>Parameters</strong></p><ul><li><code>niter::Int</code>: Current iteration number</li><li><code>keys::Vector{Symbol}</code>: Vector of symbols associated to values</li><li><code>values::Dict{Symbol,Vector{T}}</code>: Dictionary of vectors associated to keys</li><li><code>bundles::Dict{Symbol,Vector{Symbol}}</code>: Groups of symbols (e.g., a group of constraints)</li><li><code>verbose::SolverVerboseLevel</code>: Verbosity level</li><li><code>maxiter::Int</code>: Maximum number of iterations.</li></ul><p><strong>Behaviour</strong></p><ul><li>Indexing at a specific iteration returns an OptimiserHistorySlice.</li><li>Indexing with a key returns all values of that key</li><li>Indexing with a key and iteration returns value/s of the key at the iteration.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zjwegert/GridapTopOpt.jl/blob/78474ca09366934fd6cc603408f07ba85a1d4aa6/src/Optimisers/Optimisers.jl#L66-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GridapTopOpt.OptimiserHistorySlice" href="#GridapTopOpt.OptimiserHistorySlice"><code>GridapTopOpt.OptimiserHistorySlice</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct OptimiserHistorySlice{T} end</code></pre><p>A read-only wrapper of OptimiserHistory for IO display of iteration history at a specific iteration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zjwegert/GridapTopOpt.jl/blob/78474ca09366934fd6cc603408f07ba85a1d4aa6/src/Optimisers/Optimisers.jl#L224-L229">source</a></section></article><h2 id="Custom-optimiser"><a class="docs-heading-anchor" href="#Custom-optimiser">Custom optimiser</a><a id="Custom-optimiser-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-optimiser" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GridapTopOpt.Optimiser" href="#GridapTopOpt.Optimiser"><code>GridapTopOpt.Optimiser</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Optimiser</code></pre><p>Optimisers in GridapTopOpt.jl are implemented as iterators. Your own optimiser can be implemented by implementing concrete functionality of the below.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zjwegert/GridapTopOpt.jl/blob/78474ca09366934fd6cc603408f07ba85a1d4aa6/src/Optimisers/Optimisers.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.iterate-Tuple{GridapTopOpt.Optimiser}" href="#Base.iterate-Tuple{GridapTopOpt.Optimiser}"><code>Base.iterate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.iterate(::Optimiser)</code></pre><p>Return tuple of first iteration state for <code>Optimiser</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zjwegert/GridapTopOpt.jl/blob/78474ca09366934fd6cc603408f07ba85a1d4aa6/src/Optimisers/Optimisers.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.iterate-Tuple{GridapTopOpt.Optimiser, Any}" href="#Base.iterate-Tuple{GridapTopOpt.Optimiser, Any}"><code>Base.iterate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.iterate(::Optimiser,state)</code></pre><p>Return tuple of next iteration state given current state for <code>Optimiser</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zjwegert/GridapTopOpt.jl/blob/78474ca09366934fd6cc603408f07ba85a1d4aa6/src/Optimisers/Optimisers.jl#L26-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GridapTopOpt.get_history-Tuple{GridapTopOpt.Optimiser}" href="#GridapTopOpt.get_history-Tuple{GridapTopOpt.Optimiser}"><code>GridapTopOpt.get_history</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_history(::Optimiser) :: OptimiserHistory</code></pre><p>Get <code>OptimiserHistory</code> from <code>Optimiser</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zjwegert/GridapTopOpt.jl/blob/78474ca09366934fd6cc603408f07ba85a1d4aa6/src/Optimisers/Optimisers.jl#L36-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GridapTopOpt.converged-Tuple{GridapTopOpt.Optimiser}" href="#GridapTopOpt.converged-Tuple{GridapTopOpt.Optimiser}"><code>GridapTopOpt.converged</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">converged(::Optimiser)</code></pre><p>Return a <code>Bool</code> that is true if the <code>Optimiser</code> has converged, otherwise false.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zjwegert/GridapTopOpt.jl/blob/78474ca09366934fd6cc603408f07ba85a1d4aa6/src/Optimisers/Optimisers.jl#L43-L48">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../getting-started/">« Getting Started</a><a class="docs-footer-nextpage" href="../chainrules/">ChainRules »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Wednesday 15 May 2024 00:58">Wednesday 15 May 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
