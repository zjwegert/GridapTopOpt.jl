var documenterSearchIndex = {"docs":
[{"location":"reference/embedded/#Embedded","page":"Embedded","title":"Embedded","text":"","category":"section"},{"location":"reference/embedded/","page":"Embedded","title":"Embedded","text":"warning: Warning\nThis page is still under construction! Please refer to the tutorial for a discussion of functionality.","category":"page"},{"location":"reference/embedded/","page":"Embedded","title":"Embedded","text":"warning: Warning\nNon-TET/TRI polytopes are simplexified by GridapEmbedded when cutting. As a result, derivative information from AD will not be correct when using a mesh that isn't made of TRI/TET. Please use a mesh with TRI/TET polytopes to ensure correctness of derivative results.","category":"page"},{"location":"reference/embedded/#Isolated-volumes","page":"Embedded","title":"Isolated volumes","text":"","category":"section"},{"location":"reference/embedded/#GridapTopOpt.get_isolated_volumes_mask-Tuple{GridapEmbedded.Interfaces.EmbeddedDiscretization, Any}","page":"Embedded","title":"GridapTopOpt.get_isolated_volumes_mask","text":"get_isolated_volumes_mask(cutgeo::EmbeddedDiscretization,dirichlet_tags)\n\nGiven an EmbeddedDiscretization cutgeo and a list of tags dirichlet_tags, this function returns a CellField which is 1 on isolated volumes and 0 otherwise.\n\nWe define an isolated volume as a volume that is IN but is not constrained by any of the tags in dirichlet_tags. Specify the In domain using the first entry in groups.\n\nIf remove_cuts is true, then volumes that only contain CUT cells are also considered isolated.\n\n\n\n\n\n","category":"method"},{"location":"reference/embedded/#GridapTopOpt.tag_disconnected_volumes-Union{Tuple{Dc}, Tuple{Gridap.Geometry.DiscreteModel{Dc}, Vector{<:Integer}}} where Dc","page":"Embedded","title":"GridapTopOpt.tag_disconnected_volumes","text":"function tag_disconnected_volumes(\n    model::DiscreteModel{Dc},\n    cell_to_state::Vector{<:Integer};\n    groups = Tuple(unique(cell_to_state))\n)\n\nGiven a DiscreteModel model and an initial coloring cell_to_state, returns another coloring such that each color corresponds to a connected component of the graph of cells that are connected by a face and have their state in the same group.\n\n\n\n\n\n","category":"method"},{"location":"reference/embedded/#GridapTopOpt.tag_volume!-Union{Tuple{N}, Tuple{Int64, Int16, Union{Integer, NTuple{N, Integer}}, Vector{Vector{Int32}}, Vector{Int8}, Vector{Int16}, BitVector}} where N","page":"Embedded","title":"GridapTopOpt.tag_volume!","text":"function tag_volume!(\n    cell::Int,color::Int16,group::Union{Integer,NTuple{N,Integer}},\n    cell_to_nbors::Vector{Vector{Int32}},\n    cell_to_state::Vector{Int8},\n    cell_to_color::Vector{Int16},\n    touched::BitVector\n)\n\nStarting from a cell cell, crawls the cell graph provided by cell_to_nbors and colors all cells connected to cell that\n\nbelong to the group group (i.e., cell_to_state[cell] ∈ group), and\nhave not been seen yet (i.e., !touched[cell]).\n\nThis is done by using a breadth-first search algorithm.\n\n\n\n\n\n","category":"method"},{"location":"reference/embedded/#GridapTopOpt.get_isolated_volumes_mask_polytopal-Tuple{Gridap.Geometry.DiscreteModel, Any, Any}","page":"Embedded","title":"GridapTopOpt.get_isolated_volumes_mask_polytopal","text":"get_isolated_volumes_mask_polytopal(model::DiscreteModel,cell_values,dirichlet_tags)\n\nGiven a DiscreteModel model, the cell values of the level set function cell_values, and a list of tags dirichlet_tags, this function returns two cell fields:\n\ncf_IN: a CellField which is 1 on isolated volumes of the IN domain and 0 otherwise.\ncf_OUT: a CellField which is 1 on isolated volumes of the OUT domain and 0 otherwise.\n\n\n\n\n\n","category":"method"},{"location":"reference/embedded/#EmbeddedCollection-and-EmbeddedPDEConstrainedFunctionals","page":"Embedded","title":"EmbeddedCollection and EmbeddedPDEConstrainedFunctionals","text":"","category":"section"},{"location":"reference/embedded/#GridapTopOpt.EmbeddedCollection","page":"Embedded","title":"GridapTopOpt.EmbeddedCollection","text":"struct EmbeddedCollection\n  recipes :: Vector{<:Function}\n  objects :: Dict{Symbol,Any}\n  bgmodel :: DiscreteModel\nend\n\nA collection of embedded objects on the same background model. This structure provides a way to update all the stored objects at once.\n\nConstructor\n\nEmbeddedCollection(recipes::Union{<:Function,Vector{<:Function}},bgmodel::DiscreteModel[,φh])\n\nIf provided, φh will be used to compute the initial collection of objects. If not provided, the collection will remain empty until update_collection! is called.\n\nAPI:\n\nupdate_collection!(c::EmbeddedCollection,φh): Update the collection of objects using the level set function φh.\nadd_recipe!(c::EmbeddedCollection,r::Function[,φh]): Add a recipe to the collection. Update the collection if φh is provided.\n\n\n\n\n\n","category":"type"},{"location":"reference/embedded/","page":"Embedded","title":"Embedded","text":"We implement special structures that update the state map etc. on the fly using EmbeddedPDEConstrainedFunctionals:","category":"page"},{"location":"reference/embedded/#GridapTopOpt.EmbeddedCollection_in_φh","page":"Embedded","title":"GridapTopOpt.EmbeddedCollection_in_φh","text":"EmbeddedCollection_in_φh(recipes::Union{<:Function,Vector{<:Function}},bgmodel,φ0)\n\nReturns an EmbeddedCollection whoose recipes are only updated using the parameter φ0. This is useful for problems where the recipes are not computed using the cut geometry information.\n\n\n\n\n\n","category":"function"},{"location":"reference/embedded/#GridapTopOpt.EmbeddedPDEConstrainedFunctionals","page":"Embedded","title":"GridapTopOpt.EmbeddedPDEConstrainedFunctionals","text":"mutable struct EmbeddedPDEConstrainedFunctionals{N} <: AbstractPDEConstrainedFunctionals{N}\n\nA mutable version of PDEConstrainedFunctionals that allows state_map to be updated given new FE spaces for the forward problem. This is currently required for body-fitted mesh methods and unfitted methods.\n\n\n\n\n\n","category":"type"},{"location":"reference/embedded/#GridapTopOpt.evaluate_functionals!-Tuple{EmbeddedPDEConstrainedFunctionals, Any}","page":"Embedded","title":"GridapTopOpt.evaluate_functionals!","text":"evaluate_functionals!(pcf::EmbeddedPDEConstrainedFunctionals,φh;update_space::Bool=true)\n\nEvaluate the objective and constraints at φh.\n\nwarning: Warning\nTaking update_space = false will NOT update the underlying finite element spaces and assemblers that depend on φh. This should only be used when you are certain that φh has not been updated.\n\n\n\n\n\n","category":"method"},{"location":"reference/embedded/#GridapTopOpt.evaluate_derivatives!-Tuple{EmbeddedPDEConstrainedFunctionals, Any}","page":"Embedded","title":"GridapTopOpt.evaluate_derivatives!","text":"evaluate_derivatives!(pcf::EmbeddedPDEConstrainedFunctionals,φh;update_space::Bool=true)\n\nEvaluate the derivatives of the objective and constraints at φh.\n\nwarning: Warning\nTaking update_space = false will NOT update the underlying finite element spaces and assemblers that depend on φh. This should only be used when you are certain that φh has not been updated.\n\n\n\n\n\n","category":"method"},{"location":"reference/embedded/#Gridap.Arrays.evaluate!-Tuple{EmbeddedPDEConstrainedFunctionals, Any}","page":"Embedded","title":"Gridap.Arrays.evaluate!","text":"Fields.evaluate!(pcf::EmbeddedPDEConstrainedFunctionals,φh;update_space::Bool=true)\n\nEvaluate the objective and constraints, and their derivatives at φh.\n\nwarning: Warning\nTaking update_space = false will NOT update the underlying finite element spaces and assemblers that depend on φh. This should only be used when you are certain that φh has not been updated.\n\n\n\n\n\n","category":"method"},{"location":"reference/embedded/#Automatic-shape-differentiation","page":"Embedded","title":"Automatic shape differentiation","text":"","category":"section"},{"location":"reference/embedded/","page":"Embedded","title":"Embedded","text":"Automatic shape differentiation has been moved to GridapEmbedded.","category":"page"},{"location":"reference/benchmarking/#Benchmarking","page":"Benchmarking","title":"Benchmarking","text":"","category":"section"},{"location":"reference/benchmarking/#GridapTopOpt.benchmark","page":"Benchmarking","title":"GridapTopOpt.benchmark","text":"benchmark(f, args, ranks; nreps, reset!)\n\nBenchmark a function f that takes arguments args.\n\nIn MPI mode, benchmark will always return the maximum CPU time across all ranks. This behaviour can be changed by overwritting process_timer.\n\nImportant\n\nThe input ranks allows the user to provide the MPI ranks, benchmark will not function correctly in MPI mode if these are not supplied. In serial, set ranks = nothing.\n\nOptional\n\nnreps = 10: Number of benchmark repetitions\nreset!= (x...) -> nothing: Function for resetting inital data (e.g., level-set function varphi).\n\n\n\n\n\n","category":"function"},{"location":"reference/benchmarking/#Existing-benchmark-methods","page":"Benchmarking","title":"Existing benchmark methods","text":"","category":"section"},{"location":"reference/benchmarking/#GridapTopOpt.benchmark_optimizer","page":"Benchmarking","title":"GridapTopOpt.benchmark_optimizer","text":"benchmark_optimizer(m::Optimiser, niter, ranks; nreps)\n\nGiven an optimiser m, benchmark niter iterations.\n\n\n\n\n\n","category":"function"},{"location":"reference/benchmarking/#GridapTopOpt.benchmark_single_iteration","page":"Benchmarking","title":"GridapTopOpt.benchmark_single_iteration","text":"benchmark_single_iteration(m::Optimiser, ranks; nreps)\n\nGiven an optimiser m, benchmark a single iteration after 0th iteration.\n\n\n\n\n\n","category":"function"},{"location":"reference/benchmarking/#GridapTopOpt.benchmark_forward_problem","page":"Benchmarking","title":"GridapTopOpt.benchmark_forward_problem","text":"benchmark_forward_problem(m::AbstractFEStateMap, φh, ranks; nreps)\n\nBenchmark the forward FE solve given m::AbstractFEStateMap and a level-set function φh. See forward_solve! for input types.\n\n\n\n\n\n","category":"function"},{"location":"reference/benchmarking/#GridapTopOpt.benchmark_advection","page":"Benchmarking","title":"GridapTopOpt.benchmark_advection","text":"benchmark_advection(stencil::LevelSetEvolution, φ0, v0, γ, ranks; nreps)\n\nBenchmark solving the Hamilton-Jacobi evolution equation given a stencil, level-set function φ0, velocity function v0, and time step coefficient γ. See evolve! for input types.\n\n\n\n\n\n","category":"function"},{"location":"reference/benchmarking/#GridapTopOpt.benchmark_reinitialisation","page":"Benchmarking","title":"GridapTopOpt.benchmark_reinitialisation","text":"benchmark_reinitialisation(stencil::LevelSetEvolution, φ0, γ_reinit, ranks; nreps)\n\nBenchmark solving the reinitialisation equation given a stencil, level-set function φ0, and time step coefficient γ. See reinit! for input types.\n\n\n\n\n\n","category":"function"},{"location":"reference/benchmarking/#GridapTopOpt.benchmark_velocity_extension","page":"Benchmarking","title":"GridapTopOpt.benchmark_velocity_extension","text":"benchmark_velocity_extension(ext::VelocityExtension, v0, ranks; nreps)\n\nBenchmark the Hilbertian velocity-extension method ext given a RHS v0. See project! for input types.\n\n\n\n\n\n","category":"function"},{"location":"reference/benchmarking/#GridapTopOpt.benchmark_hilbertian_projection_map","page":"Benchmarking","title":"GridapTopOpt.benchmark_hilbertian_projection_map","text":"benchmark_hilbertian_projection_map(m::HilbertianProjectionMap, dV, C, dC, K, ranks; nreps)\n\nBenchmark update_descent_direction! for HilbertianProjectionMap given a objective sensitivity dV, constraint values C, constraint sensitivities dC, and stiffness matrix K for the velocity-extension.\n\n\n\n\n\n","category":"function"},{"location":"reference/levelsetevolution/#LevelSetEvolution","page":"LevelSetEvolution","title":"LevelSetEvolution","text":"","category":"section"},{"location":"reference/levelsetevolution/","page":"LevelSetEvolution","title":"LevelSetEvolution","text":"In GridapTopOpt, the level-set function is evolved and reinitialised using implementations of LevelSetEvolution. We provide the following implementations of this:","category":"page"},{"location":"reference/levelsetevolution/","page":"LevelSetEvolution","title":"LevelSetEvolution","text":"Finite differences\nUnfitted finite element methods","category":"page"},{"location":"reference/levelsetevolution/#Custom-LevelSetEvolution","page":"LevelSetEvolution","title":"Custom LevelSetEvolution","text":"","category":"section"},{"location":"reference/levelsetevolution/","page":"LevelSetEvolution","title":"LevelSetEvolution","text":"To implement a custom level-set evolution method, the following methods can be extended. For example, one could consider Reaction-Diffusion-based evolution of the level set function. This can be solved with a finite element method and so we can implement a new type that inherits from LevelSetEvolution independently of the Stencil types.","category":"page"},{"location":"reference/levelsetevolution/#GridapTopOpt.LevelSetEvolution","page":"LevelSetEvolution","title":"GridapTopOpt.LevelSetEvolution","text":"abstract type LevelSetEvolution\n\nYour own evolution method can be implemented by implementing  concrete functionality of the below.\n\n\n\n\n\n","category":"type"},{"location":"reference/levelsetevolution/#GridapTopOpt.evolve!-Tuple{GridapTopOpt.LevelSetEvolution, Any, Vararg{Any}}","page":"LevelSetEvolution","title":"GridapTopOpt.evolve!","text":"evolve!(::LevelSetEvolution,φ,args...)\n\nEvolve the level set function φ according to an evolution method LevelSetEvolution.\n\n\n\n\n\n","category":"method"},{"location":"reference/levelsetevolution/#GridapTopOpt.reinit!-Tuple{GridapTopOpt.LevelSetEvolution, Any, Vararg{Any}}","page":"LevelSetEvolution","title":"GridapTopOpt.reinit!","text":"reinit!(::LevelSetEvolution,φ,args...)\n\nReinitialise the level set function φ according to an evolution method LevelSetEvolution.\n\n\n\n\n\n","category":"method"},{"location":"reference/levelsetevolution/#GridapTopOpt.get_dof_Δ-Tuple{GridapTopOpt.LevelSetEvolution}","page":"LevelSetEvolution","title":"GridapTopOpt.get_dof_Δ","text":"get_dof_Δ(::LevelSetEvolution)\n\nReturn the distance betweem degree of freedom\n\n\n\n\n\n","category":"method"},{"location":"reference/levelsetevolution/finitediff/#Upwind-finite-difference-schemes","page":"Upwind finite difference schemes","title":"Upwind finite difference schemes","text":"","category":"section"},{"location":"reference/levelsetevolution/finitediff/","page":"Upwind finite difference schemes","title":"Upwind finite difference schemes","text":"The most standard scheme of solving the Hamilton-Jacobi evolution equation and reinitialisation equation is a first order upwind finite difference scheme. A forward Euler in time method is provided below via HamiltonJacobiEvolution <: LevelSetEvolution along with an upwind finite difference stencil for the spatial discretisation via FirstOrderStencil.","category":"page"},{"location":"reference/levelsetevolution/finitediff/","page":"Upwind finite difference schemes","title":"Upwind finite difference schemes","text":"This can be extended in several ways. For example, higher order spatial stencils can be implemented by extending the Stencil interface below. In addition, more advanced ODE solvers could be implemented (e.g., Runge–Kutta methods) or entirely different level set evolution methods by extending the LevelSetEvolution interface below.","category":"page"},{"location":"reference/levelsetevolution/finitediff/#HamiltonJacobiEvolution","page":"Upwind finite difference schemes","title":"HamiltonJacobiEvolution","text":"","category":"section"},{"location":"reference/levelsetevolution/finitediff/#GridapTopOpt.HamiltonJacobiEvolution","page":"Upwind finite difference schemes","title":"GridapTopOpt.HamiltonJacobiEvolution","text":"struct HamiltonJacobiEvolution{O}\n\nA standard forward Euler in time finite difference method for solving the Hamilton-Jacobi evolution equation and reinitialisation equation on order O finite elements in serial or parallel.\n\nBased on the scheme by Osher and Fedkiw (link).\n\nParameters\n\nstencil::Stencil: Spatial finite difference stencil for a single step HJ equation and reinitialisation equation.\nmodel: A CartesianDiscreteModel.\nspace: FE space for level-set function\nperm: A permutation vector\nparams: Tuple of additional params\ncache: Stencil cache\n\n\n\n\n\n","category":"type"},{"location":"reference/levelsetevolution/finitediff/#GridapTopOpt.HamiltonJacobiEvolution-2","page":"Upwind finite difference schemes","title":"GridapTopOpt.HamiltonJacobiEvolution","text":"HamiltonJacobiEvolution(stencil::Stencil,model,space,tol,max_steps,max_steps_reinit)\n\nCreate an instance of HamiltonJacobiEvolution given a stencil, model, FE space, and additional optional arguments. This automatically creates the DoF permutation to handle high-order finite elements.\n\n\n\n\n\n","category":"type"},{"location":"reference/levelsetevolution/finitediff/#GridapTopOpt.evolve!","page":"Upwind finite difference schemes","title":"GridapTopOpt.evolve!","text":"evolve!(::LevelSetEvolution,φ,args...)\n\nEvolve the level set function φ according to an evolution method LevelSetEvolution.\n\n\n\n\n\nevolve!(::Stencil,φ,vel,Δt,Δx,isperiodic,caches) -> φ\n\nSingle finite difference step of the Hamilton-Jacobi evoluation equation for a given Stencil.\n\n\n\n\n\nevolve!(s::HamiltonJacobiEvolution{O},φ,vel,γ) where O\n\nSolve the Hamilton-Jacobi evolution equation using the HamiltonJacobiEvolution.\n\nHamilton-Jacobi evolution equation\n\nfracpartialphipartial t + V(boldsymbolx)lVertboldsymbolnablaphirVert = 0\n\nwith phi(0boldsymbolx)=phi_0(boldsymbolx) and boldsymbolxin Dtin(0T).\n\nArguments\n\ns::HamiltonJacobiEvolution{O}: Method\nφ: level set function as a vector of degrees of freedom\nvel: the normal velocity as a vector of degrees of freedom\nγ: coeffient on the time step size.\n\n\n\n\n\n","category":"function"},{"location":"reference/levelsetevolution/finitediff/#GridapTopOpt.reinit!","page":"Upwind finite difference schemes","title":"GridapTopOpt.reinit!","text":"reinit!(::LevelSetEvolution,φ,args...)\n\nReinitialise the level set function φ according to an evolution method LevelSetEvolution.\n\n\n\n\n\nreinit!(::Stencil,φ_new,φ,vel,Δt,Δx,isperiodic,caches) -> φ\n\nSingle finite difference step of the reinitialisation equation for a given Stencil.\n\n\n\n\n\nreinit!(s::HamiltonJacobiEvolution{O},φ,γ) where O\n\nSolve the reinitialisation equation using the HamiltonJacobiEvolution.\n\nReinitialisation equation\n\nfracpartialphipartial t + mathrmsign(phi_0)(lVertboldsymbolnablaphirVert-1) = 0\n\nwith phi(0boldsymbolx)=phi_0(boldsymbolx) and boldsymbolxin Dtin(0T).\n\nArguments\n\ns::HamiltonJacobiEvolution{O}: Method\nφ: level set function as a vector of degrees of freedom\nγ: coeffient on the time step size.\n\n\n\n\n\n","category":"function"},{"location":"reference/levelsetevolution/finitediff/#GridapTopOpt.get_dof_Δ-Tuple{HamiltonJacobiEvolution}","page":"Upwind finite difference schemes","title":"GridapTopOpt.get_dof_Δ","text":"get_dof_Δ(m::HamiltonJacobiEvolution)\n\nReturn the distance betweem degree of freedom\n\n\n\n\n\n","category":"method"},{"location":"reference/levelsetevolution/finitediff/#Spatial-stencils-for-HamiltonJacobiEvolution","page":"Upwind finite difference schemes","title":"Spatial stencils for HamiltonJacobiEvolution","text":"","category":"section"},{"location":"reference/levelsetevolution/finitediff/#GridapTopOpt.FirstOrderStencil","page":"Upwind finite difference schemes","title":"GridapTopOpt.FirstOrderStencil","text":"struct FirstOrderStencil{D,T} <: Stencil end\n\nA first order upwind difference scheme based on Osher and Fedkiw (link).\n\n\n\n\n\n","category":"type"},{"location":"reference/levelsetevolution/finitediff/#Custom-Stencil","page":"Upwind finite difference schemes","title":"Custom Stencil","text":"","category":"section"},{"location":"reference/levelsetevolution/finitediff/#GridapTopOpt.Stencil","page":"Upwind finite difference schemes","title":"GridapTopOpt.Stencil","text":"abstract type Stencil\n\nFinite difference stencil for a single step of the Hamilton-Jacobi evolution equation and reinitialisation equation.\n\nYour own spatial stencil can be implemented by extending the methods below.\n\n\n\n\n\n","category":"type"},{"location":"reference/levelsetevolution/finitediff/#GridapTopOpt.evolve!-Tuple{GridapTopOpt.Stencil, Vararg{Any, 6}}","page":"Upwind finite difference schemes","title":"GridapTopOpt.evolve!","text":"evolve!(::Stencil,φ,vel,Δt,Δx,isperiodic,caches) -> φ\n\nSingle finite difference step of the Hamilton-Jacobi evoluation equation for a given Stencil.\n\n\n\n\n\n","category":"method"},{"location":"reference/levelsetevolution/finitediff/#GridapTopOpt.reinit!-Tuple{GridapTopOpt.Stencil, Vararg{Any, 7}}","page":"Upwind finite difference schemes","title":"GridapTopOpt.reinit!","text":"reinit!(::Stencil,φ_new,φ,vel,Δt,Δx,isperiodic,caches) -> φ\n\nSingle finite difference step of the reinitialisation equation for a given Stencil.\n\n\n\n\n\n","category":"method"},{"location":"reference/levelsetevolution/finitediff/#GridapTopOpt.allocate_caches-Tuple{GridapTopOpt.Stencil, Any, Any}","page":"Upwind finite difference schemes","title":"GridapTopOpt.allocate_caches","text":"allocate_caches(::Stencil,φ,vel)\n\nAllocate caches for a given Stencil.\n\n\n\n\n\n","category":"method"},{"location":"reference/levelsetevolution/finitediff/#GridapTopOpt.check_order","page":"Upwind finite difference schemes","title":"GridapTopOpt.check_order","text":"check_order(::Stencil,order)\n\nThrow error if insufficient reference element order to implement stencil in parallel.\n\n\n\n\n\n","category":"function"},{"location":"reference/velext/#Velocity-extension","page":"Velocity extension","title":"Velocity extension","text":"","category":"section"},{"location":"reference/velext/#GridapTopOpt.AbstractVelocityExtension","page":"Velocity extension","title":"GridapTopOpt.AbstractVelocityExtension","text":"abstract type AbstractVelocityExtension end\n\nAn abstract type for velocity extension structures. Structs that inherit from   this type must implement the project! method.\n\n\n\n\n\n","category":"type"},{"location":"reference/velext/#GridapTopOpt.IdentityVelocityExtension","page":"Velocity extension","title":"GridapTopOpt.IdentityVelocityExtension","text":"struct IdentityVelocityExtension <: AbstractVelocityExtension\n\nA velocity-extension method that does nothing.\n\n\n\n\n\n","category":"type"},{"location":"reference/velext/#GridapTopOpt.VelocityExtension","page":"Velocity extension","title":"GridapTopOpt.VelocityExtension","text":"struct VelocityExtension{A,B} <: AbstractVelocityExtension\n\nWrapper to hold a stiffness matrix and a cache for the Hilbertian extension-regularisation. See Allaire et al. 2022 (link).\n\nThe Hilbertian extension-regularisation method involves solving an identification problem over a Hilbert space H on D with inner product langlecdotcdotrangle_H: Find g_Omegain H such that langle g_Omegawrangle_H =-J^prime(Omega)(wboldsymboln) forall win H\n\nThis provides two benefits:\n\nIt naturally extends the shape sensitivity from partialOmega onto the bounding domain D; and\nensures a descent direction for J(Omega) with additional regularity (i.e., H as opposed to L^2(partialOmega))\n\nProperties\n\nK::A: The discretised inner product over H.\ncache::B: Cached objects used for project!\n\n\n\n\n\n","category":"type"},{"location":"reference/velext/#GridapTopOpt.VelocityExtension-Tuple{Function, Gridap.FESpaces.FESpace, Gridap.FESpaces.FESpace}","page":"Velocity extension","title":"GridapTopOpt.VelocityExtension","text":"VelocityExtension(biform,U_reg,V_reg;assem,ls)\n\nCreate an instance of VelocityExtension given a bilinear form biform, trial space U_reg, and test space V_reg.\n\nOptional\n\nassem: A matrix assembler\nls::LinearSolver: A linear solver\n\n\n\n\n\n","category":"method"},{"location":"reference/velext/#GridapTopOpt.project!-Tuple{VelocityExtension, AbstractVector}","page":"Velocity extension","title":"GridapTopOpt.project!","text":"project!(vel_ext::VelocityExtension,dF::AbstractVector) -> dF\n\nProject shape derivative dF onto a function space described by the vel_ext.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#Getting-started","page":"Getting Started","title":"Getting started","text":"","category":"section"},{"location":"getting-started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"GridapTopOpt.jl and additional dependencies can be installed in an existing Julia environment using the package manager. This can be accessed in the Julia REPL (read-eval–print loop) by pressing ]. We then add the required packages via:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"pkg> add GridapTopOpt, Gridap, GridapDistributed, GridapPETSc, GridapSolvers, PartitionedArrays, SparseMatricesCSR","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Once installed, serial driver scripts can be run immediately, whereas parallel problems also require an MPI installation.","category":"page"},{"location":"getting-started/#MPI","page":"Getting Started","title":"MPI","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"For basic users, MPI.jl provides such an implementation and a Julia wrapper for mpiexec - the MPI executor. This is installed via:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"pkg> add MPI\njulia> using MPI\njulia> MPI.install_mpiexecjl()","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Once the mpiexecjl wrapper has been added to the system PATH, MPI scripts can be executed in a terminal via","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"mpiexecjl -n P julia  main.jl","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"where main is a driver script, P denotes the number of processors.","category":"page"},{"location":"getting-started/#PETSc","page":"Getting Started","title":"PETSc","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"In GridapTopOpt.jl we rely on the GridapPETSc.jl satellite package to interface with the linear and nonlinear solvers provided by the PETSc (Portable, Extensible Toolkit for Scientific Computation) library. For basic users these solvers are provided by GridapPETSc.jl with no additional work.","category":"page"},{"location":"getting-started/#Advanced-installation","page":"Getting Started","title":"Advanced installation","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"For more advanced installations, such as use of a custom MPI/PETSc installation on a HPC cluster, we refer the reader to the discussion for GridapPETSc.jl and the configuration page for MPI.jl.","category":"page"},{"location":"getting-started/#Usage-and-tutorials","page":"Getting Started","title":"Usage and tutorials","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"In order to get familiar with the library we recommend following the numerical examples described in:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Wegert, Z.J., Manyer, J., Mallon, C.N. et al. GridapTopOpt.jl: a scalable Julia toolbox for level set-based topology optimisation. Struct Multidisc Optim 68, 22 (2025). https://doi.org/10.1007/s00158-024-03927-3","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"In addition, there are several driver scripts available in /scripts/..","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"More general tutorials for familiarising ones self with Gridap are available via the Gridap Tutorials.","category":"page"},{"location":"getting-started/#Known-issues","page":"Getting Started","title":"Known issues","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"PETSc's GAMG preconditioner breaks for split Dirichlet DoFs (e.g., x constrained while y free for a single node). There is no simple fix for this. We recommend instead using MUMPS or another preconditioner for this case.\nCurrently, our implementation of automatic differentiation does not support multiplication and division of optimisation functionals. We plan to add this in a future release of GridapTopOpt.jl – Issue #38.\nAnalytic gradient breaks in parallel for integrals of certain measures – Issue #46","category":"page"},{"location":"examples/Fluid-structure_interaction_with_CutFEM/#Fluid-structure-interaction-with-CutFEM","page":"FSI with CutFEM","title":"Fluid-structure interaction with CutFEM","text":"","category":"section"},{"location":"examples/Fluid-structure_interaction_with_CutFEM/","page":"FSI with CutFEM","title":"FSI with CutFEM","text":"note: Note\nThis page is under construction","category":"page"},{"location":"examples/Fluid-structure_interaction_with_CutFEM/","page":"FSI with CutFEM","title":"FSI with CutFEM","text":"The full script for this problem can be found here.","category":"page"},{"location":"reference/io/#IO","page":"IO","title":"IO","text":"","category":"section"},{"location":"reference/io/","page":"IO","title":"IO","text":"In GridapTopOpt, the usual IO from Gridap is available. In addition, we also implement the below IO for convenience.","category":"page"},{"location":"reference/io/#Optimiser-history","page":"IO","title":"Optimiser history","text":"","category":"section"},{"location":"reference/io/#GridapTopOpt.write_history","page":"IO","title":"GridapTopOpt.write_history","text":"write_history(path::String,h::OptimiserHistory;ranks=nothing)\n\nWrite the contents of an OptimiserHistory object to a path. Provide MPI ranks when running in parallel.\n\n\n\n\n\n","category":"function"},{"location":"reference/io/#Object-IO-in-serial","page":"IO","title":"Object IO in serial","text":"","category":"section"},{"location":"reference/io/#GridapTopOpt.save","page":"IO","title":"GridapTopOpt.save","text":"save(filename::AbstractString, x)\n\nSave an object x to filename as a JLD2 file.\n\nNote: To save in MPI mode, use psave.\n\n\n\n\n\n","category":"function"},{"location":"reference/io/#GridapTopOpt.load","page":"IO","title":"GridapTopOpt.load","text":"load(filename::AbstractString)\n\nLoad an object stored in a JLD2 file at filename.\n\nNote: To load in MPI mode, use pload.\n\n\n\n\n\n","category":"function"},{"location":"reference/io/#GridapTopOpt.load!","page":"IO","title":"GridapTopOpt.load!","text":"load!(filename::AbstractString, x)\n\nLoad an object stored in a JLD2 file at filename and copy its contents to x.\n\nNote: To load! in MPI mode, use pload!.\n\n\n\n\n\n","category":"function"},{"location":"reference/io/#Object-IO-in-parallel","page":"IO","title":"Object IO in parallel","text":"","category":"section"},{"location":"reference/io/#GridapTopOpt.psave","page":"IO","title":"GridapTopOpt.psave","text":"psave(filename::AbstractString, x)\n\nSave a partitioned object x to a directory dir as a set of JLD2 files corresponding to each part.\n\n\n\n\n\n","category":"function"},{"location":"reference/io/#GridapTopOpt.pload","page":"IO","title":"GridapTopOpt.pload","text":"pload(dir::AbstractString, ranks::AbstractArray{<:Integer})\n\nLoad a partitioned object stored in a set of JLD2 files in directory dir indexed by MPI ranks ranks.\n\n\n\n\n\n","category":"function"},{"location":"reference/io/#GridapTopOpt.pload!","page":"IO","title":"GridapTopOpt.pload!","text":"pload!(dir::AbstractString, x)\n\nLoad a partitioned object stored in a set of JLD2 files in directory dir and copy contents to the equivilent object x.\n\n\n\n\n\n","category":"function"},{"location":"examples/","page":"Introductory examples","title":"Introductory examples","text":"We refer users to the introductory examples found in:","category":"page"},{"location":"examples/","page":"Introductory examples","title":"Introductory examples","text":"Wegert, Z.J., Manyer, J., Mallon, C.N. et al. GridapTopOpt.jl: a scalable Julia toolbox for level set-based topology optimisation. Struct Multidisc Optim 68, 22 (2025). https://doi.org/10.1007/s00158-024-03927-3","category":"page"},{"location":"examples/","page":"Introductory examples","title":"Introductory examples","text":"warning: Warning\nSince this publication, there are been some minor API changes. See 'Breaking changes' for more information. Example scripts with the lastest API can be found in /scripts/Examples/....","category":"page"},{"location":"reference/levelsetevolution/unfitted/#Unfitted-schemes","page":"Unfitted schemes","title":"Unfitted schemes","text":"","category":"section"},{"location":"reference/levelsetevolution/unfitted/","page":"Unfitted schemes","title":"Unfitted schemes","text":"warning: Warning\nThis page is still under construction! Please refer to the tutorial for a discussion of functionality.","category":"page"},{"location":"reference/levelsetevolution/unfitted/#UnfittedEvolution","page":"Unfitted schemes","title":"UnfittedEvolution","text":"","category":"section"},{"location":"reference/levelsetevolution/unfitted/#GridapTopOpt.UnfittedFEEvolution","page":"Unfitted schemes","title":"GridapTopOpt.UnfittedFEEvolution","text":"struct UnfittedFEEvolution{A<:Evolver,B<:Reinitialiser} <: LevelSetEvolution\n\nWrapper for unfitted evolution and reinitialisation methods.\n\n\n\n\n\n","category":"type"},{"location":"reference/levelsetevolution/unfitted/#Level-set-evolution","page":"Unfitted schemes","title":"Level-set evolution","text":"","category":"section"},{"location":"reference/levelsetevolution/unfitted/","page":"Unfitted schemes","title":"Unfitted schemes","text":"In the following, we use the approach for evolution proposed by Burman et al. (2018) to update the level-set function. Namely, we evolve the level-set function by solving a transport equation","category":"page"},{"location":"reference/levelsetevolution/unfitted/","page":"Unfitted schemes","title":"Unfitted schemes","text":"beginequation\n    begincases\n        displaystylefracpartialphi(tboldsymbolx)partial t+boldsymbolbetacdotboldsymbolnablaphi(tboldsymbolx)=0\n        phi(0boldsymbolx)=phi_0(boldsymbolx)\n        boldsymbolxin Dtin(0T)\n    endcases\nendequation","category":"page"},{"location":"reference/levelsetevolution/unfitted/","page":"Unfitted schemes","title":"Unfitted schemes","text":"where boldsymbolbeta is a velocity field. In this work boldsymbolbeta is computed as boldsymbolbeta=boldsymbolng_Omega, where g_Omega is the regularised sensitivity resulting from the Hilbertian extension-regularisation approach. The transport equation above is solved using an interior penalty approach and Crank-Nicolson for the discretisation in time (see Burman et al. (2018) and references there in for further discussion). The weak formulation of this problem is: for all tin(0T), find phiin W such that","category":"page"},{"location":"reference/levelsetevolution/unfitted/","page":"Unfitted schemes","title":"Unfitted schemes","text":"int_Dleftvfracpartialphipartial t+vboldsymbolbetacdotboldsymbolnablaphirightmathrmdboldsymbolx+sum_FinmathscrS_hint_Fc_eh_F^2lvertboldsymboln_Fcdotboldsymbolbetarvertllbracket boldsymboln_Fcdotboldsymbolnablaphirrbracketllbracketboldsymboln_Fcdotboldsymbolnablavrrbracketmathrmds=0forall vin W^h","category":"page"},{"location":"reference/levelsetevolution/unfitted/","page":"Unfitted schemes","title":"Unfitted schemes","text":"where mathscrS_h is the set of interior mesh facets, h_F is the average element diameters of the elements sharing a facet, boldsymboln_F is the normal to the facet F, llbracket vrrbracket = v^+-v^- is the jump in a function v over the facet F, and c_e is a stabilisation coefficient. Further discussion regarding solving this can be found at Wegert et al. (2025).","category":"page"},{"location":"reference/levelsetevolution/unfitted/#GridapTopOpt.CutFEMEvolve","page":"Unfitted schemes","title":"GridapTopOpt.CutFEMEvolve","text":"mutable struct CutFEMEvolve{V,M} <: Evolver\n\nCutFEM method for level-set evolution based on method developed by\n\nBurman et al. (2018). DOI: 10.1016/j.cma.2017.09.005.\nBurman et al. (2017). DOI: 10.1016/j.cma.2016.12.021.\nBurman and Fernández (2009). DOI: 10.1016/j.cma.2009.02.011\n\nParameters\n\node_solver::ODESolver: ODE solver\nΩs::B: EmbeddedCollection holding updatable triangulation and measures from GridapEmbedded\ndΩ_bg::C: Measure for integration\nspace::B: Level-set FE space\nassembler::Assembler: FE assembler\nparams::D: Tuple of stabilisation parameter γg, mesh sizes h, and max steps max_steps, and background mesh skeleton parameters\ncache: Cache for evolver, initially nothing.\n\nwarning: Warning\nCaching for the CutFEMEvolve method is currently disabled. This will be re-enabled in the future.\"\n\n\n\n\n\n","category":"type"},{"location":"reference/levelsetevolution/unfitted/#GridapTopOpt.CutFEMEvolve-Union{Tuple{B}, Tuple{A}, Tuple{B, EmbeddedCollection, A, Any}} where {A, B}","page":"Unfitted schemes","title":"GridapTopOpt.CutFEMEvolve","text":"CutFEMEvolve(V_φ::B,Ωs::EmbeddedCollection,dΩ_bg::A,h;\n  max_steps=10,\n  γg = 0.1,\n  ode_ls = LUSolver(),\n  ode_nl = ode_ls,\n  ode_solver = MutableRungeKutta(ode_nl, ode_ls, 0.1, :DIRK_CrankNicolson_2_2),\n  assembler=SparseMatrixAssembler(V_φ,V_φ)\n) where {A,B}\n\nCreate an instance of CutFEMEvolve with the space for the level-set V_φ, the EmbeddedCollection Ωs for the triangulation and measures, the measure dΩ_bg for the background mesh, and the mesh size h. The mesh size h can either be a scalar or a CellField object.\n\nThe optional arguments are:\n\nmax_steps: Maximum number of steps for the ODE solver.\nγg: Stabilisation parameter for the continuous interior penalty term.\node_ls: Linear solver for the ODE solver.\node_nl: Non-linear solver for the ODE solver.\node_solver: ODE solver, default is MutableRungeKutta(ode_nl, ode_ls, 0.1, :DIRK_CrankNicolson_2_2).\nassembler: Assembler for the finite element space, default is SparseMatrixAssembler(V_φ,V_φ).\n\nNote\n\nThe stepsize dt = 0.1 in MutableRungeKutta is a place-holder and is updated using the γ passed to solve!.\n\n\n\n\n\n","category":"method"},{"location":"reference/levelsetevolution/unfitted/#Level-set-reinitialisation","page":"Unfitted schemes","title":"Level-set reinitialisation","text":"","category":"section"},{"location":"reference/levelsetevolution/unfitted/","page":"Unfitted schemes","title":"Unfitted schemes","text":"We solve the reinitialisation equation","category":"page"},{"location":"reference/levelsetevolution/unfitted/","page":"Unfitted schemes","title":"Unfitted schemes","text":"leftlbracebeginaligned\n    fracpartialphi(tboldsymbolx)partial t + operatornamesign(phi_0(boldsymbolx))left(lvertboldsymbolnablaphi(tboldsymbolx)rvert-1right) = 0\n    phi(0boldsymbolx)=phi_0(boldsymbolx)\n    boldsymbolxin D t0\nendalignedright","category":"page"},{"location":"reference/levelsetevolution/unfitted/","page":"Unfitted schemes","title":"Unfitted schemes","text":"To steady state using an approach based on the one proposed by Mallon et al. (2025). The weak formulation for this problem is given as: find phiin W such that","category":"page"},{"location":"reference/levelsetevolution/unfitted/","page":"Unfitted schemes","title":"Unfitted schemes","text":"    int_Dvboldsymbolwcdotboldsymbolnablaphi-voperatornamesign(phi_0)mathrmdboldsymbolx+int_Gamma fracgamma_dhphi vmathrmds+j(phiv)=0forall vin W^h","category":"page"},{"location":"reference/levelsetevolution/unfitted/","page":"Unfitted schemes","title":"Unfitted schemes","text":"where boldsymbolw=operatornamesign(phi_0)fracboldsymbolnablaphilVertboldsymbolnablaphirVert. Further discussion regarding solving this can be found at Wegert et al. (2025).","category":"page"},{"location":"reference/levelsetevolution/unfitted/#GridapTopOpt.StabilisedReinit","page":"Unfitted schemes","title":"GridapTopOpt.StabilisedReinit","text":"mutable struct StabilisedReinit{V,M} <: Reinitialiser\n\nStabilised FE method for level-set reinitialisation. Artificial viscosity approach (ArtificialViscosity) based on Mallon et al. (2023). DOI: 10.48550/arXiv.2303.13672. Interior jump penalty approach (InteriorPenalty) adapted from that work and replaces the artifical viscosity term with an interior jump penalty term.\n\nParameters\n\nnls::NonlinearSolver: Nonlinear solver for solving the reinitialisation equation\nstabilisation_method::A: A StabilisationMethod method for stabilising the problem\nΩs::B: EmbeddedCollection holding updatable triangulation and measures from GridapEmbedded\ndΩ_bg::D: Background mesh measure\nspace::C: FE space for level-set function\nassembler::Assembler: Assembler for LS FE space\nparams::E: Tuple of Nitsche parameter γd and mesh size h\ncache: Cache for reinitialiser, initially nothing.\n\nNote\n\nWe expect the EmbeddedCollection Ωs to contain :dΓ. If this is not available we add it to the recipe list in Ωs and a warning will appear.\n\n\n\n\n\n","category":"type"},{"location":"reference/levelsetevolution/unfitted/#GridapTopOpt.StabilisedReinit-Union{Tuple{C}, Tuple{B}, Tuple{A}, Tuple{C, EmbeddedCollection, B, Any}} where {A, B, C}","page":"Unfitted schemes","title":"GridapTopOpt.StabilisedReinit","text":"StabilisedReinit(V_φ::C,Ωs::EmbeddedCollection,dΩ_bg::B,h;\n  γd = 20.0,\n  nls = NewtonSolver(LUSolver();maxiter=20,rtol=1.e-14,verbose=true),\n  assembler=SparseMatrixAssembler(V_φ,V_φ),\n  stabilisation_method::A = InteriorPenalty(V_φ)\n) where {A,B,C}\n\nCreate an instance of StabilisedReinit with the space for the level-set V_φ, the EmbeddedCollection Ωs for the triangulation and measures, the measure dΩ_bg for the background mesh, and the mesh size h. The mesh size h can either be a scalar or a CellField object.\n\nThe optional arguments are:\n\nγd: Interface penalty parameter for the reinitialisation equation.\nnls: Nonlinear solver for solving the reinitialisation equation.\nassembler: Assembler for the finite element space.\nstabilisation_method: A StabilisationMethod method for stabilising the problem.\n\n\n\n\n\n","category":"method"},{"location":"reference/levelsetevolution/unfitted/#Custom-UnfittedEvolution","page":"Unfitted schemes","title":"Custom UnfittedEvolution","text":"","category":"section"},{"location":"reference/levelsetevolution/unfitted/#GridapTopOpt.Evolver","page":"Unfitted schemes","title":"GridapTopOpt.Evolver","text":"abstract type Evolver\n\nYour own unfitted level-set evolution method can be created by implementing concrete functionality for solve!.\n\n\n\n\n\n","category":"type"},{"location":"reference/levelsetevolution/unfitted/#Gridap.Algebra.solve!-Tuple{GridapTopOpt.Evolver, Any, Vararg{Any}}","page":"Unfitted schemes","title":"Gridap.Algebra.solve!","text":"solve!(::Evolver,φ,args...)\n\nEvolve the level set function φ according to an Evolution method.\n\n\n\n\n\n","category":"method"},{"location":"reference/levelsetevolution/unfitted/#GridapTopOpt.Reinitialiser","page":"Unfitted schemes","title":"GridapTopOpt.Reinitialiser","text":"abstract type Reinitialiser\n\nYour own unfitted level-set reinitialisation method can be created by implementing concrete functionality for solve!.\n\n\n\n\n\n","category":"type"},{"location":"reference/levelsetevolution/unfitted/#Gridap.Algebra.solve!-Tuple{GridapTopOpt.Reinitialiser, Any, Vararg{Any}}","page":"Unfitted schemes","title":"Gridap.Algebra.solve!","text":"solve!(::Reinitialiser,φ,args...)\n\nReinitialise the level set function φ according to an Reinitialiser method.\n\n\n\n\n\n","category":"method"},{"location":"breaking-changes/","page":"Breaking changes","title":"Breaking changes","text":"This page will be updated in the event that a breaking change is introduced into the source code.","category":"page"},{"location":"breaking-changes/#Updating-from-v0.1-to-v0.2","page":"Breaking changes","title":"Updating from v0.1 to v0.2","text":"","category":"section"},{"location":"breaking-changes/","page":"Breaking changes","title":"Breaking changes","text":"In v0.2 we made several quality of life changes and enabled compatability with GridapEmbedded. Below we list any breaking changes that will require changes to scripts implemented in v0.1:","category":"page"},{"location":"breaking-changes/","page":"Breaking changes","title":"Breaking changes","text":"Automatic differentiation capability has now been added to GridapDistributed. As a result, the IntegrandWithMeasure structure has been removed. In addition functionals previously required the measures to be passed as arguments, e.g.,\nJ(u,φ,dΩ,dΓ_N) = ∫(f(u,φ))dΩ + ∫(g(u,φ))dΓ_N\nThis is no longer required and the above should instead be written as\nJ(u,φ) = ∫(f(u,φ))dΩ + ∫(g(u,φ))dΓ_N","category":"page"},{"location":"reference/statemaps/#StateMaps","page":"StateMaps","title":"StateMaps","text":"","category":"section"},{"location":"reference/statemaps/","page":"StateMaps","title":"StateMaps","text":"compat: Compat\nFormally known as ChainRules.","category":"page"},{"location":"reference/statemaps/#PDEConstrainedFunctionals","page":"StateMaps","title":"PDEConstrainedFunctionals","text":"","category":"section"},{"location":"reference/statemaps/#GridapTopOpt.PDEConstrainedFunctionals","page":"StateMaps","title":"GridapTopOpt.PDEConstrainedFunctionals","text":"struct PDEConstrainedFunctionals{N,A} <: AbstractPDEConstrainedFunctionals{N}\n\nAn object that computes the objective, constraints, and their derivatives.\n\nImplementation\n\nThis implementation computes derivatives of a integral quantity\n\nF(u(varphi)varphimathrmdOmega_1mathrmdOmega_2) = Sigma_iint_Omega_i f_i(varphi)mathrmdOmega\n\nwith respect to an auxiliary parameter varphi where u is the solution to a PDE and implicitly depends on varphi. This requires two pieces of information:\n\nComputation of fracpartial Fpartial u and fracpartial Fpartial varphi (handled by StateParamMap).\nComputation of fracpartial Fpartial u fracpartial upartial varphi at varphi and u using the adjoint method (handled by AbstractFEStateMap). I.e., let\nfracpartial Fpartial u fracpartial upartial varphi = -lambda^intercal fracpartial mathcalRpartial varphi\nwhere mathcalR is the residual and solve the (linear) adjoint problem:\nfracpartial mathcalRpartial u^intercallambda = fracpartial Fpartial u^intercal\n\nThe gradient is then fracpartial Fpartial varphi = fracpartial Fpartial varphi - fracpartial Fpartial ufracpartial upartial varphi.\n\nParameters\n\nJ: A StateParamMap corresponding to the objective.\nC: A vector of StateParamMap corresponding to the constraints.\ndJ: The DoFs for the objective sensitivity.\ndC: The DoFs for each constraint sensitivity.\nanalytic_dJ: a Function for computing the analytic objective sensitivity.\nanalytic_dC: A vector of Function for computing the analytic objective sensitivities.\nstate_map::A: The state map for the problem.\n\nNote\n\nIf analytic_dJ = nothing automatic differentiation will be used.\nIf analytic_dC[i] = nothing automatic differentiation will be used for C[i].\n\n\n\n\n\n","category":"type"},{"location":"reference/statemaps/#Gridap.Arrays.evaluate!-Tuple{PDEConstrainedFunctionals, Any}","page":"StateMaps","title":"Gridap.Arrays.evaluate!","text":"Fields.evaluate!(pcf::PDEConstrainedFunctionals,φh)\n\nEvaluate the objective and constraints, and their derivatives at φh.\n\n\n\n\n\n","category":"method"},{"location":"reference/statemaps/#GridapTopOpt.evaluate_functionals!-Tuple{PDEConstrainedFunctionals, Any}","page":"StateMaps","title":"GridapTopOpt.evaluate_functionals!","text":"evaluate_functionals!(pcf::PDEConstrainedFunctionals,φh)\n\nEvaluate the objective and constraints at φh.\n\n\n\n\n\n","category":"method"},{"location":"reference/statemaps/#GridapTopOpt.evaluate_derivatives!-Tuple{PDEConstrainedFunctionals, Any}","page":"StateMaps","title":"GridapTopOpt.evaluate_derivatives!","text":"evaluate_derivatives!(pcf::PDEConstrainedFunctionals,φh)\n\nEvaluate the derivatives of the objective and constraints at φh.\n\n\n\n\n\n","category":"method"},{"location":"reference/statemaps/#GridapTopOpt.get_state","page":"StateMaps","title":"GridapTopOpt.get_state","text":"get_state(m::AbstractFEStateMap)\n\nReturn the solution/state u to the FE problem.\n\n\n\n\n\n","category":"function"},{"location":"reference/statemaps/#StateParamMap","page":"StateMaps","title":"StateParamMap","text":"","category":"section"},{"location":"reference/statemaps/#GridapTopOpt.StateParamMap","page":"StateMaps","title":"GridapTopOpt.StateParamMap","text":"struct StateParamMap{A,B,C,D} <: AbstractStateParamMap\n\nA wrapper to handle partial differentation of a function F of a specific form (see below) in a ChainRules.jl compatible way with caching.\n\nAssumptions\n\nWe assume that we have a function F of the following form:\n\nF(u,φ) = ∫(f(u,φ))dΩ₁ + ∫(g(u,φ))dΩ₂ + ...,.\n\nwhere u and φ are each expected to inherit from Union{FEFunction,MultiFieldFEFunction} or the GridapDistributed equivalent.\n\n\n\n\n\n","category":"type"},{"location":"reference/statemaps/#ChainRulesCore.rrule-Tuple{GridapTopOpt.StateParamMap, Any, Any}","page":"StateMaps","title":"ChainRulesCore.rrule","text":"ChainRulesCore.rrule(u_to_j::StateParamMap,uh,φh)\n\nReturn the evaluation of a StateParamMap and a a function for evaluating the pullback of u_to_j. This enables compatiblity with ChainRules.jl\n\n\n\n\n\n","category":"method"},{"location":"reference/statemaps/#Implemented-types-of-AbstractFEStateMap","page":"StateMaps","title":"Implemented types of AbstractFEStateMap","text":"","category":"section"},{"location":"reference/statemaps/#GridapTopOpt.AbstractFEStateMap","page":"StateMaps","title":"GridapTopOpt.AbstractFEStateMap","text":"abstract type AbstractFEStateMap\n\nTypes inheriting from this abstract type should enable the evaluation and differentiation of the solution to an FE problem u that implicitly depends on an auxiliary parameter φ.\n\n\n\n\n\n","category":"type"},{"location":"reference/statemaps/#AffineFEStateMap","page":"StateMaps","title":"AffineFEStateMap","text":"","category":"section"},{"location":"reference/statemaps/#GridapTopOpt.AffineFEStateMap","page":"StateMaps","title":"GridapTopOpt.AffineFEStateMap","text":"struct AffineFEStateMap{A,B,C,D,E,F} <: AbstractFEStateMap\n\nA structure to enable the forward problem and pullback for affine finite element operators AffineFEOperator.\n\nParameters\n\nbiform::A: Function defining the bilinear form.\nliform::B: Function defining the linear form.\nspaces::C: Tuple of finite element spaces.\nplb_caches::D: A cache for the pullback operator.\nfwd_caches::E: A cache for the forward problem.\nadj_caches::F: A cache for the adjoint problem.\n\n\n\n\n\n","category":"type"},{"location":"reference/statemaps/#GridapTopOpt.AffineFEStateMap-Tuple{Function, Function, Vararg{Any, 5}}","page":"StateMaps","title":"GridapTopOpt.AffineFEStateMap","text":"AffineFEStateMap(\n  a::Function,l::Function,\n  U,V,V_φ,U_reg,φh;\n  assem_U = SparseMatrixAssembler(U,V),\n  assem_adjoint = SparseMatrixAssembler(V,U),\n  assem_deriv = SparseMatrixAssembler(U_reg,U_reg),\n  ls::LinearSolver = LUSolver(),\n  adjoint_ls::LinearSolver = LUSolver()\n)\n\nCreate an instance of AffineFEStateMap given the bilinear form a and linear form l as Function types, trial and test spaces U and V, the FE space V_φ for φh, the FE space U_reg for derivatives, and the measures as additional arguments.\n\nOptional arguments enable specification of assemblers and linear solvers.\n\n\n\n\n\n","category":"method"},{"location":"reference/statemaps/#NonlinearFEStateMap","page":"StateMaps","title":"NonlinearFEStateMap","text":"","category":"section"},{"location":"reference/statemaps/#GridapTopOpt.NonlinearFEStateMap","page":"StateMaps","title":"GridapTopOpt.NonlinearFEStateMap","text":"struct NonlinearFEStateMap{A,B,C,D,E,F} <: AbstractFEStateMap\n\nA structure to enable the forward problem and pullback for nonlinear finite element operators.\n\nParameters\n\nres::A: a Function defining the residual of the problem.\njac::B: a Function defining Jacobian of the residual.\nspaces::C: Tuple of finite element spaces.\nplb_caches::D: A cache for the pullback operator.\nfwd_caches::E: A cache for the forward problem.\nadj_caches::F: A cache for the adjoint problem.\n\n\n\n\n\n","category":"type"},{"location":"reference/statemaps/#GridapTopOpt.NonlinearFEStateMap-Tuple{Function, Function, Vararg{Any, 5}}","page":"StateMaps","title":"GridapTopOpt.NonlinearFEStateMap","text":"NonlinearFEStateMap(\n  res::Function,jac::Function,U,V,V_φ,U_reg,φh;\n  assem_U = SparseMatrixAssembler(U,V),\n  assem_adjoint = SparseMatrixAssembler(V,U),\n  assem_deriv = SparseMatrixAssembler(U_reg,U_reg),\n  nls::NonlinearSolver = NewtonSolver(LUSolver();maxiter=50,rtol=1.e-8,verbose=true),\n  adjoint_ls::LinearSolver = LUSolver()\n)\n\nCreate an instance of NonlinearFEStateMap given the residual res as a Function type, trial and test spaces U and V, the FE space V_φ for φh, the FE space U_reg for derivatives, and the measures as additional arguments.\n\nOptional arguments enable specification of assemblers, nonlinear solver, and adjoint (linear) solver.\n\n\n\n\n\n","category":"method"},{"location":"reference/statemaps/#GridapTopOpt.NonlinearFEStateMap-Tuple{Function, Function, Function, Vararg{Any, 5}}","page":"StateMaps","title":"GridapTopOpt.NonlinearFEStateMap","text":"NonlinearFEStateMap(\n  res::Function,jac::Function,adjoint_jac::Function,U,V,V_φ,U_reg,φh;\n  assem_U = SparseMatrixAssembler(U,V),\n  assem_adjoint = SparseMatrixAssembler(V,U),\n  assem_deriv = SparseMatrixAssembler(U_reg,U_reg),\n  nls::NonlinearSolver = NewtonSolver(LUSolver();maxiter=50,rtol=1.e-8,verbose=true),\n  adjoint_ls::LinearSolver = LUSolver()\n)\n\nIn addition to the above, pass the jacobian adjoint_jac for the purposes of solving the adjoint problem. This can be computed with AD or by hand, but and allows the user to specify a different jacobian for the forward problem (e.g., for picard iterations).\n\n\n\n\n\n","category":"method"},{"location":"reference/statemaps/#RepeatingAffineFEStateMap","page":"StateMaps","title":"RepeatingAffineFEStateMap","text":"","category":"section"},{"location":"reference/statemaps/#GridapTopOpt.RepeatingAffineFEStateMap","page":"StateMaps","title":"GridapTopOpt.RepeatingAffineFEStateMap","text":"struct RepeatingAffineFEStateMap <: AbstractFEStateMap\n\nA structure to enable the forward problem and pullback for affine finite element operators AffineFEOperator with multiple linear forms but only a single bilinear form.\n\nParameters\n\nbiform: A Function defining the bilinear form.\nliform: A vector of Function defining the linear forms.\nspaces: Repeated finite element spaces.\nspaces_0: Original finite element spaces that are being repeated.\nplb_caches: A cache for the pullback operator.\nfwd_caches: A cache for the forward problem.\nadj_caches: A cache for the adjoint problem.\n\n\n\n\n\n","category":"type"},{"location":"reference/statemaps/#GridapTopOpt.RepeatingAffineFEStateMap-Tuple{Int64, Function, Vector{<:Function}, Vararg{Any, 5}}","page":"StateMaps","title":"GridapTopOpt.RepeatingAffineFEStateMap","text":"RepeatingAffineFEStateMap(\n  nblocks::Int,a::Function,l::Vector{<:Function},\n  U0,V0,V_φ,U_reg,φh;\n  assem_U = SparseMatrixAssembler(U0,V0),\n  assem_adjoint = SparseMatrixAssembler(V0,U0),\n  assem_deriv = SparseMatrixAssembler(U_reg,U_reg),\n  ls::LinearSolver = LUSolver(),\n  adjoint_ls::LinearSolver = LUSolver()\n)\n\nCreate an instance of RepeatingAffineFEStateMap given the number of blocks nblocks, a bilinear form a, a vector of linear form l as Function types, the trial and test spaces U and V, the FE space V_φ for φh, the FE space U_reg for derivatives, and the measures as additional arguments.\n\nOptional arguments enable specification of assemblers and linear solvers.\n\nNote\n\nThe resulting FEFunction will be a MultiFieldFEFunction (or GridapDistributed equivalent) where each field corresponds to an entry in the vector of linear forms\n\n\n\n\n\n","category":"method"},{"location":"reference/statemaps/#StaggeredAffineFEStateMap-and-StaggeredNonlinearFEStateMap","page":"StateMaps","title":"StaggeredAffineFEStateMap and StaggeredNonlinearFEStateMap","text":"","category":"section"},{"location":"reference/statemaps/#GridapTopOpt.StaggeredAffineFEStateMap","page":"StateMaps","title":"GridapTopOpt.StaggeredAffineFEStateMap","text":"struct StaggeredAffineFEStateMap{NB,SB} <: AbstractFEStateMap{NB,SB}\n  biforms    :: Vector{<:Function}\n  liforms    :: Vector{<:Function}\n  ∂Rk∂xhi    :: Tuple{Vararg{Tuple{Vararg{Function}}}}\n  spaces     :: A\n  assems     :: B\n  solvers    :: C\n  plb_caches :: D\n  fwd_caches :: E\n  adj_caches :: F\nend\n\nAffine staggered state map for the equivalent StaggeredAffineFEOperator, used to solve staggered problems where the k-th equation is linear in u_k.\n\nSimilar to the StaggeredAffineFEOperator counterpart, we expect a set of bilinear/linear form pairs that also depend on φ:\n\na_k((u_1,...,u_{k-1}),u_k,v_k,φ) = ∫(...)\nl_k((u_1,...,u_{k-1}),v_k,φ) = ∫(...)\n\nThese can be assembled into a set of linear systems:\n\nA_k u_k = b_k\n\nwhere A_k and b_k only depend on the previous variables u_1,...,u_{k-1}.\n\n\n\n\n\n","category":"type"},{"location":"reference/statemaps/#GridapTopOpt.StaggeredNonlinearFEStateMap","page":"StateMaps","title":"GridapTopOpt.StaggeredNonlinearFEStateMap","text":"mutable struct StaggeredNonlinearFEStateMap{NB,SB} <: AbstractFEStateMap{NB,SB}\n  const residuals         :: Vector{<:Function}\n  const jacobians         :: Vector{<:Function}\n  const adjoint_jacobians :: Vector{<:Function}\n  const ∂Rk∂xhi           :: Tuple{Vararg{Tuple{Vararg{Function}}}}\n  const spaces            :: A\n  const assems            :: B\n  const solvers           :: C\n  const plb_caches        :: D\n  fwd_caches              :: E\n  const adj_caches        :: F\nend\n\nStaggered nonlinear state map for the equivalent StaggeredNonlinearFEOperator, used to solve staggered problems where the k-th equation is nonlinear in u_k.\n\nSimilar to the previous structure and the StaggeredNonlinearFEOperator counterpart, we expect a set of residual/jacobian pairs that also depend on φ:\n\njack((u1,...,u{k-1},φ),uk,duk,dvk) = ∫(...)   resk((u1,...,u{k-1},φ),uk,v_k) = ∫(...)\n\ninfo: Info\nThis is mutable for now, in future we will refactor ChainRules to remove storage of caches\n\n\n\n\n\n","category":"type"},{"location":"reference/statemaps/#Advanced","page":"StateMaps","title":"Advanced","text":"","category":"section"},{"location":"reference/statemaps/#Inheriting-from-AbstractFEStateMap","page":"StateMaps","title":"Inheriting from AbstractFEStateMap","text":"","category":"section"},{"location":"reference/statemaps/#Existing-methods","page":"StateMaps","title":"Existing methods","text":"","category":"section"},{"location":"reference/statemaps/#ChainRulesCore.rrule-Tuple{GridapTopOpt.AbstractFEStateMap, Any}","page":"StateMaps","title":"ChainRulesCore.rrule","text":"rrule(φ_to_u::AbstractFEStateMap,φh)\n\nReturn the evaluation of a AbstractFEStateMap and a a function for evaluating the pullback of φ_to_u. This enables compatiblity with ChainRules.jl\n\n\n\n\n\n","category":"method"},{"location":"reference/statemaps/#GridapTopOpt.pullback","page":"StateMaps","title":"GridapTopOpt.pullback","text":"pullback(φ_to_u::AbstractFEStateMap,uh,φh,du;updated)\n\nCompute ∂F∂u*dudφ at φh and uh using the adjoint method. I.e., let\n\n∂F∂u*dudφ = -λᵀ*dRdφ\n\nand solve the adjoint problem dRduᵀ*λ = ∂F∂uᵀ using adjoint_solve!.\n\n\n\n\n\n","category":"function"},{"location":"reference/statemaps/#Required-to-implement","page":"StateMaps","title":"Required to implement","text":"","category":"section"},{"location":"reference/statemaps/#GridapTopOpt.forward_solve!","page":"StateMaps","title":"GridapTopOpt.forward_solve!","text":"forward_solve!(φ_to_u::AbstractFEStateMap,φh)\n\nEvaluate the forward problem u given φ. This should compute the FE problem.\n\n\n\n\n\n","category":"function"},{"location":"reference/statemaps/#GridapTopOpt.adjoint_solve!","page":"StateMaps","title":"GridapTopOpt.adjoint_solve!","text":"adjoint_solve!(φ_to_u::AbstractFEStateMap,du::AbstractVector)\n\nEvaluate the solution to the adjoint problem given a RHS vector ∂F∂u denoted du. This should solve the linear problem dRduᵀ*λ = ∂F∂uᵀ.\n\n\n\n\n\n","category":"function"},{"location":"reference/statemaps/#GridapTopOpt.update_adjoint_caches!","page":"StateMaps","title":"GridapTopOpt.update_adjoint_caches!","text":"update_adjoint_caches!(φ_to_u::AbstractFEStateMap,uh,φh)\n\nUpdate the cache for the adjoint problem. This is usually a tuple of objects.\n\n\n\n\n\n","category":"function"},{"location":"reference/statemaps/#GridapTopOpt.dRdφ","page":"StateMaps","title":"GridapTopOpt.dRdφ","text":"dRdφ(φ_to_u::AbstractFEStateMap,uh,vh,φh)\n\nCompute the derivative with respect to φh of the residual R.\n\n\n\n\n\n","category":"function"},{"location":"reference/statemaps/#GridapTopOpt.get_state-Tuple{GridapTopOpt.AbstractFEStateMap}","page":"StateMaps","title":"GridapTopOpt.get_state","text":"get_state(m::AbstractFEStateMap)\n\nReturn the solution/state u to the FE problem.\n\n\n\n\n\n","category":"method"},{"location":"reference/statemaps/#GridapTopOpt.get_spaces","page":"StateMaps","title":"GridapTopOpt.get_spaces","text":"get_spaces(m::AbstractFEStateMap)\n\nReturn a collection of FE spaces. The first four entires should correspond to get_trial_space, get_test_space, get_aux_space, and get_deriv_space unless these are overloaded for a particular implementation.\n\n\n\n\n\n","category":"function"},{"location":"reference/statemaps/#GridapTopOpt.get_assemblers","page":"StateMaps","title":"GridapTopOpt.get_assemblers","text":"get_assemblers(m::AbstractFEStateMap)\n\nReturn a collection of assemblers. The first two entires should correspond to get_pde_assembler and get_deriv_assembler unless these are overloaded for a particular implementation.\n\n\n\n\n\n","category":"function"},{"location":"reference/statemaps/#GridapTopOpt.get_trial_space","page":"StateMaps","title":"GridapTopOpt.get_trial_space","text":"get_trial_space(m::AbstractFEStateMap)\n\nReturn trial space for FE problem.\n\n\n\n\n\n","category":"function"},{"location":"reference/statemaps/#GridapTopOpt.get_test_space","page":"StateMaps","title":"GridapTopOpt.get_test_space","text":"get_test_space(m::AbstractFEStateMap)\n\nReturn test space for FE problem.\n\n\n\n\n\n","category":"function"},{"location":"reference/statemaps/#GridapTopOpt.get_aux_space","page":"StateMaps","title":"GridapTopOpt.get_aux_space","text":"get_aux_space(m::AbstractFEStateMap)\n\nReturn space for auxillary parameter.\n\n\n\n\n\n","category":"function"},{"location":"reference/statemaps/#GridapTopOpt.get_deriv_space","page":"StateMaps","title":"GridapTopOpt.get_deriv_space","text":"get_deriv_space(m::AbstractFEStateMap)\n\nReturn space for derivatives.\n\n\n\n\n\n","category":"function"},{"location":"reference/statemaps/#GridapTopOpt.get_pde_assembler","page":"StateMaps","title":"GridapTopOpt.get_pde_assembler","text":"get_pde_assembler(m::AbstractFEStateMap)\n\nReturn assembler for FE problem.\n\n\n\n\n\n","category":"function"},{"location":"reference/statemaps/#GridapTopOpt.get_deriv_assembler","page":"StateMaps","title":"GridapTopOpt.get_deriv_assembler","text":"get_deriv_assembler(m::AbstractFEStateMap)\n\nReturn assembler for derivatives.\n\n\n\n\n\n","category":"function"},{"location":"reference/statemaps/#Partial-derivatives","page":"StateMaps","title":"Partial derivatives","text":"","category":"section"},{"location":"reference/statemaps/#Gridap.Fields.gradient","page":"StateMaps","title":"Gridap.Fields.gradient","text":"Gridap.gradient(F,uh::Vector,K::Int)\n\nGiven a function F that returns a DomainContribution when called, and a vector of FEFunctions uh, evaluate the partial derivative of F with respect to uh[K].\n\nExample\n\nSuppose uh and φh are FEFunctions with measures dΩ and dΓ_N. Then the partial derivative of a function J wrt to φh is computed via\n\nJ(u,φ) = ∫(f(u,φ))dΩ + ∫(g(u,φ))dΓ_N\n∂J∂φh = ∇(J,[uh,φh],2)\n\nwhere f and g are user defined.\n\n\n\n\n\n","category":"function"},{"location":"reference/statemaps/#Gridap.Algebra.jacobian","page":"StateMaps","title":"Gridap.Algebra.jacobian","text":"Gridap.jacobian(F,uh::Vector,K::Int)\n\nGiven a function F that returns a DomainContribution when called, and a vector of FEFunctions or CellField uh, evaluate the Jacobian F with respect to uh[K].\n\n\n\n\n\n","category":"function"},{"location":"examples/Unfitted-TO-with-Laplace/#Topology-optimisation-on-unfitted-meshes","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"","category":"section"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"In this tutorial, we will learn:","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"How to formulate a Laplace's equation with CutFEM based on Burman et al. (2015)\nHow to use unfitted discretisations from GridapEmbedded in GridapTopOpt\nHow to use automatic (unfitted) shape differentation","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"This tutorial is for intermediate-level users. You should be familar with the GridapTopOpt framework before attempting this tutorial. In addition, it is recommended that this Gridap tutorial is read before attempting the below.","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/#Problem-formulation","page":"Topology optimisation on unfitted meshes","title":"Problem formulation","text":"","category":"section"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"The goal of this tutorial is to solve a level-set topology optimisation problem with an unfitted discretisation and automatic shape differentiation. To simplify this tutorial, we consider Laplace's equation for the underlying PDE. Specifically, the PDE-constrained optimisation problem that we consider is","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"beginaligned\n    min_Omegasubset DJ(Omega)coloneqqint_Omega(phi)boldsymbolnablaucdotboldsymbolnablaumathrmdboldsymbolx\n    textst C(Omega)=0\n    leftlbracebeginaligned\n    -boldsymbolnabla^2u = 0textin Omega\nboldsymbolnabla ucdotboldsymboln = 1texton Gamma_N\nboldsymbolnabla ucdotboldsymboln = 0texton Gamma\nu = 0texton overlineOmega_D\n    endalignedright\nendaligned","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"where C(Omega)=(operatornameVol(Omega) - 03)operatornameVol(D) constrains the volume of Omega. The background domain D and boundary conditions are shown below:","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"<p align=\"center\">\n<img src=\"../Unfitted-TO-with-Laplace.png\" width=\"300\">\n</p>","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/#Unfitted-formulation","page":"Topology optimisation on unfitted meshes","title":"Unfitted formulation","text":"","category":"section"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"In the following, we discretise the PDE governing u using CutFEM based on Burman et al. (2015). The weak formulation for this problem is: for V=H^1(Omegau_Gamma_D=0), find uin V such that","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"int_Omega(phi)boldsymbolnablaucdotboldsymbolnablavmathrmdboldsymbolx + j(uv) + i(uv) = int_Gamma_Nvmathrmdsforall vin V","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"Those who are familiar with deriving the weak form will notice that we have two addition terms in this formulation. The first is the so-called ghost penalty term j(uv) that extends coercivity of the bilinear form from the physical domain to the cut domain. This is given by","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"j(uv)=int_Gamma_ggamma h llbracket boldsymbolncdotboldsymbolnablaurrbracketllbracket boldsymbolncdotboldsymbolnablavrrbracketmathrmds","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"The second term i(uv) enforces zero temperature within an isolated volumes marked by chi. We can think of these isolated volumes as blobs of material that are not sufficently constrained. As a result, without an additional constraint on these \"blobs\", an unfitted discretisation will yield infinite solutions. This term is given by","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"i(uv) = int_Omega(phi)chi uvmathrmdboldsymbolx","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"Note that this only acts on the isolated volumes marked by chi. As a result, the problem is still consistent.","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/#Setup-and-parameters","page":"Topology optimisation on unfitted meshes","title":"Setup and parameters","text":"","category":"section"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"As usual, we start by loading the required libraries and defining any parameters:","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"using Gridap, Gridap.Adaptivity, Gridap.Geometry\nusing GridapEmbedded, GridapEmbedded.LevelSetCutters\nusing GridapTopOpt, GridapSolvers\n\nusing GridapTopOpt: StateParamMap\n\npath=\"./results/Unfitted_Thermal2D/\"\nmkpath(path)\n# Params\nn = 50            # Initial mesh size (pre-refinement)\nmax_steps = n/5   # Time-steps for evolution equation\nvf = 0.3          # Volume fraction\nα_coeff = 2       # Regularisation coefficient extension-regularisation\niter_mod = 10     # Write output every iter_mod iterations","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"Here, we deictate that the initial mesh size is 50^2 quadrilateral elements, the time steps for the evolution equation is set to n5, the required volume fraction is 0.3, the reguarisation coefficent for the Hilbertian extension-regularisation is 2, and we data files at each iteration.","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/#Mesh-with-refinement","page":"Topology optimisation on unfitted meshes","title":"Mesh with refinement","text":"","category":"section"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"For this problem, we use a refined mesh using Gridap's adaptivity features. In addition, we mark mesh entities that are part of overlineOmega_D and Gamma_N:","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"# Base model\n_model = CartesianDiscreteModel((0,1,0,1),(n,n))\nbase_model = UnstructuredDiscreteModel(_model)\n# Refinement\nref_model = refine(base_model, refinement_method = \"barycentric\")\nref_model = refine(ref_model)\nref_model = refine(ref_model)\nmodel = ref_model.model\n# Get mesh size\nh = minimum(get_element_diameters(model))\nhₕ = get_element_diameter_field(model)\n# Mark mesh entities\nf_Γ_D(x) = (x[1]-0.5)^2 + (x[2]-0.5)^2 <= 0.05^2\nf_Γ_N(x) = ((x[1] ≈ 0 || x[1] ≈ 1) && (0.2 <= x[2] <= 0.3 + eps() || 0.7 - eps() <= x[2] <= 0.8)) ||\n  ((x[2] ≈ 0 || x[2] ≈ 1) && (0.2 <= x[1] <= 0.3 + eps() || 0.7 - eps() <= x[1] <= 0.8))\nupdate_labels!(1,model,f_Γ_D,\"Omega_D\")\nupdate_labels!(2,model,f_Γ_N,\"Gamma_N\")\nwritevtk(model,path*\"model\")","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"warning: Warning\nNon-TET/TRI polytopes are simplexified by GridapEmbedded when cutting. As a result, derivative information from AD will not be correct when using a mesh that isn't made of TRI/TET. Please use a mesh with TRI/TET polytopes to ensure correctness of derivative results.","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/#FESpace-for-level-set-function-and-derivatives","page":"Topology optimisation on unfitted meshes","title":"FESpace for level-set function and derivatives","text":"","category":"section"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"In example, we consider piecewise linear cuts defined via a level-set function. As such, the level-set function should be discretised using continuous piecewise-linear finite elements. In addition, we use the same space for the derivatives, except we also constrain the derivative space so that the shape derivatives are zero on overlineOmega_D and Gamma_N.","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"reffe_scalar = ReferenceFE(lagrangian,Float64,1)\nV_φ = TestFESpace(model,reffe_scalar)\nV_reg = TestFESpace(model,reffe_scalar;dirichlet_tags=[\"Omega_D\",\"Gamma_N\"])\nU_reg = TrialFESpace(V_reg)","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"Next, we build the initial level-set function using","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"f1 = (x,y) -> -cos(6π*(x-1/12))*cos(6π*(y-1/12))-0.5\nf2 = (x,y) -> -cos(6π*(x-3/12))*cos(6π*(y-1/12))-0.5\nf3 = (x,y) -> (x-0.5)^2 + (y-0.5)^2 - 0.06^2\nf((x,y)) = min(max(f1(x,y),f2(x,y)),f3(x,y))\nφh = interpolate(f,V_φ)","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"Before defining the triangulation, we need to ensure that the initial cut interface defined by the level-set function does not intersect the vertices in the background domain. We do this using:","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"GridapTopOpt.correct_ls!(φh)","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/#Background-triangulations-and-measures","page":"Topology optimisation on unfitted meshes","title":"Background triangulations and measures","text":"","category":"section"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"Next we define the measures for the background domain as usual","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"Ω_bg = Triangulation(model)\nΓ_N = BoundaryTriangulation(model,tags=\"Gamma_N\")\ndΩ_bg = Measure(Ω_bg,2)\ndΓ_N = Measure(Γ_N,2)\nvol_D = sum(∫(1)dΩ_bg)","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/#Embedded-triangulations-and-measures","page":"Topology optimisation on unfitted meshes","title":"Embedded triangulations and measures","text":"","category":"section"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"To make it possible to update the embedded triangulations, measures, and the indicator function we use an EmbeddedCollection. This is given by","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"Ωs = EmbeddedCollection(model,φh) do cutgeo,cutgeo_facets,_φh\n  Ωin = DifferentiableTriangulation(Triangulation(cutgeo,PHYSICAL),V_φ)\n  Γ = DifferentiableTriangulation(EmbeddedBoundary(cutgeo),V_φ)\n  Γg = GhostSkeleton(cutgeo)\n  Ωact = Triangulation(cutgeo,ACTIVE)\n  φ_cell_values = get_cell_dof_values(_φh)\n  χ,_ = get_isolated_volumes_mask_polytopal(model,φ_cell_values,[\"Omega_D\",])\n  (;\n    :Ωin  => Ωin,\n    :dΩin => Measure(Ωin,2),\n    :Γg   => Γg,\n    :dΓg  => Measure(Γg,2),\n    :n_Γg => get_normal_vector(Γg),\n    :Γ    => Γ,\n    :dΓ   => Measure(Γ,2),\n    :n_Γ  => get_normal_vector(Γ),\n    :Ωact => Ωact,\n    :χ => χ\n  )\nend","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"The do statement above provides a recipe for the EmbeddedCollection to generate the data in Ωs that can be accessed, for example, via Ωs.Ωin. The contents of Ωs can then be updated via update_collection!(c::EmbeddedCollection,φh). In addition, new recipes can be added using add_recipe!(c::EmbeddedCollection,r::Function[,φh]). Inside EmbeddedCollection, cut geometries are created and then passed to recipes when update_collection! is called.","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/#Isolated-volume-marking-and-automatic-differentation","page":"Topology optimisation on unfitted meshes","title":"Isolated volume marking and automatic differentation","text":"","category":"section"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"In the above, we use get_isolated_volumes_mask_polytopal to create a cell field that marks cells based on whether they are connected to Omega_D. In addition, we wrap the cut triangulations inside DifferentiableTriangulation. This is a wrapper around an embedded triangulation (i.e SubCellTriangulation or SubFacetTriangulation) implementing all the necessary methods to compute derivatives with respect to deformations of the embedded mesh. To do so, it propagates dual numbers into the geometric maps mapping cut subcells/subfacets to the background mesh. We refer to this article for the mathematical discussion:","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"Wegert, Z.J., Manyer, J., Mallon, C.N. et al. Level-set topology optimisation with unfitted finite elements and automatic shape differentiation. arXiv:2504.09748 [math] (2025). http://arxiv.org/abs/2504.09748","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/#FE-problem","page":"Topology optimisation on unfitted meshes","title":"FE problem","text":"","category":"section"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"Now that all the measures are defined, lets define the weak form, optimisation functionals, and the FE operators. First, we can define the weak form and optimisation functionals as","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"γg = 0.1\na(u,v,φ) = ∫(∇(v)⋅∇(u))Ωs.dΩin +\n           ∫((γg*mean(hₕ))*jump(Ωs.n_Γg⋅∇(v))*jump(Ωs.n_Γg⋅∇(u)))Ωs.dΓg +\n           ∫(Ωs.χ*v*u)Ωs.dΩin\nl(v,φ) = ∫(v)dΓ_N","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"and","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"J(u,φ) = ∫(∇(u)⋅∇(u))Ωs.dΩin\nVol(u,φ) = ∫(1/vol_D)Ωs.dΩin - ∫(vf/vol_D)dΩ_bg\ndVol(q,u,φ) = ∫(-1/vol_D*q/(abs(Ωs.n_Γ ⋅ ∇(φ))))Ωs.dΓ","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"We have directly computed the shape derivative of the volume functional using the analytical results by Wegert et al. (2025) referenced above.","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"Next, we setup the AffineFEStateMap and PDEConstrainedFunctionals objects. Here we use another new objective EmbeddedCollection_in_φh that is similar to EmbeddedCollection except it does not cut the mesh and only expects recipes that take arguments in φh. This allows us to update the spaces and state maps whenever required. Note that this is different to how we usually setup these objects because we have to recreate the FE spaces and state maps at each iteration. This is because the active mesh for the unfitted discretisation is changing over the course of the level-set evolution. This new state_collection holds the state map, the objective as a StateParamMap, and set of StateParamMap for the constraints. This is given by the follow snippet","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"state_collection = EmbeddedCollection_in_φh(model,φh) do _φh\n  update_collection!(Ωs,_φh)\n  V = TestFESpace(Ωs.Ωact,reffe_scalar;dirichlet_tags=[\"Omega_D\"])\n  U = TrialFESpace(V,0.0)\n  state_map = AffineFEStateMap(a,l,U,V,V_φ,U_reg,_φh)\n  (;\n    :state_map => state_map,\n    :J => StateParamMap(J,state_map),\n    :C => map(Ci -> StateParamMap(Ci,state_map),[Vol,])\n  )\nend","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"Note that StateParamMap is a wrapper to handle partial differentation of a function in a ChainRules.jl compatible way with caching. See this documentation for further information.","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"Next, we create the EmbeddedPDEConstrainedFunctionals. This is similar to PDEConstrainedFunctionals except it takes state_collection as the argument and updates the unfitted triangulations where appropriate.","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"pcfs = EmbeddedPDEConstrainedFunctionals(state_collection;analytic_dC=(dVol,))","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/#Evolution","page":"Topology optimisation on unfitted meshes","title":"Evolution","text":"","category":"section"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"We now define the evolution and reinitialisation methods for this problem. Here we use unfitted approaches to solve both of these problems","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"To set these up, we provide CutFEMEvolve and StabilisedReinit as follows:","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"evo = CutFEMEvolve(V_φ,Ωs,dΩ_bg,hₕ;max_steps,γg=0.1)\nreinit = StabilisedReinit(V_φ,Ωs,dΩ_bg,hₕ;stabilisation_method=ArtificialViscosity(2.0))","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"We then define the UnfittedFEEvolution object that wraps these methods, and we reinitialise our initial level-set function via","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"ls_evo = UnfittedFEEvolution(evo,reinit)\nreinit!(ls_evo,φh)","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/#Hilbertian-extension-regularisation-problems","page":"Topology optimisation on unfitted meshes","title":"Hilbertian extension-regularisation problems","text":"","category":"section"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"The Hilbertian extension-regularisation approach projects a directional derivative mathrmdJ(phiw) of a functional J(phi) onto a Hilbert space H on D, typically with additional regularity. This involves solving an identification problem: for Find g_Omegain H such that","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"langle g_Omegawrangle_H=-mathrmdJ(phiw)forall win H","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"where langlecdotcdotrangle_H is the inner product on H. Here, we use H=H^1_Omega_DcupGamma_N(D) with the inner product","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"    langle uvrangle_H=int_Dleft(alpha^2boldsymbolnabla ucdotboldsymbolnabla v+uvright)mathrmdboldsymbolx","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"This is implemented as follows:","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"α = (α_coeff)^2*hₕ*hₕ\na_hilb(p,q) =∫(α*∇(p)⋅∇(q) + p*q)dΩ_bg;\nvel_ext = VelocityExtension(a_hilb,U_reg,V_reg)","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/#Optimiser-and-solution","page":"Topology optimisation on unfitted meshes","title":"Optimiser and solution","text":"","category":"section"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"Finally, for the optimiser we use the AugmentedLagrangian method with the convergence criteria below. In addition, we output data on the background mesh, along with the solution u_h on the unfitted triangulation. This is given by the following:","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"converged(m) = GridapTopOpt.default_al_converged(\n  m;\n  L_tol = 0.01*h,\n  C_tol = 0.01\n)\noptimiser = AugmentedLagrangian(pcfs,ls_evo,vel_ext,φh;verbose=true,constraint_names=[:Vol],converged)\nfor (it,uh,φh) in optimiser\n  if iszero(it % iter_mod)\n    writevtk(Ω_bg,path*\"Omega$it\",cellfields=[\"φ\"=>φh,\"|∇(φ)|\"=>(norm ∘ ∇(φh)),\"uh\"=>uh,\"χ\"=>Ωs.χ])\n    writevtk(Ωs.Ωin,path*\"Omega_in$it\",cellfields=[\"uh\"=>uh])\n  end\n  write_history(path*\"/history.txt\",optimiser.history)\nend\nit = get_history(optimiser).niter; uh = get_state(pcfs)\nwritevtk(Ω_bg,path*\"Omega$it\",cellfields=[\"φ\"=>φh,\"|∇(φ)|\"=>(norm ∘ ∇(φh)),\"uh\"=>uh,\"χ\"=>Ωs.χ])\nwritevtk(Ωs.Ωin,path*\"Omega_in$it\",cellfields=[\"uh\"=>uh])","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"Solving this problem results in the following iteration history:","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"<p align=\"center\">\n<img src=\"../Unfitted-TO-with-Laplace-result.gif\" width=\"300\">\n</p>","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"The full script for this problem can be found here.","category":"page"},{"location":"reference/optimisers/#Optimisers","page":"Optimisers","title":"Optimisers","text":"","category":"section"},{"location":"reference/optimisers/","page":"Optimisers","title":"Optimisers","text":"In GridapTopOpt we implement optimisation algorithms as iterators that inherit from an abstract type Optimiser. A concrete Optimiser implementation, say OptEg, then implements iterate(m::OptEg) ↦ (var,state) and iterate(m::OptEg,state) ↦ (var,state), where var and state are the available items in the outer loop and internal state of the iterator, respectively. As a result we can iterate over the object m=OptEg(...) using for var in m. The benefit of this implementation is that the internals of the optimisation method can be hidden in the source code while the explicit for loop is still visible to the user. The body of the loop can then be used for auxiliary operations such as writing the optimiser history and other files.","category":"page"},{"location":"reference/optimisers/","page":"Optimisers","title":"Optimisers","text":"The below describes the implemented optimisers along with the OptimiserHistory type. Custom optimisers can be implemented by creating types that inherit from Optimiser and extending the interfaces in Custom optimiser.","category":"page"},{"location":"reference/optimisers/#Lagrangian-and-Augmented-Lagrangian-method","page":"Optimisers","title":"Lagrangian & Augmented Lagrangian method","text":"","category":"section"},{"location":"reference/optimisers/#GridapTopOpt.AugmentedLagrangian","page":"Optimisers","title":"GridapTopOpt.AugmentedLagrangian","text":"struct AugmentedLagrangian <: Optimiser\n\nAn augmented Lagrangian method based on Nocedal and Wright, 2006 (link). Note that this method will function as a Lagrangian method if no constraints are defined in problem::AbstractPDEConstrainedFunctionals.\n\nParameters\n\nproblem::AbstractPDEConstrainedFunctionals: The objective and constraint setup.\nls_evolver::LevelSetEvolution: Solver for the evolution and reinitisation equations.\nvel_ext::VelocityExtension: The velocity-extension method for extending shape sensitivities onto the computational domain.\nhistory::OptimiserHistory{Float64}: Historical information for optimisation problem.\nconverged::Function: A function to check optimiser convergence.\nhas_oscillations::Function: A function to check for oscillations.\nparams::NamedTuple: Optimisation parameters.\n\nThe has_oscillations function has been added to avoid oscillations in the iteration history. By default this uses a mean zero crossing algorithm as implemented in ChaosTools. Oscillations checking can be disabled by taking has_oscillations = (args...) -> false.\n\n\n\n\n\n","category":"type"},{"location":"reference/optimisers/#GridapTopOpt.AugmentedLagrangian-Union{Tuple{N}, Tuple{GridapTopOpt.AbstractPDEConstrainedFunctionals{N}, GridapTopOpt.LevelSetEvolution, VelocityExtension, Any}} where N","page":"Optimisers","title":"GridapTopOpt.AugmentedLagrangian","text":"AugmentedLagrangian(\n  problem    :: AbstractPDEConstrainedFunctionals{N},\n  ls_evolver :: LevelSetEvolution,\n  vel_ext    :: VelocityExtension,\n  φ0;\n  Λ_max = 10^10, ζ = 1.1, update_mod = 5, γ = 0.1, γ_reinit = 0.5, os_γ_mult = 0.75,\n  Λ_update_tol = 0.01,maxiter = 1000, verbose=false, constraint_names = map(i -> Symbol(\"C_$i\"),1:N),\n  converged::Function = default_al_converged, debug = false,\n  has_oscillations::Function = default_has_oscillations\n) where {N,O}\n\nCreate an instance of AugmentedLagrangian with several adjustable defaults.\n\nRequired\n\nproblem::AbstractPDEConstrainedFunctionals: The objective and constraint setup.\nls_evolver::LevelSetEvolution: Solver for the evolution and reinitisation equations.\nvel_ext::VelocityExtension: The velocity-extension method for extending shape sensitivities onto the computational domain.\nφ0: An initial level-set function defined as a FEFunction or GridapDistributed equivilent.\n\nOptional defaults\n\nγ = 0.1: Initial coeffient on the time step size for solving the Hamilton-Jacobi evolution equation.\nγ_reinit = 0.5: Coeffient on the time step size for solving the reinitisation equation.\nζ = 1.1: Increase multiplier on Λ every update_mod iterations.\nΛ_max = 10^10: Maximum value on any entry in Λ.\nupdate_mod = 5: Number of iterations before increasing Λ.\nreinit_mod = 1: How often we solve reinitialisation equation.\nmaxiter = 1000: Maximum number of algorithm iterations.\nverbose=false: Verbosity flag.\nconstraint_names = map(i -> Symbol(\"C_$i\"),1:N): Constraint names for history output.\nhas_oscillations::Function = default_has_oscillations: Function to check for oscillations in the history.\ninitial_parameters::Function = default_al_init_params: Function to generate initial λ, Λ. This can be replaced to inject different λ and Λ, for example.\nos_γ_mult = 0.75: Decrease multiplier for γ when has_oscillations returns true\nΛ_update_tol = 0.01: Tolerance of constraint satisfaction for updating Λ. In our testing, this is usually set to 0.01. Some problems, may perform better with a stricter tolerance (e.g., 0.001 or 0.0 to always update).\nconverged::Function = default_hp_converged: Convergence criteria.\ndebug = false: Debug flag.\n\n\n\n\n\n","category":"method"},{"location":"reference/optimisers/#Hilbertian-projection-method","page":"Optimisers","title":"Hilbertian projection method","text":"","category":"section"},{"location":"reference/optimisers/#GridapTopOpt.HilbertianProjection","page":"Optimisers","title":"GridapTopOpt.HilbertianProjection","text":"struct HilbertianProjection <: Optimiser\n\nA Hilbertian projection method as described by Wegert et al., 2023 (link).\n\nParameters\n\nproblem::AbstractPDEConstrainedFunctionals{N}: The objective and constraint setup.\nls_evolver::LevelSetEvolution: Solver for the evolution and reinitisation equations.\nvel_ext::VelocityExtension: The velocity-extension method for extending shape sensitivities onto the computational domain.\nprojector::HilbertianProjectionMap: Sensitivity information projector\nhistory::OptimiserHistory{Float64}: Historical information for optimisation problem.\nconverged::Function: A function to check optimiser convergence.\nhas_oscillations::Function: A function to check for oscillations.\nparams::NamedTuple: Optimisation parameters.\n\n\n\n\n\n","category":"type"},{"location":"reference/optimisers/#GridapTopOpt.HilbertianProjection-Union{Tuple{N}, Tuple{GridapTopOpt.AbstractPDEConstrainedFunctionals{N}, GridapTopOpt.LevelSetEvolution, VelocityExtension, Any}} where N","page":"Optimisers","title":"GridapTopOpt.HilbertianProjection","text":"HilbertianProjection(\n  problem :: AbstractPDEConstrainedFunctionals{N},\n  ls_evolver :: LevelSetEvolution,\n  vel_ext :: VelocityExtension,\n  φ0;\n  orthog = HPModifiedGramSchmidt(),\n  λ=0.5, α_min=0.1, α_max=1.0, γ=0.1, γ_reinit=0.5,\n  ls_max_iters = 10, ls_δ_inc = 1.1, ls_δ_dec = 0.7,\n  ls_ξ = 0.0025, ls_ξ_reduce_coef = 0.1, ls_ξ_reduce_abs_tol = 0.01,\n  ls_γ_min = 0.001, ls_γ_max = 0.1,\n  maxiter = 1000, verbose=false, constraint_names = map(i -> Symbol(\"C_$i\"),1:N),\n  converged::Function = default_hp_converged, debug = false\n) where {N}\n\nCreate an instance of HilbertianProjection with several adjustable defaults including the orthogonalisation method. By default the later is HPModifiedGramSchmidt.\n\nRequired\n\nproblem::AbstractPDEConstrainedFunctionals{N}: The objective and constraint setup.\nls_evolver::LevelSetEvolution: Solver for the evolution and reinitisation equations.\nvel_ext::VelocityExtension: The velocity-extension method for extending shape sensitivities onto the computational domain.\nφ0: An initial level-set function defined as a FEFunction or GridapDistributed equivilent.\n\nAlgorithm defaults\n\nγ = 0.1: Initial coeffient on the time step size for solving the Hamilton-Jacobi evolution equation.\nγ_reinit = 0.5: Coeffient on the time step size for solving the reinitisation equation.\nmaxiter = 1000: Maximum number of algorithm iterations.\nverbose=false: Verbosity flag.\nconstraint_names = map(i -> Symbol(\"C_$i\"),1:N): Constraint names for history output.\nconverged::Function = default_hp_converged: Convergence criteria.\nhas_oscillations::Function = (ls_enabled ? (args...)->false : default_has_oscillations: By default this is disabled when a line search in enabled.\nos_γ_mult = 0.5: Decrease multiplier for γ when has_oscillations returns true\ndebug = false: Debug flag.\nα_min ∈ [0,1] = 0.1: Controls lower bound on on the projected objective descent coefficent. α_min = 1 ignores the objective function and instead solves a constraint satisfaction problem.\nα_max ∈ [0,1] = 1.0: Controls the upper bound on the projected objective descent coeffient. Typically this shouldn't change unless wanting to approach the optimum 'slower'.\nλ = 0.5: The rate of contraint decrease.\n\nNote that in practice we usually only adjust α_min to control the balance between improving the objective or constraints.\n\nLine search defaults\n\nls_enabled = true: Set whether a line search is used.\nls_max_iters = 10: Maximum number of line search iterations.\nls_δ_inc = 1.1: Increase multiplier for γ on acceptance.\nls_δ_dec = 0.7: Decrease multiplier for γ on rejection.\nls_ξ = 1.0: Line search tolerance for objective reduction.\nls_ξ_reduce_coef = 0.0025: Coeffient on ls_ξ if constraints within tolerance (see below).\nls_ξ_reduce_abs_tol = 0.01: Tolerance on constraints to reduce ls_ξ via ls_ξ_reduce_coef.\nls_γ_min = 0.001: Minimum coeffient on the time step size for solving the HJ evolution equation.\nls_γ_max = 0.1: Maximum coeffient on the time step size for solving the HJ evolution equation.\n\nA more concervative evolution of the boundary can be achieved by decreasing ls_γ_max.\n\nnote: Note\nThe line search has been adjusted so that it is only enforced once the constraints are within a set tolerance. This generally leads to better optimisation histories, especially for problems where constraints are far from saturation and the objective must decrease to improve the constraints.This can be set to always be enfored by taking ls_ξ = 0.0025 and ls_ξ_reduce_coef = 0.1.\n\n\n\n\n\n","category":"method"},{"location":"reference/optimisers/#GridapTopOpt.HPModifiedGramSchmidt","page":"Optimisers","title":"GridapTopOpt.HPModifiedGramSchmidt","text":"HPModifiedGramSchmidt\n\nHigh performance modified Gram-Schmidt. Based on Algorithm 6 in this paper.\n\n\n\n\n\n","category":"type"},{"location":"reference/optimisers/#GridapTopOpt.OrthogonalisationMap","page":"Optimisers","title":"GridapTopOpt.OrthogonalisationMap","text":"OrthogonalisationMap\n\n\n\n\n\n","category":"type"},{"location":"reference/optimisers/#Optimiser-history","page":"Optimisers","title":"Optimiser history","text":"","category":"section"},{"location":"reference/optimisers/#GridapTopOpt.OptimiserHistory","page":"Optimisers","title":"GridapTopOpt.OptimiserHistory","text":"mutable struct OptimiserHistory{T}\n\nTrack historical information on optimisation problem iteration history.\n\nParameters\n\nniter::Int: Current iteration number\nkeys::Vector{Symbol}: Vector of symbols associated to values\nvalues::Dict{Symbol,Vector{T}}: Dictionary of vectors associated to keys\nbundles::Dict{Symbol,Vector{Symbol}}: Groups of symbols (e.g., a group of constraints)\nverbose::SolverVerboseLevel: Verbosity level\nmaxiter::Int: Maximum number of iterations.\n\nBehaviour\n\nIndexing at a specific iteration returns an OptimiserHistorySlice.\nIndexing with a key returns all values of that key\nIndexing with a key and iteration returns value/s of the key at the iteration.\n\n\n\n\n\n","category":"type"},{"location":"reference/optimisers/#GridapTopOpt.OptimiserHistorySlice","page":"Optimisers","title":"GridapTopOpt.OptimiserHistorySlice","text":"struct OptimiserHistorySlice{T} end\n\nA read-only wrapper of OptimiserHistory for IO display of iteration history at a specific iteration.\n\n\n\n\n\n","category":"type"},{"location":"reference/optimisers/#Custom-optimiser","page":"Optimisers","title":"Custom optimiser","text":"","category":"section"},{"location":"reference/optimisers/#GridapTopOpt.Optimiser","page":"Optimisers","title":"GridapTopOpt.Optimiser","text":"abstract type Optimiser\n\nOptimisers in GridapTopOpt.jl are implemented as iterators. Your own optimiser can be implemented by implementing concrete functionality of the below.\n\n\n\n\n\n","category":"type"},{"location":"reference/optimisers/#Base.iterate-Tuple{GridapTopOpt.Optimiser}","page":"Optimisers","title":"Base.iterate","text":"Base.iterate(::Optimiser)\n\nReturn tuple of first iteration state for Optimiser.\n\n\n\n\n\n","category":"method"},{"location":"reference/optimisers/#Base.iterate-Tuple{GridapTopOpt.Optimiser, Any}","page":"Optimisers","title":"Base.iterate","text":"Base.iterate(::Optimiser,state)\n\nReturn tuple of next iteration state given current state for Optimiser.\n\n\n\n\n\n","category":"method"},{"location":"reference/optimisers/#GridapTopOpt.get_history-Tuple{GridapTopOpt.Optimiser}","page":"Optimisers","title":"GridapTopOpt.get_history","text":"get_history(::Optimiser) :: OptimiserHistory\n\nGet OptimiserHistory from Optimiser.\n\n\n\n\n\n","category":"method"},{"location":"reference/optimisers/#GridapTopOpt.converged-Tuple{GridapTopOpt.Optimiser}","page":"Optimisers","title":"GridapTopOpt.converged","text":"converged(::Optimiser)\n\nReturn a Bool that is true if the Optimiser has converged, otherwise false.\n\n\n\n\n\n","category":"method"},{"location":"reference/utilities/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"reference/utilities/#Ersatz-material-interpolation","page":"Utilities","title":"Ersatz material interpolation","text":"","category":"section"},{"location":"reference/utilities/#GridapTopOpt.SmoothErsatzMaterialInterpolation","page":"Utilities","title":"GridapTopOpt.SmoothErsatzMaterialInterpolation","text":"struct SmoothErsatzMaterialInterpolation{M<:Vector{<:Number},N<:Vector{<:Number}}\n\nA wrapper holding parameters and methods for interpolating an integrand across a single boundary partialOmega.\n\nE.g., int fmathrmdOmega = int I(varphi)fmathrmdD where Omegasubset D is described by a level-set function varphi and I is an indicator function.\n\nProperties\n\nη::M: the interpolation or smoothing radius across ∂Ω\nϵ::M: the ersatz material density\nH: a smoothed Heaviside function\nDH: the derivative of H\nI: an indicator function\nρ: a function describing the volume density of Omega (e.g., mathrmVol(Omega) = int rho(varphi))mathrmdD)\n\nNote\n\nWe store η and ϵ as length-one vectors so that updating these values propagates through H, DH, etc.\nTo update η and/or ϵ in an instance m, take m.η .= <VALUE>.\nA conviencence constructor is provided to create an instance given η<:Number and ϵ<:Number.\n\n\n\n\n\n","category":"type"},{"location":"reference/utilities/#Mesh-labelling","page":"Utilities","title":"Mesh labelling","text":"","category":"section"},{"location":"reference/utilities/#GridapTopOpt.update_labels!","page":"Utilities","title":"GridapTopOpt.update_labels!","text":"update_labels!(e::Int,model,f_Γ::Function,name::String)\n\nGiven a tag number e, a DiscreteModel model, an indicator function f_Γ, and a string name, label the corresponding vertices, edges, and faces as name.\n\nNote: f_Γ must recieve a Vector and return a Boolean depending on whether it indicates Γ\n\n\n\n\n\n","category":"function"},{"location":"reference/utilities/#Helpers","page":"Utilities","title":"Helpers","text":"","category":"section"},{"location":"reference/utilities/#GridapTopOpt.initial_lsf","page":"Utilities","title":"GridapTopOpt.initial_lsf","text":"initial_lsf(ξ,a;b)\n\nGenerate a function f according to f(x) = -1/4 ∏ᵢ(cos(ξπ(xᵢ-bᵢ))) - a/4 where x is a vector with components xᵢ.\n\n\n\n\n\n","category":"function"},{"location":"reference/utilities/#GridapTopOpt.isotropic_elast_tensor","page":"Utilities","title":"GridapTopOpt.isotropic_elast_tensor","text":"isotropic_elast_tensor(D::Int,E::M,v::M)\n\nGenerate an isotropic SymFourthOrderTensorValue given a dimension D, Young's modulus E, and Poisson's ratio v.\n\n\n\n\n\n","category":"function"},{"location":"reference/utilities/#GridapTopOpt.get_cartesian_element_sizes","page":"Utilities","title":"GridapTopOpt.get_cartesian_element_sizes","text":"get_cartesian_element_sizes(model)\n\nGiven a CartesianDiscreteModel return the element size as a tuple.\n\n\n\n\n\n","category":"function"},{"location":"reference/utilities/#GridapTopOpt.get_element_diameters","page":"Utilities","title":"GridapTopOpt.get_element_diameters","text":"get_element_diameters(model)\n\nGiven a general unstructured model return the maximum vertex length of a polytope.\n\n\n\n\n\n","category":"function"},{"location":"reference/utilities/#GridapTopOpt.get_element_diameter_field","page":"Utilities","title":"GridapTopOpt.get_element_diameter_field","text":"get_element_diameter_field(model)\n\nGiven a general unstructured model return the maximum vertex length as a CellField over the triangulation.\n\n\n\n\n\n","category":"function"},{"location":"reference/utilities/","page":"Utilities","title":"Utilities","text":"warning: `get_cartesian_element_sizes` vs. `get_element_diameters`\nCurrently, we use different naming for returning the size of elements for a CartesianDiscreteModel and a general DiscreteModel.The function get_element_diameters returns a list of element diameters and should be used for TRI and TET polytopes (this can be extended to QUAD and HEX if needed).\nThe legacy function get_cartesian_element_sizes returns a tuple of a single element size for a mesh with homogenous sizes.","category":"page"},{"location":"#GridapTopOpt.jl","page":"Home","title":"GridapTopOpt.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for GridapTopOpt.jl!","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GridapTopOpt.jl is computational toolbox for level set-based topology optimisation implemented in Julia and the Gridap package ecosystem. The core design principle of GridapTopOpt.jl is to provide an extendable framework for solving optimisation problems in serial or parallel with a high-level programming interface and automatic differentiation. See the following publication for further details:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Wegert, Z.J., Manyer, J., Mallon, C.N. et al. GridapTopOpt.jl: a scalable Julia toolbox for level set-based topology optimisation. Struct Multidisc Optim 68, 22 (2025). https://doi.org/10.1007/s00158-024-03927-3","category":"page"},{"location":"#How-to-use-this-documentation","page":"Home","title":"How to use this documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The first step for new users is to visit the Getting Started page.\nA set of tutorials are available as part of the above paper.\nThe detailed documentation is in the Reference section.","category":"page"},{"location":"#Julia-educational-resources","page":"Home","title":"Julia educational resources","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A basic knowledge of the Julia programming language is needed to use the GridapTopOpt.jl package. Here, one can find a list of resources to get started with this programming language.","category":"page"},{"location":"","page":"Home","title":"Home","text":"First steps to learn Julia form the Gridap wiki page.\nOfficial webpage docs.julialang.org\nOfficial list of learning resources julialang.org/learning","category":"page"}]
}
