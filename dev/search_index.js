var documenterSearchIndex = {"docs":
[{"location":"reference/embedded/#Embedded","page":"Embedded","title":"Embedded","text":"","category":"section"},{"location":"reference/embedded/","page":"Embedded","title":"Embedded","text":"warning: Warning\nThis page is still under construction! Please refer to the tutorial for a discussion of functionality.","category":"page"},{"location":"reference/embedded/","page":"Embedded","title":"Embedded","text":"warning: Warning\nNon-TET/TRI polytopes are simplexified by GridapEmbedded when cutting. As a result, derivative information from AD will not be correct when using a mesh that isn't made of TRI/TET. Please use a mesh with TRI/TET polytopes to ensure correctness of derivative results.","category":"page"},{"location":"reference/embedded/#Isolated-volumes","page":"Embedded","title":"Isolated volumes","text":"","category":"section"},{"location":"reference/embedded/#GridapTopOpt.get_isolated_volumes_mask-Tuple{GridapEmbedded.Interfaces.EmbeddedDiscretization, Any}","page":"Embedded","title":"GridapTopOpt.get_isolated_volumes_mask","text":"get_isolated_volumes_mask(cutgeo::EmbeddedDiscretization,dirichlet_tags)\n\nGiven an EmbeddedDiscretization cutgeo and a list of tags dirichlet_tags, this function returns a CellField which is 1 on isolated volumes and 0 otherwise.\n\nWe define an isolated volume as a volume that is IN but is not constrained by any of the tags in dirichlet_tags. Specify the In domain using the first entry in groups.\n\nIf remove_cuts is true, then volumes that only contain CUT cells are also considered isolated.\n\n\n\n\n\n","category":"method"},{"location":"reference/embedded/#GridapTopOpt.tag_disconnected_volumes-Union{Tuple{Dc}, Tuple{Gridap.Geometry.DiscreteModel{Dc}, Vector{<:Integer}}} where Dc","page":"Embedded","title":"GridapTopOpt.tag_disconnected_volumes","text":"function tag_disconnected_volumes(\n    model::DiscreteModel{Dc},\n    cell_to_state::Vector{<:Integer};\n    groups = Tuple(unique(cell_to_state))\n)\n\nGiven a DiscreteModel model and an initial coloring cell_to_state, returns another coloring such that each color corresponds to a connected component of the graph of cells that are connected by a face and have their state in the same group.\n\n\n\n\n\n","category":"method"},{"location":"reference/embedded/#GridapTopOpt.tag_volume!-Union{Tuple{N}, Tuple{Int64, Int16, Union{Integer, NTuple{N, Integer}}, Vector{Vector{Int32}}, Vector{Int8}, Vector{Int16}, BitVector}} where N","page":"Embedded","title":"GridapTopOpt.tag_volume!","text":"function tag_volume!(\n    cell::Int,color::Int16,group::Union{Integer,NTuple{N,Integer}},\n    cell_to_nbors::Vector{Vector{Int32}},\n    cell_to_state::Vector{Int8},\n    cell_to_color::Vector{Int16},\n    touched::BitVector\n)\n\nStarting from a cell cell, crawls the cell graph provided by cell_to_nbors and colors all cells connected to cell that\n\nbelong to the group group (i.e., cell_to_state[cell] ∈ group), and\nhave not been seen yet (i.e., !touched[cell]).\n\nThis is done by using a breadth-first search algorithm.\n\n\n\n\n\n","category":"method"},{"location":"reference/embedded/#GridapTopOpt.get_isolated_volumes_mask_polytopal-Tuple{Gridap.Geometry.DiscreteModel, Any, Any}","page":"Embedded","title":"GridapTopOpt.get_isolated_volumes_mask_polytopal","text":"get_isolated_volumes_mask_polytopal(model::DiscreteModel,cell_values,dirichlet_tags)\n\nGiven a DiscreteModel model, the cell values of the level set function cell_values, and a list of tags dirichlet_tags, this function returns two cell fields:\n\ncf_IN: a CellField which is 1 on isolated volumes of the IN domain and 0 otherwise.\ncf_OUT: a CellField which is 1 on isolated volumes of the OUT domain and 0 otherwise.\n\n\n\n\n\n","category":"method"},{"location":"reference/embedded/#EmbeddedCollection-and-EmbeddedPDEConstrainedFunctionals","page":"Embedded","title":"EmbeddedCollection and EmbeddedPDEConstrainedFunctionals","text":"","category":"section"},{"location":"reference/embedded/#GridapTopOpt.EmbeddedCollection","page":"Embedded","title":"GridapTopOpt.EmbeddedCollection","text":"struct EmbeddedCollection\n  recipes :: Vector{<:Function}\n  objects :: Dict{Symbol,Any}\n  bgmodel :: DiscreteModel\nend\n\nA collection of embedded objects on the same background model. This structure provides a way to update all the stored objects at once.\n\nConstructor\n\nEmbeddedCollection(recipes::Union{<:Function,Vector{<:Function}},bgmodel::DiscreteModel[,φh])\n\nIf provided, φh will be used to compute the initial collection of objects. If not provided, the collection will remain empty until update_collection! is called.\n\nAPI:\n\nupdate_collection!(c::EmbeddedCollection,φh): Update the collection of objects using the level set function φh.\nadd_recipe!(c::EmbeddedCollection,r::Function[,φh]): Add a recipe to the collection. Update the collection if φh is provided.\n\n\n\n\n\n","category":"type"},{"location":"reference/embedded/","page":"Embedded","title":"Embedded","text":"We implement special structures that update the state map etc. on the fly using EmbeddedPDEConstrainedFunctionals:","category":"page"},{"location":"reference/embedded/#GridapTopOpt.EmbeddedCollection_in_φh","page":"Embedded","title":"GridapTopOpt.EmbeddedCollection_in_φh","text":"EmbeddedCollection_in_φh(recipes::Union{<:Function,Vector{<:Function}},bgmodel,φ0)\n\nReturns an EmbeddedCollection whoose recipes are only updated using the parameter φ0. This is useful for problems where the recipes are not computed using the cut geometry information.\n\n\n\n\n\n","category":"function"},{"location":"reference/embedded/#GridapTopOpt.EmbeddedPDEConstrainedFunctionals","page":"Embedded","title":"GridapTopOpt.EmbeddedPDEConstrainedFunctionals","text":"struct EmbeddedPDEConstrainedFunctionals{N,T} <: AbstractPDEConstrainedFunctionals{N}\n\nA version of PDEConstrainedFunctionals that has an embedded_collection to allow the state_map to be updated given new FE spaces for the forward problem. This is currently required for unfitted methods.\n\n\n\n\n\n","category":"type"},{"location":"reference/embedded/#GridapTopOpt.evaluate_functionals!-Tuple{EmbeddedPDEConstrainedFunctionals, Any}","page":"Embedded","title":"GridapTopOpt.evaluate_functionals!","text":"evaluate_functionals!(pcf::EmbeddedPDEConstrainedFunctionals,φh;update_space::Bool=true)\n\nEvaluate the objective and constraints at φh.\n\nwarning: Warning\nTaking update_space = false will NOT update the underlying finite element spaces and assemblers that depend on φh. This should only be used when you are certain that φh has not been updated.\n\n\n\n\n\n","category":"method"},{"location":"reference/embedded/#GridapTopOpt.evaluate_derivatives!-Tuple{EmbeddedPDEConstrainedFunctionals, Any}","page":"Embedded","title":"GridapTopOpt.evaluate_derivatives!","text":"evaluate_derivatives!(pcf::EmbeddedPDEConstrainedFunctionals,φh;update_space::Bool=true)\n\nEvaluate the derivatives of the objective and constraints at φh.\n\nwarning: Warning\nTaking update_space = false will NOT update the underlying finite element spaces and assemblers that depend on φh. This should only be used when you are certain that φh has not been updated.\n\n\n\n\n\n","category":"method"},{"location":"reference/embedded/#Gridap.Arrays.evaluate!-Tuple{EmbeddedPDEConstrainedFunctionals, Any}","page":"Embedded","title":"Gridap.Arrays.evaluate!","text":"Fields.evaluate!(pcf::EmbeddedPDEConstrainedFunctionals,φh;update_space::Bool=true)\n\nEvaluate the objective and constraints, and their derivatives at φh.\n\nwarning: Warning\nTaking update_space = false will NOT update the underlying finite element spaces and assemblers that depend on φh. This should only be used when you are certain that φh has not been updated.\n\n\n\n\n\n","category":"method"},{"location":"reference/embedded/#Automatic-shape-differentiation","page":"Embedded","title":"Automatic shape differentiation","text":"","category":"section"},{"location":"reference/embedded/","page":"Embedded","title":"Embedded","text":"Automatic shape differentiation has been moved to GridapEmbedded.","category":"page"},{"location":"reference/benchmarking/#Benchmarking","page":"Benchmarking","title":"Benchmarking","text":"","category":"section"},{"location":"reference/velext/#Velocity-extension","page":"Velocity extension","title":"Velocity extension","text":"","category":"section"},{"location":"reference/velext/#GridapTopOpt.AbstractVelocityExtension","page":"Velocity extension","title":"GridapTopOpt.AbstractVelocityExtension","text":"abstract type AbstractVelocityExtension end\n\nAn abstract type for velocity extension structures. Structs that inherit from   this type must implement the project! method.\n\n\n\n\n\n","category":"type"},{"location":"reference/velext/#GridapTopOpt.IdentityVelocityExtension","page":"Velocity extension","title":"GridapTopOpt.IdentityVelocityExtension","text":"struct IdentityVelocityExtension <: AbstractVelocityExtension\n\nA velocity-extension method that does nothing.\n\n\n\n\n\n","category":"type"},{"location":"reference/velext/#GridapTopOpt.VelocityExtension","page":"Velocity extension","title":"GridapTopOpt.VelocityExtension","text":"struct VelocityExtension{A,B} <: AbstractVelocityExtension\n\nWrapper to hold a stiffness matrix and a cache for the Hilbertian extension-regularisation. See Allaire et al. 2022 (link).\n\nThe Hilbertian extension-regularisation method involves solving an identification problem over a Hilbert space H on D with inner product langlecdotcdotrangle_H: Find g_Omegain H such that langle g_Omegawrangle_H =-J^prime(Omega)(wboldsymboln) forall win H\n\nThis provides two benefits:\n\nIt naturally extends the shape sensitivity from partialOmega onto the bounding domain D; and\nensures a descent direction for J(Omega) with additional regularity (i.e., H as opposed to L^2(partialOmega))\n\nProperties\n\nK::A: The discretised inner product over H.\nU_reg::B: The trial space used for the Hilbertian extension-regularisation.\ncache::C: Cached objects used for project!\n\n\n\n\n\n","category":"type"},{"location":"reference/velext/#GridapTopOpt.VelocityExtension-Tuple{Function, Gridap.FESpaces.FESpace, Gridap.FESpaces.FESpace}","page":"Velocity extension","title":"GridapTopOpt.VelocityExtension","text":"VelocityExtension(biform,U_reg,V_reg;assem,ls)\n\nCreate an instance of VelocityExtension given a bilinear form biform, trial space U_reg, and test space V_reg.\n\nOptional\n\nassem: A matrix assembler\nls::LinearSolver: A linear solver\n\n\n\n\n\n","category":"method"},{"location":"reference/velext/#GridapTopOpt.project!-Tuple{VelocityExtension, AbstractVector, Any, Any}","page":"Velocity extension","title":"GridapTopOpt.project!","text":"project!(vel_ext::VelocityExtension,dF::AbstractVector,V_φ,uhd) -> dF_reg::Vector\n\nProject dFh onto a function space described by the vel_ext.\n\nNote:\n\nWe expect that dF is a vector resulting from assembly on V_φ.\nuhd should be an FEFunction on V_φ.\n\n\n\n\n\n","category":"method"},{"location":"reference/zygote/#Zygote-and-GridapTopOpt-Compatability","page":"Zygote & GridapTopOpt Compatability","title":"Zygote & GridapTopOpt Compatability","text":"","category":"section"},{"location":"reference/zygote/","page":"Zygote & GridapTopOpt Compatability","title":"Zygote & GridapTopOpt Compatability","text":"As of v0.3.0, Zygote can be used for backwards AD in GridapTopOpt in serial and distributed.","category":"page"},{"location":"reference/zygote/#GridapTopOpt.CustomPDEConstrainedFunctionals","page":"Zygote & GridapTopOpt Compatability","title":"GridapTopOpt.CustomPDEConstrainedFunctionals","text":"CustomPDEConstrainedFunctionals{N,A} <:  AbstractPDEConstrainedFunctionals{N}\n\nA version of PDEConstrainedFunctionals that allows for an arbitrary mapping φ_to_jc that is used to compute the objective and constraints given the primal variable.\n\nUnder the hood, we use Zygote to compute the Jacobian of this mapping with the rrules defined throughout GridapTopOpt.\n\nParameters\n\nφ_to_jc: A function that defines the mapping from the primal variable φ to the objective and constraints. This should accept AbstractVector φ (the free values of φh) and output a scalar. In side this function, you should compute your states and evaluate your objectives and constraints that should be written as GridapTopOpt.StateParamMap. For example,\nusing GridapTopOpt: StateParamMap\n...\nJ = StateParamMap(j,state_map)\nC = StateParamMap(c,state_map)\nfunction φ_to_jc(φ)\n  u = state_map(φ)\n  [J(u,φ),C(u,φ)^2]\nend\npcfs = CustomPDEConstrainedFunctionals(φ_to_jc,state_map,φh)\nanalytic_dJ: Either a Function (if using analytic derivative) or nothing if using AD.\nanalytic_dC: A vector of Nothing or Function depending on whether using analytic derivatives or AD.\nstate_map::A: The state map for the problem. NOTE: this is a place holder for the optimiser output and in theory you could use many different state maps inside φ_to_jc.\n\nwarning: Warning\nThe expected function for analytic_dJ and functions of analytic_dC are different to usual. Here, you should define a function that takes an AbstractVector input corresponding to the derivative and the primal variable dofs φ and assembles the derivative into the AbstractVector input. For example,function analytic_dJ!(dJ,φ)\n  φh = FEFunction(V_φ,φ)\n  uh = get_state(state_map)\n  _dJ(q) = ∫(q*...)dΩ\n  Gridap.FESpaces.assemble_vector!(_dJ,dJ,V_φ)\nendThis functionality is subject to change.\n\n\n\n\n\n","category":"type"},{"location":"reference/zygote/#Staggered-type-problems","page":"Zygote & GridapTopOpt Compatability","title":"Staggered-type problems","text":"","category":"section"},{"location":"reference/zygote/","page":"Zygote & GridapTopOpt Compatability","title":"Zygote & GridapTopOpt Compatability","text":"Staggered-type problems can be handled purely with Zygote and the other existing StateMap implementations. This is preferred over the StaggeredStateMap implementations.","category":"page"},{"location":"reference/zygote/","page":"Zygote & GridapTopOpt Compatability","title":"Zygote & GridapTopOpt Compatability","text":"For example, we can solve a problem where the second FE problem depends on the first via the following:","category":"page"},{"location":"reference/zygote/","page":"Zygote & GridapTopOpt Compatability","title":"Zygote & GridapTopOpt Compatability","text":"## Weak forms\na1(u1,v1,φ) = ...\nl1(v1,φ) = ...\n# Treat (u1,φ) as the primal variable\na2(u2,v2,(u1,φ)) = ...\nl2(v2,(u1,φ)) = ...\n\n## Build StateMaps\nφ_to_u1 = AffineFEStateMap(a1,l1,U1,V,V_φ)\n# u1φ_to_u2 has a MultiFieldFESpace V_u1φ of primal vars\nu1φ_to_u2 = AffineFEStateMap(a2,l2,U2,V,V_u1φ)\n# The StateParamMap F needs to take a MultiFieldFEFunction u1u2h ∈ U_u1u2\nF = GridapTopOpt.StateParamMap(F,U_u1u2,V_φ,assem_U_u1u2,assem_V_φ)\n\nfunction φ_to_j(φ)\n  u1 = φ_to_u1(φ)\n  u1φ = combine_fields(V_u1φ,u1,φ) # Combine vectors of DOFs\n  u2 = u1φ_to_u2(u1φ)\n  u1u2 = combine_fields(U_u1u2,u1,u2)\n  F(u1u2,φ)\nend\n\npcf = CustomPDEConstrainedFunctionals(...)","category":"page"},{"location":"reference/zygote/#GridapTopOpt-GridapEmbedded-Zygote","page":"Zygote & GridapTopOpt Compatability","title":"GridapTopOpt + GridapEmbedded + Zygote","text":"","category":"section"},{"location":"reference/zygote/#GridapTopOpt.CustomEmbeddedPDEConstrainedFunctionals","page":"Zygote & GridapTopOpt Compatability","title":"GridapTopOpt.CustomEmbeddedPDEConstrainedFunctionals","text":"struct CustomEmbeddedPDEConstrainedFunctionals{N,A} <: AbstractPDEConstrainedFunctionals{N}\n\nA version of CustomPDEConstrainedFunctionals that has an embedded_collection to allow the state_map to be updated given new FE spaces for the forward problem. This is currently required for unfitted methods.\n\n\n\n\n\n","category":"type"},{"location":"reference/zygote/#GridapTopOpt.CustomEmbeddedPDEConstrainedFunctionals-Tuple{Function, Any, EmbeddedCollection}","page":"Zygote & GridapTopOpt Compatability","title":"GridapTopOpt.CustomEmbeddedPDEConstrainedFunctionals","text":"CustomEmbeddedPDEConstrainedFunctionals(\n  φ_to_jc :: Function,\n  num_constraints,\n  embedded_collection :: EmbeddedCollection;\n  analytic_dJ = nothing,\n  analytic_dC = fill(nothing,num_constraints)\n)\n\nCreate an instance of CustomEmbeddedPDEConstrainedFunctionals. Here, num_constraints specifies the number of constraints.\n\nnote: Note\nIf you have one or more state_map objects in embedded_collection, you should include these as a vector under the :state_map key of the embedded_collection. This is used in the optimiser to get the current state of the maps for the uh output infor (it, uh, φh) in optimiser\n  ...\nendIf you do not have a :state_map in the embedded_collection, then get_state, and the corresponding output of uh above will be nothing.This functionality is subject to change.\n\n\n\n\n\n","category":"method"},{"location":"reference/zygote/#PartitionedArrays-compatible-Zygote-methods","page":"Zygote & GridapTopOpt Compatability","title":"PartitionedArrays-compatible Zygote methods","text":"","category":"section"},{"location":"reference/zygote/#GridapTopOpt.val_and_gradient","page":"Zygote & GridapTopOpt Compatability","title":"GridapTopOpt.val_and_gradient","text":"val_and_gradient(f, args...)\n\nCompute the value and gradient of f at args. Equivalent to Zygote.withgradient except this is compatible with PartitionedArrays.\n\n\n\n\n\n","category":"function"},{"location":"reference/zygote/#GridapTopOpt.val_and_jacobian","page":"Zygote & GridapTopOpt Compatability","title":"GridapTopOpt.val_and_jacobian","text":"val_and_jacobian(f, args...;ignore_pullback=[])\n\nCompute the value and jacobian of f at args. Equivalent to Zygote.withjacobian except this is compatible with PartitionedArrays.\n\nTerms in the output of f can be ignored by specifying their indices in ignore_pullback. This is useful for when we have an analytic derivative.\n\n\n\n\n\n","category":"function"},{"location":"reference/zygote/","page":"Zygote & GridapTopOpt Compatability","title":"Zygote & GridapTopOpt Compatability","text":"Discussion of the usage of these can be found in this example.","category":"page"},{"location":"getting-started/#Getting-started","page":"Getting Started","title":"Getting started","text":"","category":"section"},{"location":"getting-started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"GridapTopOpt.jl and additional dependencies can be installed in an existing Julia environment using the package manager. This can be accessed in the Julia REPL (read-eval–print loop) by pressing ]. We then add the required packages via:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"pkg> add GridapTopOpt, Gridap, GridapDistributed, GridapPETSc, GridapSolvers, GridapEmbedded, PartitionedArrays, SparseMatricesCSR","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Once installed, serial driver scripts can be run immediately, whereas parallel problems also require an MPI installation.","category":"page"},{"location":"getting-started/#MPI","page":"Getting Started","title":"MPI","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"For basic users, MPI.jl provides such an implementation and a Julia wrapper for mpiexec - the MPI executor. This is installed via:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"pkg> add MPI\njulia> using MPI\njulia> MPI.install_mpiexecjl()","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Once the mpiexecjl wrapper has been added to the system PATH, MPI scripts can be executed in a terminal via","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"mpiexecjl -n P julia  main.jl","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"where main is a driver script, P denotes the number of processors.","category":"page"},{"location":"getting-started/#PETSc","page":"Getting Started","title":"PETSc","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"In GridapTopOpt.jl we rely on the GridapPETSc.jl satellite package to interface with the linear and nonlinear solvers provided by the PETSc (Portable, Extensible Toolkit for Scientific Computation) library. For basic users these solvers are provided by GridapPETSc.jl with no additional work.","category":"page"},{"location":"getting-started/#Advanced-installation","page":"Getting Started","title":"Advanced installation","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"For more advanced installations, such as use of a custom MPI/PETSc installation on a HPC cluster, we refer the reader to the discussion for GridapPETSc.jl and the configuration page for MPI.jl.","category":"page"},{"location":"getting-started/#Usage-and-tutorials","page":"Getting Started","title":"Usage and tutorials","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"In order to get familiar with the library we recommend following the numerical examples described in:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Wegert, Z.J., Manyer, J., Mallon, C.N. et al. GridapTopOpt.jl: a scalable Julia toolbox for level set-based topology optimisation. Struct Multidisc Optim 68, 22 (2025). https://doi.org/10.1007/s00158-024-03927-3","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Please note, there have been several breaking releases since the above publication was first submitted, please see Breaking Releases for a breakdown of these.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"In addition to these, there are several driver scripts available in /scripts/.. along with some examples in this documentation.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"More general tutorials for familiarising ones self with Gridap are available via the Gridap Tutorials.","category":"page"},{"location":"getting-started/#Known-issues","page":"Getting Started","title":"Known issues","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"PETSc's GAMG preconditioner breaks for split Dirichlet DoFs (e.g., x constrained while y free for a single node). There is no simple fix for this. We recommend instead using MUMPS or another preconditioner for this case.\nAnalytic gradient breaks in parallel for integrals of certain measures – Issue #46","category":"page"},{"location":"examples/Fluid-structure_interaction_with_CutFEM/#Fluid-structure-interaction-with-CutFEM","page":"FSI with CutFEM","title":"Fluid-structure interaction with CutFEM","text":"","category":"section"},{"location":"examples/Fluid-structure_interaction_with_CutFEM/","page":"FSI with CutFEM","title":"FSI with CutFEM","text":"note: Note\nThis page is under construction","category":"page"},{"location":"examples/Fluid-structure_interaction_with_CutFEM/","page":"FSI with CutFEM","title":"FSI with CutFEM","text":"The full script for this problem can be found in /scripts/Examples/Unfitted/FSI2D_CutFEM.jl.","category":"page"},{"location":"examples/AD-PDE-constrained-functions/#Automatic-Differentiation-of-generic-PDE-constrained-functions","page":"AD of generic PDE-constrained functions","title":"Automatic Differentiation of generic PDE-constrained functions","text":"","category":"section"},{"location":"examples/AD-PDE-constrained-functions/","page":"AD of generic PDE-constrained functions","title":"AD of generic PDE-constrained functions","text":"GridapTopOpt provides serial and distributed automatic differentiation methods for generic PDE-constrained functionals and arbitrary maps of those functionals. This works by:","category":"page"},{"location":"examples/AD-PDE-constrained-functions/","page":"AD of generic PDE-constrained functions","title":"AD of generic PDE-constrained functions","text":"Implementing adjoint methods for linear and non-linear finite element problems. We do this by creating new so-called StateMap operators AffineFEStateMap and NonlinearFEStateMap, these act like AffineFEOperator and FEOperator but also (efficently) implement adjoint methods.\nThe adjoint methods implemented in (1) work by overloading the rrule method from ChainRules.jl. As a result, more general backwards automatic differentation packages such as Zygote.jl can be utilised to compute derivatives of generic (and possibly quite complicated) maps.","category":"page"},{"location":"examples/AD-PDE-constrained-functions/","page":"AD of generic PDE-constrained functions","title":"AD of generic PDE-constrained functions","text":"Let's consider the following introductory example. Suppose we wish to differentiate","category":"page"},{"location":"examples/AD-PDE-constrained-functions/","page":"AD of generic PDE-constrained functions","title":"AD of generic PDE-constrained functions","text":"J(ukappa) = left(int_Omega(u(kappa)-u_textrmobs)mathrmdboldsymbolxright)^12","category":"page"},{"location":"examples/AD-PDE-constrained-functions/","page":"AD of generic PDE-constrained functions","title":"AD of generic PDE-constrained functions","text":"where u_textrmobs is some observed data and u depends on kappa through Poisson's equation: find uin H^1_g(Omega) such that a(uv) = l(v) for all vin H^1_0(Omega) where","category":"page"},{"location":"examples/AD-PDE-constrained-functions/","page":"AD of generic PDE-constrained functions","title":"AD of generic PDE-constrained functions","text":"$","category":"page"},{"location":"examples/AD-PDE-constrained-functions/","page":"AD of generic PDE-constrained functions","title":"AD of generic PDE-constrained functions","text":"\\begin{aligned} a(u,v) &= \\int\\Omega\\kappa\\nabla u\\cdot\\nabla v~\\mathrm{d}\\boldsymbol{x},\\\nl(v) &= \\int\\Omega vf~\\mathrm{d}\\boldsymbol{x}, \\end{aligned} $","category":"page"},{"location":"examples/AD-PDE-constrained-functions/","page":"AD of generic PDE-constrained functions","title":"AD of generic PDE-constrained functions","text":"and f(xy) = y and g(xy) = x. The derivative of J(u(kappa)kappa) with respect to kappa can be found using the following snippet:","category":"page"},{"location":"examples/AD-PDE-constrained-functions/","page":"AD of generic PDE-constrained functions","title":"AD of generic PDE-constrained functions","text":"using Gridap, GridapTopOpt\n\nf(x) = x[2]\ng(x) = x[1]\n\nmodel = CartesianDiscreteModel((0,1,0,1), (10,10))\nΩ = Triangulation(model)\ndΩ = Measure(Ω, 2)\nreffe = ReferenceFE(lagrangian, Float64, 1)\nK = TestFESpace(model, reffe)\nV = TestFESpace(model, reffe; dirichlet_tags=\"boundary\")\nU = TrialFESpace(V,x->x[1])\na(u, v, κ) = ∫(κ * ∇(v) ⋅ ∇(u))dΩ\nb(v, κ) = ∫(v*f)dΩ\nκ_to_u = AffineFEStateMap(a,b,U,V,K)\nl2_norm = GridapTopOpt.StateParamMap((u, κ) -> ∫(u ⋅ u)dΩ,κ_to_u)\nu_obs = interpolate(x -> sin(2π*x[1]), V) |> get_free_dof_values\nfunction J(κ)\n  u = κ_to_u(κ)\n  sqrt(l2_norm(u-u_obs, κ))\nend\nκ0h = interpolate(1.0, K)\nval, grad = GridapTopOpt.val_and_gradient(J, get_free_dof_values(κ0h))","category":"page"},{"location":"examples/AD-PDE-constrained-functions/","page":"AD of generic PDE-constrained functions","title":"AD of generic PDE-constrained functions","text":"The above is quite standard other than AffineFEStateMap, StateParamMap, and val_and_gradient. These work as follows:","category":"page"},{"location":"examples/AD-PDE-constrained-functions/","page":"AD of generic PDE-constrained functions","title":"AD of generic PDE-constrained functions","text":"AffineFEStateMap represents an (affine) FE operator that maps from kappa to u, and implements adjoint methods.\nStateParamMap is a wrapper for a function that produces a DomainContribution and handles partial differentiation in a Gridap-friendly. It also implements rrule methods so that Zygote can use the partial derivatives.\nval_and_gradient is a custom function for computing derivatives using Zygote. This works in almost the same way as Zygote.withgradient, except val_and_gradient is compatible with PartitionedArrays for distributed computation. Note that in serial, Zygote.withgradient will work as usual.","category":"page"},{"location":"examples/AD-PDE-constrained-functions/","page":"AD of generic PDE-constrained functions","title":"AD of generic PDE-constrained functions","text":"When J maps to multiple numbers (e.g., the case of having an objective and constraints), val_and_gradient can be replaced with val_and_jacobian.","category":"page"},{"location":"examples/AD-PDE-constrained-functions/","page":"AD of generic PDE-constrained functions","title":"AD of generic PDE-constrained functions","text":"Finally, we verify the above using finite differences as follows:","category":"page"},{"location":"examples/AD-PDE-constrained-functions/","page":"AD of generic PDE-constrained functions","title":"AD of generic PDE-constrained functions","text":"using FiniteDiff, Test\nfdm_grad = FiniteDiff.finite_difference_gradient(J, get_free_dof_values(κ0h))\n@test maximum(abs,grad[1] - fdm_grad)/maximum(abs, grad[1]) < 1e-7","category":"page"},{"location":"examples/AD-PDE-constrained-functions/","page":"AD of generic PDE-constrained functions","title":"AD of generic PDE-constrained functions","text":"Additional examples, as well as examples using GridapDistributed, can be found in src/tests/.","category":"page"},{"location":"examples/AD-PDE-constrained-functions/","page":"AD of generic PDE-constrained functions","title":"AD of generic PDE-constrained functions","text":"note: Note\nRefer to CustomPDEConstrainedFunctionals and CustomEmbeddedPDEConstrainedFunctionals when attempting to use this with the level-set topology optimisation methods in GridapTopOpt.","category":"page"},{"location":"examples/","page":"Introductory examples","title":"Introductory examples","text":"We refer users to the introductory examples found in:","category":"page"},{"location":"examples/","page":"Introductory examples","title":"Introductory examples","text":"Wegert, Z.J., Manyer, J., Mallon, C.N. et al. GridapTopOpt.jl: a scalable Julia toolbox for level set-based topology optimisation. Struct Multidisc Optim 68, 22 (2025). https://doi.org/10.1007/s00158-024-03927-3","category":"page"},{"location":"examples/","page":"Introductory examples","title":"Introductory examples","text":"warning: Warning\nSince this publication, there are been some minor API changes. See 'Breaking changes' for more information. Example scripts with the lastest API can be found in /scripts/Examples/....","category":"page"},{"location":"reference/io/#IO","page":"IO","title":"IO","text":"","category":"section"},{"location":"reference/io/","page":"IO","title":"IO","text":"In GridapTopOpt, the usual IO from Gridap is available. In addition, we also implement the below IO for convenience.","category":"page"},{"location":"reference/io/#Optimiser-history","page":"IO","title":"Optimiser history","text":"","category":"section"},{"location":"reference/io/#GridapTopOpt.write_history","page":"IO","title":"GridapTopOpt.write_history","text":"write_history(path::String,h::OptimiserHistory;ranks=nothing)\n\nWrite the contents of an OptimiserHistory object to a path. Provide MPI ranks when running in parallel.\n\n\n\n\n\n","category":"function"},{"location":"reference/io/#Object-IO-in-serial","page":"IO","title":"Object IO in serial","text":"","category":"section"},{"location":"reference/io/#GridapTopOpt.save","page":"IO","title":"GridapTopOpt.save","text":"save(filename::AbstractString, x)\n\nSave an object x to filename as a JLD2 file.\n\nNote: To save in MPI mode, use psave.\n\n\n\n\n\n","category":"function"},{"location":"reference/io/#GridapTopOpt.load","page":"IO","title":"GridapTopOpt.load","text":"load(filename::AbstractString)\n\nLoad an object stored in a JLD2 file at filename.\n\nNote: To load in MPI mode, use pload.\n\n\n\n\n\n","category":"function"},{"location":"reference/io/#GridapTopOpt.load!","page":"IO","title":"GridapTopOpt.load!","text":"load!(filename::AbstractString, x)\n\nLoad an object stored in a JLD2 file at filename and copy its contents to x.\n\nNote: To load! in MPI mode, use pload!.\n\n\n\n\n\n","category":"function"},{"location":"reference/io/#Object-IO-in-parallel","page":"IO","title":"Object IO in parallel","text":"","category":"section"},{"location":"reference/io/#GridapTopOpt.psave","page":"IO","title":"GridapTopOpt.psave","text":"psave(filename::AbstractString, x)\n\nSave a partitioned object x to a directory dir as a set of JLD2 files corresponding to each part.\n\n\n\n\n\n","category":"function"},{"location":"reference/io/#GridapTopOpt.pload","page":"IO","title":"GridapTopOpt.pload","text":"pload(dir::AbstractString, ranks::AbstractArray{<:Integer})\n\nLoad a partitioned object stored in a set of JLD2 files in directory dir indexed by MPI ranks ranks.\n\n\n\n\n\n","category":"function"},{"location":"reference/io/#GridapTopOpt.pload!","page":"IO","title":"GridapTopOpt.pload!","text":"pload!(dir::AbstractString, x)\n\nLoad a partitioned object stored in a set of JLD2 files in directory dir and copy contents to the equivilent object x.\n\n\n\n\n\n","category":"function"},{"location":"breaking-changes/#Breaking-Changes","page":"Breaking changes","title":"Breaking Changes","text":"","category":"section"},{"location":"breaking-changes/","page":"Breaking changes","title":"Breaking changes","text":"The following git diff shows a comparison between the script in Appendix B of the original GridapTopOpt paper and the most up-to-date version of the package. Details regarding all breaking changes can be found in the next section.","category":"page"},{"location":"breaking-changes/","page":"Breaking changes","title":"Breaking changes","text":"using GridapTopOpt, Gridap\n\nfunction main(write_dir)\n  # FE parameters\n  order = 1                                       # Finite element order\n  xmax,ymax = (1.0,1.0)                           # Domain size\n  dom = (0,xmax,0,ymax)                           # Bounding domain\n  el_size = (200,200)                             # Mesh partition size\n  prop_Γ_N = 0.2                                  # Γ_N size parameter\n  prop_Γ_D = 0.2                                  # Γ_D size parameter\n  f_Γ_N(x) = (x[1] ≈ xmax &&                      # Γ_N indicator function\n    ymax/2-ymax*prop_Γ_N/2 - eps() <= x[2] <= ymax/2+ymax*prop_Γ_N/2 + eps())\n  f_Γ_D(x) = (x[1] ≈ 0.0 &&                       # Γ_D indicator function\n    (x[2] <= ymax*prop_Γ_D + eps() || x[2] >= ymax-ymax*prop_Γ_D - eps()))\n  # FD parameters\n  γ = 0.1                                         # HJ eqn time step coeff\n  γ_reinit = 0.5                                  # Reinit. eqn time step coeff\n  max_steps = floor(Int,order*minimum(el_size)/10)# Max steps for advection\n  tol = 1/(5order^2)/minimum(el_size)\t\t      # Reinitialisation tolerance\n  # Problem parameters\n  κ = 1                                           # Diffusivity\n  g = 1                                           # Heat flow in\n  vf = 0.4                                        # Volume fraction constraint\n  lsf_func = initial_lsf(4,0.2)                   # Initial level set function\n  iter_mod = 10                                   # VTK Output modulo\n  path = \"$write_dir/therm_comp_serial/\"          # Output path\n  mkpath(path)                                    # Create path\n  # Model\n  model = CartesianDiscreteModel(dom,el_size);\n  update_labels!(1,model,f_Γ_D,\"Gamma_D\")\n  update_labels!(2,model,f_Γ_N,\"Gamma_N\")\n  # Triangulation and measures\n  Ω = Triangulation(model)\n  Γ_N = BoundaryTriangulation(model,tags=\"Gamma_N\")\n  dΩ = Measure(Ω,2*order)\n  dΓ_N = Measure(Γ_N,2*order)\n  # Spaces\n  reffe = ReferenceFE(lagrangian,Float64,order)\n  V = TestFESpace(model,reffe;dirichlet_tags=[\"Gamma_D\"])\n  U = TrialFESpace(V,0.0)\n  V_φ = TestFESpace(model,reffe)\n  V_reg = TestFESpace(model,reffe;dirichlet_tags=[\"Gamma_N\"])\n  U_reg = TrialFESpace(V_reg,0)\n  # Level set and interpolator\n  φh = interpolate(lsf_func,V_φ)\n  interp = SmoothErsatzMaterialInterpolation(η = 2*maximum(get_el_Δ(model)))\n  I,H,DH,ρ = interp.I,interp.H,interp.DH,interp.ρ\n  # Weak formulation\n- a(u,v,φ,dΩ,dΓ_N) = ∫((I ∘ φ)*κ*∇(u)⋅∇(v))dΩ\n- l(v,φ,dΩ,dΓ_N) = ∫(g*v)dΓ_N\n+ a(u,v,φ) = ∫((I ∘ φ)*κ*∇(u)⋅∇(v))dΩ\n+ l(v,φ) = ∫(g*v)dΓ_N\n- state_map = AffineFEStateMap(a,l,U,V,V_φ,U_reg,φh,dΩ,dΓ_N)\n+ state_map = AffineFEStateMap(a,l,U,V,V_φ)\n  # Objective and constraints\n- J(u,φ,dΩ,dΓ_N) = ∫((I ∘ φ)*κ*∇(u)⋅∇(u))dΩ\n- dJ(q,u,φ,dΩ,dΓ_N) = ∫(κ*∇(u)⋅∇(u)*q*(DH ∘ φ)*(norm ∘ ∇(φ)))dΩ\n+ J(u,φ) = ∫((I ∘ φ)*κ*∇(u)⋅∇(u))dΩ\n+ dJ(q,u,φ) = ∫(κ*∇(u)⋅∇(u)*q*(DH ∘ φ)*(norm ∘ ∇(φ)))dΩ\n  vol_D = sum(∫(1)dΩ)\n- C1(u,φ,dΩ,dΓ_N) = ∫(((ρ ∘ φ) - vf)/vol_D)dΩ\n- dC1(q,u,φ,dΩ,dΓ_N) = ∫(-1/vol_D*q*(DH ∘ φ)*(norm ∘ ∇(φ)))dΩ\n+ C1(u,φ) = ∫(((ρ ∘ φ) - vf)/vol_D)dΩ\n+ dC1(q,u,φ) = ∫(-1/vol_D*q*(DH ∘ φ)*(norm ∘ ∇(φ)))dΩ\n  pcfs = PDEConstrainedFunctionals(J,[C1],state_map,\n    analytic_dJ=dJ,analytic_dC=[dC1])\n  # Velocity extension\n  α = 4max_steps*γ*maximum(get_el_Δ(model))\n  a_hilb(p,q) =∫(α^2*∇(p)⋅∇(q) + p*q)dΩ\n  vel_ext = VelocityExtension(a_hilb,U_reg,V_reg)\n  # Finite difference scheme\n  scheme = FirstOrderStencil(length(el_size),Float64)\n- ls_evo = HamiltonJacobiEvolution(scheme,model,V_φ,tol,max_steps)\n+ evo = FiniteDifferenceEvolver(scheme,model,V_φ;max_steps)\n+ reinit = FiniteDifferenceReinitialiser(scheme,model,V_φ;tol,γ_reinit)\n+ ls_evo = LevelSetEvolution(evo,reinit)\n  # Optimiser\n- optimiser = AugmentedLagrangian(pcfs,ls_evo,vel_ext,φh;γ,γ_reinit,\n-   verbose=true)\n+ optimiser = AugmentedLagrangian(pcfs,ls_evo,vel_ext,φh;γ,verbose=true)\n  # Solve\n  for (it,uh,φh) in optimiser\n    data = [\"φ\"=>φh,\"H(φ)\"=>(H ∘ φh),\"|∇(φ)|\"=>(norm ∘ ∇(φh)),\"uh\"=>uh]\n    iszero(it % iter_mod) && writevtk(Ω,path*\"out$it\",cellfields=data)\n    write_history(path*\"/history.txt\",get_history(optimiser))\n  end\n  # Final structure\n  it = get_history(optimiser).niter; uh = get_state(pcfs)\n  writevtk(Ω,path*\"out$it\",cellfields=[\"φ\"=>φh,\n    \"H(φ)\"=>(H ∘ φh),\"|∇(φ)|\"=>(norm ∘ ∇(φh)),\"uh\"=>uh])\nend\n\nmain(\"results/\")","category":"page"},{"location":"breaking-changes/#Details-of-all-breaking-changes","page":"Breaking changes","title":"Details of all breaking changes","text":"","category":"section"},{"location":"breaking-changes/","page":"Breaking changes","title":"Breaking changes","text":"This page will be updated in the event that a breaking change is introduced into the source code.","category":"page"},{"location":"breaking-changes/#Updating-from-v0.2-to-v0.3/v0.4","page":"Breaking changes","title":"Updating from v0.2 to v0.3/v0.4","text":"","category":"section"},{"location":"breaking-changes/","page":"Breaking changes","title":"Breaking changes","text":"In v0.3 we added Zygote compatability for backwards differentiation in serial and parallel. In addition, in v0.4 we removed the requirement for φh to be passed to the constructors of StateMaps (excepting staggered maps). Below we list any breaking changes that will require changes to scripts implemented in v0.2:","category":"page"},{"location":"breaking-changes/","page":"Breaking changes","title":"Breaking changes","text":"StateMaps now always differentiate onto the space of the primal variable. See #76 for details. This introduces a breaking API change as U_reg and φh are removed from constructors of StateMaps. E.g.,\n  AffineFEStateMap(a,l,U,V,V_φ,U_reg,φh)\nbecomes\n  AffineFEStateMap(a,l,U,V,V_φ)\nBackwards compatability has been added here to ensure that the old API produces a meaningful error.\nThe way that we allocate vectors for distributed has been reworked. Now, we always create derivatives using zero(<:FESpace), we then move this to the correct type of array when required. For example, if needing to interpolate onto a RHS vector (this doesn't have ghosts in distributed), we can use the functionality _interpolate_onto_rhs!. This change cleans up a lot of the constructors for <:StateMap and StateMapWithParam. Any code implemented that relies on the old approach for allocating vectors should be adjusted accordingly.","category":"page"},{"location":"breaking-changes/#Updating-from-v0.1-to-v0.2","page":"Breaking changes","title":"Updating from v0.1 to v0.2","text":"","category":"section"},{"location":"breaking-changes/","page":"Breaking changes","title":"Breaking changes","text":"In v0.2 we made several quality of life changes and enabled compatability with GridapEmbedded. Below we list any breaking changes that will require changes to scripts implemented in v0.1:","category":"page"},{"location":"breaking-changes/","page":"Breaking changes","title":"Breaking changes","text":"Automatic differentiation capability has now been added to GridapDistributed. As a result, the IntegrandWithMeasure structure has been removed. In addition functionals previously required the measures to be passed as arguments, e.g.,\nJ(u,φ,dΩ,dΓ_N) = ∫(f(u,φ))dΩ + ∫(g(u,φ))dΓ_N\nThis is no longer required and the above should instead be written as\nJ(u,φ) = ∫(f(u,φ))dΩ + ∫(g(u,φ))dΓ_N","category":"page"},{"location":"reference/statemaps/#StateMaps","page":"StateMaps","title":"StateMaps","text":"","category":"section"},{"location":"reference/statemaps/","page":"StateMaps","title":"StateMaps","text":"compat: Compat\nFormally known as ChainRules.","category":"page"},{"location":"reference/statemaps/#PDEConstrainedFunctionals","page":"StateMaps","title":"PDEConstrainedFunctionals","text":"","category":"section"},{"location":"reference/statemaps/#GridapTopOpt.PDEConstrainedFunctionals","page":"StateMaps","title":"GridapTopOpt.PDEConstrainedFunctionals","text":"struct PDEConstrainedFunctionals{N,A} <: AbstractPDEConstrainedFunctionals{N}\n\nAn object that computes the objective, constraints, and their derivatives.\n\nImplementation\n\nThis implementation computes derivatives of a integral quantity\n\nF(u(varphi)varphimathrmdOmega_1mathrmdOmega_2) = Sigma_iint_Omega_i f_i(varphi)mathrmdOmega\n\nwith respect to an auxiliary parameter varphi where u is the solution to a PDE and implicitly depends on varphi. This requires two pieces of information:\n\nComputation of fracpartial Fpartial u and fracpartial Fpartial varphi (handled by StateParamMap).\nComputation of fracpartial Fpartial u fracpartial upartial varphi at varphi and u using the adjoint method (handled by AbstractFEStateMap). I.e., let\nfracpartial Fpartial u fracpartial upartial varphi = -lambda^intercal fracpartial mathcalRpartial varphi\nwhere mathcalR is the residual and solve the (linear) adjoint problem:\nfracpartial mathcalRpartial u^intercallambda = fracpartial Fpartial u^intercal\n\nThe gradient is then fracpartial Fpartial varphi = fracpartial Fpartial varphi - fracpartial Fpartial ufracpartial upartial varphi.\n\nParameters\n\nJ: A StateParamMap corresponding to the objective.\nC: A vector of StateParamMap corresponding to the constraints.\ndJ: The DoFs for the objective sensitivity.\ndC: The DoFs for each constraint sensitivity.\nanalytic_dJ: a Function for computing the analytic objective sensitivity.\nanalytic_dC: A vector of Function for computing the analytic objective sensitivities.\nstate_map::A: The state map for the problem.\n\nNote\n\nIf analytic_dJ = nothing automatic differentiation will be used.\nIf analytic_dC[i] = nothing automatic differentiation will be used for C[i].\n\n\n\n\n\n","category":"type"},{"location":"reference/statemaps/#Gridap.Arrays.evaluate!-Tuple{PDEConstrainedFunctionals, Any}","page":"StateMaps","title":"Gridap.Arrays.evaluate!","text":"Fields.evaluate!(pcf::PDEConstrainedFunctionals,φh)\n\nEvaluate the objective and constraints, and their derivatives at φh.\n\n\n\n\n\n","category":"method"},{"location":"reference/statemaps/#GridapTopOpt.evaluate_functionals!-Tuple{PDEConstrainedFunctionals, Any}","page":"StateMaps","title":"GridapTopOpt.evaluate_functionals!","text":"evaluate_functionals!(pcf::PDEConstrainedFunctionals,φh)\n\nEvaluate the objective and constraints at φh.\n\n\n\n\n\n","category":"method"},{"location":"reference/statemaps/#GridapTopOpt.evaluate_derivatives!-Tuple{PDEConstrainedFunctionals, Any}","page":"StateMaps","title":"GridapTopOpt.evaluate_derivatives!","text":"evaluate_derivatives!(pcf::PDEConstrainedFunctionals,φh)\n\nEvaluate the derivatives of the objective and constraints at φh.\n\n\n\n\n\n","category":"method"},{"location":"reference/statemaps/#GridapTopOpt.get_state","page":"StateMaps","title":"GridapTopOpt.get_state","text":"get_state(m::AbstractFEStateMap)\n\nReturn the solution/state u to the FE problem.\n\n\n\n\n\n","category":"function"},{"location":"reference/statemaps/#StateParamMap","page":"StateMaps","title":"StateParamMap","text":"","category":"section"},{"location":"reference/statemaps/#GridapTopOpt.StateParamMap","page":"StateMaps","title":"GridapTopOpt.StateParamMap","text":"struct StateParamMap{A,B,C,D} <: AbstractStateParamMap\n\nA wrapper to handle partial differentation of a function F of a specific form (see below) in a ChainRules.jl compatible way with caching.\n\nAssumptions\n\nWe assume that we have a function F of the following form:\n\nF(u,φ) = ∫(f(u,φ))dΩ₁ + ∫(g(u,φ))dΩ₂ + ...,.\n\nwhere u and φ are each expected to inherit from Union{FEFunction,MultiFieldFEFunction} or the GridapDistributed equivalent.\n\n\n\n\n\n","category":"type"},{"location":"reference/statemaps/#ChainRulesCore.rrule-Tuple{StateParamMap, Any, Any}","page":"StateMaps","title":"ChainRulesCore.rrule","text":"ChainRulesCore.rrule(u_to_j::StateParamMap,uh,φh)\n\nReturn the evaluation of a StateParamMap and a a function for evaluating the pullback of u_to_j. This enables compatiblity with ChainRules.jl\n\n\n\n\n\n","category":"method"},{"location":"reference/statemaps/#Implemented-types-of-AbstractFEStateMap","page":"StateMaps","title":"Implemented types of AbstractFEStateMap","text":"","category":"section"},{"location":"reference/statemaps/#GridapTopOpt.AbstractFEStateMap","page":"StateMaps","title":"GridapTopOpt.AbstractFEStateMap","text":"abstract type AbstractFEStateMap\n\nTypes inheriting from this abstract type should enable the evaluation and differentiation of the solution to an FE problem u that implicitly depends on an auxiliary parameter φ.\n\n\n\n\n\n","category":"type"},{"location":"reference/statemaps/#AffineFEStateMap","page":"StateMaps","title":"AffineFEStateMap","text":"","category":"section"},{"location":"reference/statemaps/#GridapTopOpt.AffineFEStateMap","page":"StateMaps","title":"GridapTopOpt.AffineFEStateMap","text":"struct AffineFEStateMap{A,B,C,D,E,F} <: AbstractFEStateMap\n\nA structure to enable the forward problem and pullback for affine finite element operators AffineFEOperator.\n\nParameters\n\nbiform::A: Function defining the bilinear form.\nliform::B: Function defining the linear form.\nspaces::C: Tuple of finite element spaces.\nassems::D: Tuple of assemblers\ncache::E: An AffineFEStateMapCache\nupdate_opts::Tuple{Vararg{Bool}}: Special options to optimise the state map update.\n\n\n\n\n\n","category":"type"},{"location":"reference/statemaps/#GridapTopOpt.AffineFEStateMap-Tuple{Function, Function, Any, Any, Any}","page":"StateMaps","title":"GridapTopOpt.AffineFEStateMap","text":"AffineFEStateMap(\n  a::Function,l::Function,U,V,V_φ;\n  assem_U = SparseMatrixAssembler(U,V),\n  assem_adjoint = SparseMatrixAssembler(V,U),\n  assem_deriv = SparseMatrixAssembler(V_φ,V_φ),\n  ls::LinearSolver = LUSolver(),\n  adjoint_ls::LinearSolver = LUSolver(),\n  reassemble_matrix::Bool = true,\n  reassemble_adjoint::Bool = true,\n  reassemble_adjoint_in_pullback::Bool = false,\n  precompute_uhd::Bool = false\n)\n\nCreate an instance of AffineFEStateMap given the bilinear form a and linear form l as Function types, trial and test spaces U and V, the FE space V_φ for φh and derivatives, and the measures as additional arguments.\n\nOptional arguments enable specification of assemblers, linear solvers, and advanced options.\n\nThe advanced options should not be adjusted unless you know what you're doing! They are:\n\nreassemble_matrix: If true, the matrix is reassembled when the solver is called. By default, this is true and  is only false for special iterated problem (e.g., [*]).\nreassemble_adjoint: If true, the adjoint matrix is reassembled when the adjoint solver is built. By default, this is true and is only false for special iterated problem (e.g., [*]).\nreassemble_adjoint_in_pullback: If true, the adjoint matrix is reassembled in the pullback. By default, this is false and is only required for special iterated problem (e.g., transient with non-constant matrices).\nprecompute_uhd: If true, the uhd vector is precomputed and stored in the cache. By default, this is false and is only true when it is advantageous to avoid allocation of many uhd FEFunctions (e.g., transient problems with many time steps).\n\n[*] Transient with constant matrices where we only update once\n\n\n\n\n\n","category":"method"},{"location":"reference/statemaps/#NonlinearFEStateMap","page":"StateMaps","title":"NonlinearFEStateMap","text":"","category":"section"},{"location":"reference/statemaps/#GridapTopOpt.NonlinearFEStateMap","page":"StateMaps","title":"GridapTopOpt.NonlinearFEStateMap","text":"struct NonlinearFEStateMap{A,B,C,D,E} <: AbstractFEStateMap\n\nA structure to enable the forward problem and pullback for nonlinear finite element operators.\n\nParameters\n\nres: a Function defining the residual of the problem.\njacs: a tuple of Functions defining the Jacobian of the residual and the Jacobian for the adjoint. This allows the user to specify a different Jacobian for the forward problem/adjoint problem (e.g., Picard iterations).\nspaces: Tuple of finite element spaces.\nassems: Tuple of assemblers\ncache: An AffineFEStateMapCache\nupdate_opts::Tuple{Vararg{Bool}}: Special options to optimise the state map update.\n\n\n\n\n\n","category":"type"},{"location":"reference/statemaps/#GridapTopOpt.NonlinearFEStateMap-Tuple{Function, Function, Any, Any, Any}","page":"StateMaps","title":"GridapTopOpt.NonlinearFEStateMap","text":"NonlinearFEStateMap(\n  res::Function,jac::Function,U,V,V_φ;\n  assem_U = SparseMatrixAssembler(U,V),\n  assem_adjoint = SparseMatrixAssembler(V,U),\n  assem_deriv = SparseMatrixAssembler(V_φ,V_φ),\n  nls::NonlinearSolver = NewtonSolver(LUSolver();maxiter=50,rtol=1.e-8,verbose=true),\n  adjoint_ls::LinearSolver = LUSolver(),\n  adjoint_jac::Function = jac,\n  reassemble_adjoint_in_pullback::Bool = false\n)\n\nCreate an instance of NonlinearFEStateMap given the residual res as a Function type, trial and test spaces U and V, the FE space V_φ for φh and derivatives, and the measures as additional arguments.\n\nOptional arguments enable specification of assemblers, nonlinear solver, and adjoint (linear) solver. In addition, the jacobian adjoint_jac can be optionally specified for the purposes of solving the adjoint problem. This can be computed with AD or by hand, but and allows the user to specify a different jacobian for the forward problem (e.g., for picard iterations).\n\nThe optional argument reassemble_adjoint_in_pullback (default false) allows the user to specify whether the adjoint matrix should be reassembled in the pullback. This is required for transient problems with a non-linear residual.\n\n\n\n\n\n","category":"method"},{"location":"reference/statemaps/#RepeatingAffineFEStateMap","page":"StateMaps","title":"RepeatingAffineFEStateMap","text":"","category":"section"},{"location":"reference/statemaps/#GridapTopOpt.RepeatingAffineFEStateMap","page":"StateMaps","title":"GridapTopOpt.RepeatingAffineFEStateMap","text":"struct RepeatingAffineFEStateMap <: AbstractFEStateMap\n\nA structure to enable the forward problem and pullback for affine finite element operators AffineFEOperator with multiple linear forms but only a single bilinear form.\n\nParameters\n\nbiform: A Function defining the bilinear form.\nliform: A vector of Function defining the linear forms.\nspaces: Repeated finite element spaces.\nspaces_0: Original finite element spaces that are being repeated.\nassems: Tuple of assemblers\ncache: An AffineFEStateMapCache\n\n\n\n\n\n","category":"type"},{"location":"reference/statemaps/#GridapTopOpt.RepeatingAffineFEStateMap-Tuple{Int64, Function, Vector{<:Function}, Any, Any, Any}","page":"StateMaps","title":"GridapTopOpt.RepeatingAffineFEStateMap","text":"RepeatingAffineFEStateMap(\n  nblocks::Int,biform::Function,liforms::Vector{<:Function},U0,V0,V_φ;\n  assem_U = SparseMatrixAssembler(U0,V0),\n  assem_adjoint = SparseMatrixAssembler(V0,U0),\n  assem_deriv = SparseMatrixAssembler(V_φ,V_φ),\n  ls::LinearSolver = LUSolver(),\n  adjoint_ls::LinearSolver = LUSolver()\n)\n\nCreate an instance of RepeatingAffineFEStateMap given the number of blocks nblocks, a bilinear form a, a vector of linear form l as Function types, the trial and test spaces U and V, the FE space V_φ for φh and derivatives, and the measures as additional arguments.\n\nOptional arguments enable specification of assemblers and linear solvers.\n\nNote\n\nThe resulting FEFunction will be a MultiFieldFEFunction (or GridapDistributed equivalent) where each field corresponds to an entry in the vector of linear forms\n\n\n\n\n\n","category":"method"},{"location":"reference/statemaps/#StaggeredAffineFEStateMap-and-StaggeredNonlinearFEStateMap","page":"StateMaps","title":"StaggeredAffineFEStateMap and StaggeredNonlinearFEStateMap","text":"","category":"section"},{"location":"reference/statemaps/#GridapTopOpt.StaggeredAffineFEStateMap","page":"StateMaps","title":"GridapTopOpt.StaggeredAffineFEStateMap","text":"struct StaggeredAffineFEStateMap{NB,SB} <: AbstractFEStateMap{NB,SB}\n  biforms    :: Vector{<:Function}\n  liforms    :: Vector{<:Function}\n  ∂Rk∂xhi    :: Tuple{Vararg{Tuple{Vararg{Function}}}}\n  spaces     :: A\n  assems     :: B\n  solvers    :: C\n  plb_caches :: D\n  fwd_caches :: E\n  adj_caches :: F\nend\n\nAffine staggered state map for the equivalent StaggeredAffineFEOperator, used to solve staggered problems where the k-th equation is linear in u_k.\n\nSimilar to the StaggeredAffineFEOperator counterpart, we expect a set of bilinear/linear form pairs that also depend on φ:\n\na_k((u_1,...,u_{k-1}),u_k,v_k,φ) = ∫(...)\nl_k((u_1,...,u_{k-1}),v_k,φ) = ∫(...)\n\nThese can be assembled into a set of linear systems:\n\nA_k u_k = b_k\n\nwhere A_k and b_k only depend on the previous variables u_1,...,u_{k-1}.\n\nnote: Note\nStaggered-type problems can be handled purely with Zygote and the other existing StateMap implementations. This is preferred over the StaggeredStateMaps implementations.For example,## Weak forms\na1(u1,v1,φ) = ...\nl1(v1,φ) = ...\n# Treat (u1,φ) as the primal variable\na2(u2,v2,(u1,φ)) = ...\nl2(v2,(u1,φ)) = ...\n\n## Build StateMaps\nφ_to_u1 = AffineFEStateMap(a1,l1,U1,V,V_φ)\n# u1φ_to_u2 has a MultiFieldFESpace V_u1φ of primal vars\nu1φ_to_u2 = AffineFEStateMap(a2,l2,U2,V,V_u1φ)\n# The StateParamMap F needs to take a MultiFieldFEFunction u1u2h ∈ U_u1u2\nF = GridapTopOpt.StateParamMap(F,U_u1u2,V_φ,assem_U_u1u2,assem_V_φ)\n\nfunction φ_to_j(φ)\n  u1 = φ_to_u1(φ)\n  u1φ = combine_fields(V_u1φ,u1,φ) # Combine vectors of DOFs\n  u2 = u1φ_to_u2(u1φ)\n  u1u2 = combine_fields(U_u1u2,u1,u2)\n  F(u1u2,φ)\nend\n\npcf = CustomPDEConstrainedFunctionals(...)StaggeredStateMaps will remain in GridapTopOpt for backwards compatibility. These methods will not be updated in future unless required due to breaking changes.\n\n\n\n\n\n","category":"type"},{"location":"reference/statemaps/#GridapTopOpt.StaggeredAffineFEStateMap-Union{Tuple{SB}, Tuple{NB}, Tuple{GridapSolvers.BlockSolvers.StaggeredAffineFEOperator{NB, SB}, Any, Any}} where {NB, SB}","page":"StateMaps","title":"GridapTopOpt.StaggeredAffineFEStateMap","text":"StaggeredAffineFEStateMap(\n    op              :: StaggeredAffineFEOperator{NB,SB},\n    V_φ,\n    φh;\n    assem_deriv     :: Assembler = SparseMatrixAssembler(V_φ,V_φ),\n    assems_adjoint  :: Vector{<:Assembler} = map(SparseMatrixAssembler,op.tests,op.trials),\n    solver          :: StaggeredFESolver{NB} = StaggeredFESolver(fill(LUSolver(),length(op.biforms))),\n    adjoint_solver  :: StaggeredFESolver{NB} = StaggeredFESolver(fill(LUSolver(),length(op.biforms)))\n) where {NB,SB}\n\nCreate an instance of StaggeredAffineFEStateMap given a StaggeredAffineFEOperator op, the auxiliary space V_φ for φh and derivatives, and the parameter φh.\n\nOtional arguemnts:\n\nassem_deriv is the assembler for the derivative space.\nassems_adjoint is a vector of assemblers for the adjoint space.\nsolver is a StaggeredFESolver for the forward problem.\nadjoint_solver is a StaggeredFESolver for the adjoint problem.\n\n\n\n\n\n","category":"method"},{"location":"reference/statemaps/#GridapTopOpt.StaggeredNonlinearFEStateMap","page":"StateMaps","title":"GridapTopOpt.StaggeredNonlinearFEStateMap","text":"mutable struct StaggeredNonlinearFEStateMap{NB,SB} <: AbstractFEStateMap{NB,SB}\n  const residuals         :: Vector{<:Function}\n  const jacobians         :: Vector{<:Function}\n  const adjoint_jacobians :: Vector{<:Function}\n  const ∂Rk∂xhi           :: Tuple{Vararg{Tuple{Vararg{Function}}}}\n  const spaces            :: A\n  const assems            :: B\n  const solvers           :: C\n  const plb_caches        :: D\n  fwd_caches              :: E\n  const adj_caches        :: F\nend\n\nStaggered nonlinear state map for the equivalent StaggeredNonlinearFEOperator, used to solve staggered problems where the k-th equation is nonlinear in u_k.\n\nSimilar to the previous structure and the StaggeredNonlinearFEOperator counterpart, we expect a set of residual/jacobian pairs that also depend on φ:\n\njack((u1,...,u{k-1},φ),uk,duk,dvk) = ∫(...)   resk((u1,...,u{k-1},φ),uk,v_k) = ∫(...)\n\nnote: Note\nStaggered-type problems can be handled purely with Zygote and the other existing StateMap implementations. This is preferred over the StaggeredStateMaps implementations. See StaggeredAffineFEStateMapStaggeredStateMaps will remain in GridapTopOpt for backwards compatibility. These methods will not be updated in future unless required due to breaking changes.\n\n\n\n\n\n","category":"type"},{"location":"reference/statemaps/#GridapTopOpt.StaggeredNonlinearFEStateMap-Union{Tuple{SB}, Tuple{NB}, Tuple{GridapSolvers.BlockSolvers.StaggeredNonlinearFEOperator{NB, SB}, Any, Any}} where {NB, SB}","page":"StateMaps","title":"GridapTopOpt.StaggeredNonlinearFEStateMap","text":"function StaggeredNonlinearFEStateMap(\n  op                :: StaggeredNonlinearFEOperator{NB,SB},\n  V_φ,\n  φh;\n  assem_deriv       :: Assembler = SparseMatrixAssembler(V_φ,V_φ),\n  assems_adjoint    :: Vector{<:Assembler} = map(SparseMatrixAssembler,op.tests,op.trials),\n  solver            :: StaggeredFESolver{NB} = StaggeredFESolver(\n    fill(NewtonSolver(LUSolver();maxiter=50,rtol=1.e-8,verbose=true),length(op.residuals))),\n  adjoint_solver    :: StaggeredFESolver{NB} = StaggeredFESolver(fill(LUSolver(),length(op.residuals))),\n  adjoint_jacobians :: Vector{<:Function} = op.jacobians\n) where {NB,SB}\n\nCreate an instance of StaggeredNonlinearFEStateMap given a StaggeredNonlinearFEOperator op, the auxiliary space V_φ for φh and derivatives, and the parameter φh.\n\nOtional arguemnts:\n\nassem_deriv is the assembler for the derivative space.\nassems_adjoint is a vector of assemblers for the adjoint space.\nsolver is a StaggeredFESolver for the forward problem.\nadjoint_solver is a StaggeredFESolver for the adjoint problem.\nadjoint_jacobians is a vector of jacobians for the adjoint problem.\n\n\n\n\n\n","category":"method"},{"location":"reference/statemaps/#Advanced","page":"StateMaps","title":"Advanced","text":"","category":"section"},{"location":"reference/statemaps/#Inheriting-from-AbstractFEStateMap","page":"StateMaps","title":"Inheriting from AbstractFEStateMap","text":"","category":"section"},{"location":"reference/statemaps/#Existing-methods","page":"StateMaps","title":"Existing methods","text":"","category":"section"},{"location":"reference/statemaps/#ChainRulesCore.rrule-Tuple{GridapTopOpt.AbstractFEStateMap, Any}","page":"StateMaps","title":"ChainRulesCore.rrule","text":"rrule(φ_to_u::AbstractFEStateMap,φh)\n\nReturn the evaluation of a AbstractFEStateMap and a a function for evaluating the pullback of φ_to_u. This enables compatiblity with ChainRules.jl\n\n\n\n\n\n","category":"method"},{"location":"reference/statemaps/#GridapTopOpt.pullback","page":"StateMaps","title":"GridapTopOpt.pullback","text":"pullback(φ_to_u::AbstractFEStateMap,uh,φh,du;updated)\n\nCompute ∂F∂u*dudφ at φh and uh using the adjoint method. I.e., let\n\n∂F∂u*dudφ = -λᵀ*dRdφ\n\nand solve the adjoint problem dRduᵀ*λ = ∂F∂uᵀ using adjoint_solve!.\n\n\n\n\n\n","category":"function"},{"location":"reference/statemaps/#Required-to-implement","page":"StateMaps","title":"Required to implement","text":"","category":"section"},{"location":"reference/statemaps/#GridapTopOpt.forward_solve!","page":"StateMaps","title":"GridapTopOpt.forward_solve!","text":"forward_solve!(φ_to_u::AbstractFEStateMap,φh)\n\nEvaluate the forward problem u given φ. This should compute the FE problem.\n\n\n\n\n\n","category":"function"},{"location":"reference/statemaps/#GridapTopOpt.adjoint_solve!","page":"StateMaps","title":"GridapTopOpt.adjoint_solve!","text":"adjoint_solve!(φ_to_u::AbstractFEStateMap,du::AbstractVector)\n\nEvaluate the solution to the adjoint problem given a RHS vector ∂F∂u denoted du. This should solve the linear problem dRduᵀ*λ = ∂F∂uᵀ.\n\n\n\n\n\n","category":"function"},{"location":"reference/statemaps/#GridapTopOpt.update_adjoint_caches!","page":"StateMaps","title":"GridapTopOpt.update_adjoint_caches!","text":"update_adjoint_caches!(φ_to_u::AbstractFEStateMap,uh,φh)\n\nUpdate the cache for the adjoint problem. This is usually a tuple of objects.\n\n\n\n\n\n","category":"function"},{"location":"reference/statemaps/#GridapTopOpt.dRdφ","page":"StateMaps","title":"GridapTopOpt.dRdφ","text":"dRdφ(φ_to_u::AbstractFEStateMap,uh,vh,φh)\n\nCompute the derivative with respect to φh of the residual R.\n\n\n\n\n\n","category":"function"},{"location":"reference/statemaps/#GridapTopOpt.get_state-Tuple{GridapTopOpt.AbstractFEStateMap}","page":"StateMaps","title":"GridapTopOpt.get_state","text":"get_state(m::AbstractFEStateMap)\n\nReturn the solution/state u to the FE problem.\n\n\n\n\n\n","category":"method"},{"location":"reference/statemaps/#GridapTopOpt.get_spaces","page":"StateMaps","title":"GridapTopOpt.get_spaces","text":"get_spaces(m::AbstractFEStateMap)\n\nReturn a collection of FE spaces. The first four entires should correspond to get_trial_space, get_test_space, get_aux_space, and get_deriv_space unless these are overloaded for a particular implementation.\n\n\n\n\n\n","category":"function"},{"location":"reference/statemaps/#GridapTopOpt.get_assemblers","page":"StateMaps","title":"GridapTopOpt.get_assemblers","text":"get_assemblers(m::AbstractFEStateMap)\n\nReturn a collection of assemblers. The first two entires should correspond to get_pde_assembler and get_deriv_assembler unless these are overloaded for a particular implementation.\n\n\n\n\n\n","category":"function"},{"location":"reference/statemaps/#GridapTopOpt.get_trial_space","page":"StateMaps","title":"GridapTopOpt.get_trial_space","text":"get_trial_space(m::AbstractFEStateMap)\n\nReturn trial space for FE problem.\n\n\n\n\n\n","category":"function"},{"location":"reference/statemaps/#GridapTopOpt.get_test_space","page":"StateMaps","title":"GridapTopOpt.get_test_space","text":"get_test_space(m::AbstractFEStateMap)\n\nReturn test space for FE problem.\n\n\n\n\n\n","category":"function"},{"location":"reference/statemaps/#GridapTopOpt.get_aux_space","page":"StateMaps","title":"GridapTopOpt.get_aux_space","text":"get_aux_space(m::AbstractFEStateMap)\n\nReturn space for auxillary parameter.\n\n\n\n\n\n","category":"function"},{"location":"reference/statemaps/#GridapTopOpt.get_deriv_space","page":"StateMaps","title":"GridapTopOpt.get_deriv_space","text":"get_deriv_space(m::AbstractFEStateMap)\n\nReturn space for derivatives.\n\n\n\n\n\n","category":"function"},{"location":"reference/statemaps/#GridapTopOpt.get_pde_assembler","page":"StateMaps","title":"GridapTopOpt.get_pde_assembler","text":"get_pde_assembler(m::AbstractFEStateMap)\n\nReturn assembler for FE problem.\n\n\n\n\n\n","category":"function"},{"location":"reference/statemaps/#GridapTopOpt.get_deriv_assembler","page":"StateMaps","title":"GridapTopOpt.get_deriv_assembler","text":"get_deriv_assembler(m::AbstractFEStateMap)\n\nReturn assembler for derivatives.\n\n\n\n\n\n","category":"function"},{"location":"reference/statemaps/#Partial-derivatives","page":"StateMaps","title":"Partial derivatives","text":"","category":"section"},{"location":"reference/statemaps/#Gridap.Algebra.jacobian-Tuple{Any, Vector{<:Gridap.CellData.CellField}, Int64}","page":"StateMaps","title":"Gridap.Algebra.jacobian","text":"Gridap.jacobian(F,uh::Vector{<:CellField},K::Int)\n\nGiven a function F that returns a DomainContribution when called, and a vector of FEFunctions or CellField uh, evaluate the Jacobian F with respect to uh[K].\n\n\n\n\n\n","category":"method"},{"location":"reference/statemaps/#Gridap.Fields.gradient-Tuple{Any, Vector{<:Gridap.CellData.CellField}, Int64}","page":"StateMaps","title":"Gridap.Fields.gradient","text":"Gridap.gradient(F,uh::Vector{<:CellField},K::Int)\n\nGiven a function F that returns a DomainContribution when called, and a vector of FEFunctions uh, evaluate the partial derivative of F with respect to uh[K].\n\nExample\n\nSuppose uh and φh are FEFunctions with measures dΩ and dΓ_N. Then the partial derivative of a function J wrt to φh is computed via\n\nJ(u,φ) = ∫(f(u,φ))dΩ + ∫(g(u,φ))dΓ_N\n∂J∂φh = ∇(J,[uh,φh],2)\n\nwhere f and g are user defined.\n\n\n\n\n\n","category":"method"},{"location":"examples/Unfitted-TO-with-Laplace/#Topology-optimisation-on-unfitted-meshes","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"","category":"section"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"In this tutorial, we will learn:","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"How to formulate a Laplace's equation with CutFEM based on Burman et al. (2015)\nHow to use unfitted discretisations from GridapEmbedded in GridapTopOpt\nHow to use automatic (unfitted) shape differentation","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"This tutorial is for intermediate-level users. You should be familar with the GridapTopOpt framework before attempting this tutorial. In addition, it is recommended that this Gridap tutorial is read before attempting the below.","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/#Problem-formulation","page":"Topology optimisation on unfitted meshes","title":"Problem formulation","text":"","category":"section"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"The goal of this tutorial is to solve a level-set topology optimisation problem with an unfitted discretisation and automatic shape differentiation. To simplify this tutorial, we consider Laplace's equation for the underlying PDE. Specifically, the PDE-constrained optimisation problem that we consider is","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"beginaligned\n    min_Omegasubset DJ(Omega)coloneqqint_Omega(phi)boldsymbolnablaucdotboldsymbolnablaumathrmdboldsymbolx\n    textst C(Omega)=0\n    leftlbracebeginaligned\n    -boldsymbolnabla^2u = 0textin Omega\nboldsymbolnabla ucdotboldsymboln = 1texton Gamma_N\nboldsymbolnabla ucdotboldsymboln = 0texton Gamma\nu = 0texton overlineOmega_D\n    endalignedright\nendaligned","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"where C(Omega)=(operatornameVol(Omega) - 03)operatornameVol(D) constrains the volume of Omega. The background domain D and boundary conditions are shown below:","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"<p align=\"center\">\n<img src=\"../Unfitted-TO-with-Laplace.png\" width=\"300\">\n</p>","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/#Unfitted-formulation","page":"Topology optimisation on unfitted meshes","title":"Unfitted formulation","text":"","category":"section"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"In the following, we discretise the PDE governing u using CutFEM based on Burman et al. (2015). The weak formulation for this problem is: for V=H^1(Omegau_Gamma_D=0), find uin V such that","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"int_Omega(phi)boldsymbolnablaucdotboldsymbolnablavmathrmdboldsymbolx + j(uv) + i(uv) = int_Gamma_Nvmathrmdsforall vin V","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"Those who are familiar with deriving the weak form will notice that we have two addition terms in this formulation. The first is the so-called ghost penalty term j(uv) that extends coercivity of the bilinear form from the physical domain to the cut domain. This is given by","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"j(uv)=int_Gamma_ggamma h llbracket boldsymbolncdotboldsymbolnablaurrbracketllbracket boldsymbolncdotboldsymbolnablavrrbracketmathrmds","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"The second term i(uv) enforces zero temperature within an isolated volumes marked by chi. We can think of these isolated volumes as blobs of material that are not sufficently constrained. As a result, without an additional constraint on these \"blobs\", an unfitted discretisation will yield infinite solutions. This term is given by","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"i(uv) = int_Omega(phi)chi uvmathrmdboldsymbolx","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"Note that this only acts on the isolated volumes marked by chi. As a result, the problem is still consistent.","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/#Setup-and-parameters","page":"Topology optimisation on unfitted meshes","title":"Setup and parameters","text":"","category":"section"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"As usual, we start by loading the required libraries and defining any parameters:","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"using Gridap, Gridap.Adaptivity, Gridap.Geometry\nusing GridapEmbedded, GridapEmbedded.LevelSetCutters\nusing GridapTopOpt, GridapSolvers\n\nusing GridapTopOpt: StateParamMap\n\npath=\"./results/Unfitted_Thermal2D/\"\nmkpath(path)\n# Params\nn = 50            # Initial mesh size (pre-refinement)\nmax_steps = n/5   # Time-steps for evolution equation\nvf = 0.3          # Volume fraction\nα_coeff = 2       # Regularisation coefficient extension-regularisation\niter_mod = 10     # Write output every iter_mod iterations","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"Here, we deictate that the initial mesh size is 50^2 quadrilateral elements, the time steps for the evolution equation is set to n5, the required volume fraction is 0.3, the reguarisation coefficent for the Hilbertian extension-regularisation is 2, and we data files at each iteration.","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/#Mesh-with-refinement","page":"Topology optimisation on unfitted meshes","title":"Mesh with refinement","text":"","category":"section"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"For this problem, we use a refined mesh using Gridap's adaptivity features. In addition, we mark mesh entities that are part of overlineOmega_D and Gamma_N:","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"# Base model\n_model = CartesianDiscreteModel((0,1,0,1),(n,n))\nbase_model = UnstructuredDiscreteModel(_model)\n# Refinement\nref_model = refine(base_model, refinement_method = \"barycentric\")\nref_model = refine(ref_model)\nref_model = refine(ref_model)\nmodel = ref_model.model\n# Get mesh size\nh = minimum(get_element_diameters(model))\nhₕ = get_element_diameter_field(model)\n# Mark mesh entities\nf_Γ_D(x) = (x[1]-0.5)^2 + (x[2]-0.5)^2 <= 0.05^2\nf_Γ_N(x) = ((x[1] ≈ 0 || x[1] ≈ 1) && (0.2 <= x[2] <= 0.3 + eps() || 0.7 - eps() <= x[2] <= 0.8)) ||\n  ((x[2] ≈ 0 || x[2] ≈ 1) && (0.2 <= x[1] <= 0.3 + eps() || 0.7 - eps() <= x[1] <= 0.8))\nupdate_labels!(1,model,f_Γ_D,\"Omega_D\")\nupdate_labels!(2,model,f_Γ_N,\"Gamma_N\")\nwritevtk(model,path*\"model\")","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"warning: Warning\nNon-TET/TRI polytopes are simplexified by GridapEmbedded when cutting. As a result, derivative information from AD will not be correct when using a mesh that isn't made of TRI/TET. Please use a mesh with TRI/TET polytopes to ensure correctness of derivative results.","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/#FESpace-for-level-set-function-and-derivatives","page":"Topology optimisation on unfitted meshes","title":"FESpace for level-set function and derivatives","text":"","category":"section"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"In example, we consider piecewise linear cuts defined via a level-set function. As such, the level-set function should be discretised using continuous piecewise-linear finite elements. In addition, we use the same space for the derivatives, except we also constrain the derivative space so that the shape derivatives are zero on overlineOmega_D and Gamma_N.","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"reffe_scalar = ReferenceFE(lagrangian,Float64,1)\nV_φ = TestFESpace(model,reffe_scalar)\nV_reg = TestFESpace(model,reffe_scalar;dirichlet_tags=[\"Omega_D\",\"Gamma_N\"])\nU_reg = TrialFESpace(V_reg)","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"Next, we build the initial level-set function using","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"f1 = (x,y) -> -cos(6π*(x-1/12))*cos(6π*(y-1/12))-0.5\nf2 = (x,y) -> -cos(6π*(x-3/12))*cos(6π*(y-1/12))-0.5\nf3 = (x,y) -> (x-0.5)^2 + (y-0.5)^2 - 0.06^2\nf((x,y)) = min(max(f1(x,y),f2(x,y)),f3(x,y))\nφh = interpolate(f,V_φ)","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"Before defining the triangulation, we need to ensure that the initial cut interface defined by the level-set function does not intersect the vertices in the background domain. We do this using:","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"GridapTopOpt.correct_ls!(φh)","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/#Background-triangulations-and-measures","page":"Topology optimisation on unfitted meshes","title":"Background triangulations and measures","text":"","category":"section"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"Next we define the measures for the background domain as usual","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"Ω_bg = Triangulation(model)\nΓ_N = BoundaryTriangulation(model,tags=\"Gamma_N\")\ndΩ_bg = Measure(Ω_bg,2)\ndΓ_N = Measure(Γ_N,2)\nvol_D = sum(∫(1)dΩ_bg)","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/#Embedded-triangulations-and-measures","page":"Topology optimisation on unfitted meshes","title":"Embedded triangulations and measures","text":"","category":"section"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"To make it possible to update the embedded triangulations, measures, and the indicator function we use an EmbeddedCollection. This is given by","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"Ωs = EmbeddedCollection(model,φh) do cutgeo,cutgeo_facets,_φh\n  Ωin = DifferentiableTriangulation(Triangulation(cutgeo,PHYSICAL),V_φ)\n  Γ = DifferentiableTriangulation(EmbeddedBoundary(cutgeo),V_φ)\n  Γg = GhostSkeleton(cutgeo)\n  Ωact = Triangulation(cutgeo,ACTIVE)\n  φ_cell_values = get_cell_dof_values(_φh)\n  χ,_ = get_isolated_volumes_mask_polytopal(model,φ_cell_values,[\"Omega_D\",])\n  (;\n    :Ωin  => Ωin,\n    :dΩin => Measure(Ωin,2),\n    :Γg   => Γg,\n    :dΓg  => Measure(Γg,2),\n    :n_Γg => get_normal_vector(Γg),\n    :Γ    => Γ,\n    :dΓ   => Measure(Γ,2),\n    :n_Γ  => get_normal_vector(Γ),\n    :Ωact => Ωact,\n    :χ => χ\n  )\nend","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"The do statement above provides a recipe for the EmbeddedCollection to generate the data in Ωs that can be accessed, for example, via Ωs.Ωin. The contents of Ωs can then be updated via update_collection!(c::EmbeddedCollection,φh). In addition, new recipes can be added using add_recipe!(c::EmbeddedCollection,r::Function[,φh]). Inside EmbeddedCollection, cut geometries are created and then passed to recipes when update_collection! is called.","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/#Isolated-volume-marking-and-automatic-differentation","page":"Topology optimisation on unfitted meshes","title":"Isolated volume marking and automatic differentation","text":"","category":"section"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"In the above, we use get_isolated_volumes_mask_polytopal to create a cell field that marks cells based on whether they are connected to Omega_D. In addition, we wrap the cut triangulations inside DifferentiableTriangulation. This is a wrapper around an embedded triangulation (i.e SubCellTriangulation or SubFacetTriangulation) implementing all the necessary methods to compute derivatives with respect to deformations of the embedded mesh. To do so, it propagates dual numbers into the geometric maps mapping cut subcells/subfacets to the background mesh. We refer to this article for the mathematical discussion:","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"Wegert, Z.J., Manyer, J., Mallon, C.N. et al. Level-set topology optimisation with unfitted finite elements and automatic shape differentiation. Comput Methods Appl Mech Engrg 445 (2025). https://doi.org/10.1016/j.cma.2025.118203","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/#FE-problem","page":"Topology optimisation on unfitted meshes","title":"FE problem","text":"","category":"section"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"Now that all the measures are defined, lets define the weak form, optimisation functionals, and the FE operators. First, we can define the weak form and optimisation functionals as","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"γg = 0.1\na(u,v,φ) = ∫(∇(v)⋅∇(u))Ωs.dΩin +\n           ∫((γg*mean(hₕ))*jump(Ωs.n_Γg⋅∇(v))*jump(Ωs.n_Γg⋅∇(u)))Ωs.dΓg +\n           ∫(Ωs.χ*v*u)Ωs.dΩin\nl(v,φ) = ∫(v)dΓ_N","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"and","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"J(u,φ) = ∫(∇(u)⋅∇(u))Ωs.dΩin\nVol(u,φ) = ∫(1/vol_D)Ωs.dΩin - ∫(vf/vol_D)dΩ_bg\ndVol(q,u,φ) = ∫(-1/vol_D*q/(abs(Ωs.n_Γ ⋅ ∇(φ))))Ωs.dΓ","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"We have directly computed the shape derivative of the volume functional using the analytical results by Wegert et al. (2025) referenced above.","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"Next, we setup the AffineFEStateMap and PDEConstrainedFunctionals objects. Here we use another new objective EmbeddedCollection_in_φh that is similar to EmbeddedCollection except it does not cut the mesh and only expects recipes that take arguments in φh. This allows us to update the spaces and state maps whenever required. Note that this is different to how we usually setup these objects because we have to recreate the FE spaces and state maps at each iteration. This is because the active mesh for the unfitted discretisation is changing over the course of the level-set evolution. This new state_collection holds the state map, the objective as a StateParamMap, and set of StateParamMap for the constraints. This is given by the follow snippet","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"state_collection = EmbeddedCollection_in_φh(model,φh) do _φh\n  update_collection!(Ωs,_φh)\n  V = TestFESpace(Ωs.Ωact,reffe_scalar;dirichlet_tags=[\"Omega_D\"])\n  U = TrialFESpace(V,0.0)\n  state_map = AffineFEStateMap(a,l,U,V,V_φ,U_reg)\n  (;\n    :state_map => state_map,\n    :J => StateParamMap(J,state_map),\n    :C => map(Ci -> StateParamMap(Ci,state_map),[Vol,])\n  )\nend","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"Note that StateParamMap is a wrapper to handle partial differentation of a function in a ChainRules.jl compatible way with caching. See this documentation for further information.","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"Next, we create the EmbeddedPDEConstrainedFunctionals. This is similar to PDEConstrainedFunctionals except it takes state_collection as the argument and updates the unfitted triangulations where appropriate.","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"pcfs = EmbeddedPDEConstrainedFunctionals(state_collection;analytic_dC=(dVol,))","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/#Evolution","page":"Topology optimisation on unfitted meshes","title":"Evolution","text":"","category":"section"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"We now define the evolution and reinitialisation methods for this problem. Here we use unfitted approaches to solve both of these problems","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"To set these up, we provide CutFEMEvolver and StabilisedReinitialiser as follows:","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"evo = CutFEMEvolver(V_φ,Ωs,dΩ_bg,hₕ;max_steps,γg=0.1)\nreinit = StabilisedReinitialiser(V_φ,Ωs,dΩ_bg,hₕ;stabilisation_method=ArtificialViscosity(2.0))","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"We then define the LevelSetEvolution object that wraps these methods, and we reinitialise our initial level-set function via","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"ls_evo = LevelSetEvolution(evo,reinit)\nreinit!(ls_evo,φh)","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/#Hilbertian-extension-regularisation-problems","page":"Topology optimisation on unfitted meshes","title":"Hilbertian extension-regularisation problems","text":"","category":"section"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"The Hilbertian extension-regularisation approach projects a directional derivative mathrmdJ(phiw) of a functional J(phi) onto a Hilbert space H on D, typically with additional regularity. This involves solving an identification problem: for Find g_Omegain H such that","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"langle g_Omegawrangle_H=-mathrmdJ(phiw)forall win H","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"where langlecdotcdotrangle_H is the inner product on H. Here, we use H=H^1_Omega_DcupGamma_N(D) with the inner product","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"    langle uvrangle_H=int_Dleft(alpha^2boldsymbolnabla ucdotboldsymbolnabla v+uvright)mathrmdboldsymbolx","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"This is implemented as follows:","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"α = (α_coeff)^2*hₕ*hₕ\na_hilb(p,q) =∫(α*∇(p)⋅∇(q) + p*q)dΩ_bg;\nvel_ext = VelocityExtension(a_hilb,U_reg,V_reg)","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/#Optimiser-and-solution","page":"Topology optimisation on unfitted meshes","title":"Optimiser and solution","text":"","category":"section"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"Finally, for the optimiser we use the AugmentedLagrangian method with the convergence criteria below. In addition, we output data on the background mesh, along with the solution u_h on the unfitted triangulation. This is given by the following:","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"converged(m) = GridapTopOpt.default_al_converged(\n  m;\n  L_tol = 0.01*h,\n  C_tol = 0.01\n)\noptimiser = AugmentedLagrangian(pcfs,ls_evo,vel_ext,φh;verbose=true,constraint_names=[:Vol],converged)\nfor (it,uh,φh) in optimiser\n  if iszero(it % iter_mod)\n    writevtk(Ω_bg,path*\"Omega$it\",cellfields=[\"φ\"=>φh,\"|∇(φ)|\"=>(norm ∘ ∇(φh)),\"uh\"=>uh,\"χ\"=>Ωs.χ])\n    writevtk(Ωs.Ωin,path*\"Omega_in$it\",cellfields=[\"uh\"=>uh])\n  end\n  write_history(path*\"/history.txt\",optimiser.history)\nend\nit = get_history(optimiser).niter; uh = get_state(pcfs)\nwritevtk(Ω_bg,path*\"Omega$it\",cellfields=[\"φ\"=>φh,\"|∇(φ)|\"=>(norm ∘ ∇(φh)),\"uh\"=>uh,\"χ\"=>Ωs.χ])\nwritevtk(Ωs.Ωin,path*\"Omega_in$it\",cellfields=[\"uh\"=>uh])","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"Solving this problem results in the following iteration history:","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"<p align=\"center\">\n<img src=\"../Unfitted-TO-with-Laplace-result.gif\" width=\"300\">\n</p>","category":"page"},{"location":"examples/Unfitted-TO-with-Laplace/","page":"Topology optimisation on unfitted meshes","title":"Topology optimisation on unfitted meshes","text":"The full script for this problem can be found in scripts/Examples/Unfitted/Thermal2D_CutFEM.jl.","category":"page"},{"location":"reference/levelsetevolution/#LevelSetEvolution","page":"LevelSetEvolution","title":"LevelSetEvolution","text":"","category":"section"},{"location":"reference/levelsetevolution/","page":"LevelSetEvolution","title":"LevelSetEvolution","text":"In GridapTopOpt, the a level-set function is evolved and reinitialised as a signed distance function using an Evolver and Reinitialiser implementations, respectively. These are wrapped in an object LevelSetEvolution for the purpose of optimisation.","category":"page"},{"location":"reference/levelsetevolution/","page":"LevelSetEvolution","title":"LevelSetEvolution","text":"List of Evolver types:","category":"page"},{"location":"reference/levelsetevolution/","page":"LevelSetEvolution","title":"LevelSetEvolution","text":"Method Ambient mesh type Cached Preferred Method\nFiniteDifferenceEvolver Cartesian ✓ \nCutFEMEvolver Unstructured ✗* ☆","category":"page"},{"location":"reference/levelsetevolution/","page":"LevelSetEvolution","title":"LevelSetEvolution","text":"*: Caching is disabled due to a bug. This is will be improved in future.","category":"page"},{"location":"reference/levelsetevolution/","page":"LevelSetEvolution","title":"LevelSetEvolution","text":"List of Reinitialiser types:","category":"page"},{"location":"reference/levelsetevolution/","page":"LevelSetEvolution","title":"LevelSetEvolution","text":"Method Ambient mesh type Cached Differentiable Preferred Method\nFiniteDifferenceReinitialiser Cartesian ✓ ✗ \nStabilisedReinitialiser Unstructured ✓ ✗ \nHeatReinitialiser Unstructured ✓ ✓ ☆","category":"page"},{"location":"reference/levelsetevolution/","page":"LevelSetEvolution","title":"LevelSetEvolution","text":"note: Note\nThe finite difference methods are based on the upwinding scheme of Osher and Fedkiw (link). These are extremely efficient as they require no linear solves. They are, however, currently restricted to meshes built from CartesianDiscreteModel. Note as well that the FiniteDifferenceReinitialiser is can result in slight movement of the zero isosurface.","category":"page"},{"location":"reference/levelsetevolution/#LevelSetEvolution-2","page":"LevelSetEvolution","title":"LevelSetEvolution","text":"","category":"section"},{"location":"reference/levelsetevolution/#GridapTopOpt.LevelSetEvolution","page":"LevelSetEvolution","title":"GridapTopOpt.LevelSetEvolution","text":"struct LevelSetEvolution{A,B} <: AbstractLevelSetEvolution\n\nA wrapper to hold a level-set evolver and reinitialiser.\n\n\n\n\n\n","category":"type"},{"location":"reference/levelsetevolution/#GridapTopOpt.evolve!-Tuple{LevelSetEvolution, Any, Vararg{Any}}","page":"LevelSetEvolution","title":"GridapTopOpt.evolve!","text":"evolve!(s::LevelSetEvolution,φ,args...)\n\nEvolve the level set function φ using the evolver in LevelSetEvolution.\n\n\n\n\n\n","category":"method"},{"location":"reference/levelsetevolution/#GridapTopOpt.get_evolver-Tuple{LevelSetEvolution}","page":"LevelSetEvolution","title":"GridapTopOpt.get_evolver","text":"get_evolver(s::LevelSetEvolution)\n\nReturn the level-set function evolver.\n\n\n\n\n\n","category":"method"},{"location":"reference/levelsetevolution/#GridapTopOpt.get_ls_space-Tuple{LevelSetEvolution}","page":"LevelSetEvolution","title":"GridapTopOpt.get_ls_space","text":"get_ls_space(s::LevelSetEvolution)\n\nReturn the finite element space used for the level-set function.\n\n\n\n\n\n","category":"method"},{"location":"reference/levelsetevolution/#GridapTopOpt.get_min_dof_spacing-Tuple{LevelSetEvolution}","page":"LevelSetEvolution","title":"GridapTopOpt.get_min_dof_spacing","text":"get_min_dof_spacing(s::LevelSetEvolution)\n\nReturn the minimum spacing of DOFs for the level-set function.\n\n\n\n\n\n","category":"method"},{"location":"reference/levelsetevolution/#GridapTopOpt.get_reinitialiser-Tuple{LevelSetEvolution}","page":"LevelSetEvolution","title":"GridapTopOpt.get_reinitialiser","text":"reinitialiser(s::LevelSetEvolution)\n\nReturn the level-set function reinitialiser.\n\n\n\n\n\n","category":"method"},{"location":"reference/levelsetevolution/#GridapTopOpt.reinit!-Tuple{LevelSetEvolution, Any, Vararg{Any}}","page":"LevelSetEvolution","title":"GridapTopOpt.reinit!","text":"reinit!(::LevelSetEvolution,φ,args...)\n\nReinitialise the level set function φ using the reinitialiser in LevelSetEvolution.\n\n\n\n\n\n","category":"method"},{"location":"reference/levelsetevolution/#Level-Set-Evolvers","page":"LevelSetEvolution","title":"Level-Set Evolvers","text":"","category":"section"},{"location":"reference/levelsetevolution/#FiniteDifferenceEvolver","page":"LevelSetEvolution","title":"FiniteDifferenceEvolver","text":"","category":"section"},{"location":"reference/levelsetevolution/#GridapTopOpt.FiniteDifferenceEvolver","page":"LevelSetEvolution","title":"GridapTopOpt.FiniteDifferenceEvolver","text":"struct FiniteDifferenceEvolver{O}\n\nA standard forward Euler in time finite difference method for solving the Hamilton-Jacobi evolution equation on order O finite elements in serial or parallel.\n\nBased on the scheme by Osher and Fedkiw (link).\n\nHamilton-Jacobi evolution equation\n\nfracpartialphipartial t + V(boldsymbolx)lVertboldsymbolnablaphirVert = 0\n\nwith phi(0boldsymbolx)=phi_0(boldsymbolx) and boldsymbolxin Dtin(0T).\n\nParameters\n\nstencil::Stencil: Spatial finite difference stencil for a single step HJ equation and reinitialisation equation.\nmodel: A CartesianDiscreteModel.\nspace: FE space for level-set function\nperm: A permutation vector\nparams: Tuple of additional params\n\n\n\n\n\n","category":"type"},{"location":"reference/levelsetevolution/#GridapTopOpt.FiniteDifferenceEvolver-Tuple{GridapTopOpt.Stencil, Any, Any}","page":"LevelSetEvolution","title":"GridapTopOpt.FiniteDifferenceEvolver","text":"FiniteDifferenceEvolver(stencil::Stencil,model,space,max_steps)\n\nCreate an instance of FiniteDifferenceEvolver given a stencil, model, FE space, and additional optional arguments. This automatically creates the DoF permutation to handle high-order finite elements.\n\nOptional Arguments\n\nmax_steps: number of timesteps\ncorrect_ls: Boolean for whether or not to ensure LS DOFs aren't zero this MUST be true for differentiation in unfitted methods.\n\n\n\n\n\n","category":"method"},{"location":"reference/levelsetevolution/#GridapTopOpt.FirstOrderStencil","page":"LevelSetEvolution","title":"GridapTopOpt.FirstOrderStencil","text":"struct FirstOrderStencil{D,T} <: Stencil end\n\nA first order upwind difference scheme based on Osher and Fedkiw (link).\n\n\n\n\n\n","category":"type"},{"location":"reference/levelsetevolution/#CutFEMEvolver","page":"LevelSetEvolution","title":"CutFEMEvolver","text":"","category":"section"},{"location":"reference/levelsetevolution/#GridapTopOpt.CutFEMEvolver","page":"LevelSetEvolution","title":"GridapTopOpt.CutFEMEvolver","text":"mutable struct CutFEMEvolver{V,M} <: Evolver\n\nCutFEM method for level-set evolution based on method developed by\n\nBurman et al. (2018). DOI: 10.1016/j.cma.2017.09.005.\nBurman et al. (2017). DOI: 10.1016/j.cma.2016.12.021.\nBurman and Fernández (2009). DOI: 10.1016/j.cma.2009.02.011\n\nThis solves the tranport equation fracpartialphi(toldsymbolx)partial t+boldsymbolbetacdotboldsymbolnablaphi(tboldsymbolx)=0 with boldsymbolbeta=boldsymbolnv_h, phi(0boldsymbolx)=phi_0(boldsymbolx) and quadboldsymbolxin Dtin(0T).\n\nParameters\n\node_solver::ODESolver: ODE solver\nΩs::B: EmbeddedCollection holding updatable triangulation and measures from GridapEmbedded\ndΩ_bg::C: Measure for integration\nspace::B: Level-set FE space\nassembler::Assembler: FE assembler\nparams::D: Tuple of stabilisation parameter γg, mesh sizes h, and max steps max_steps, and background mesh skeleton parameters\n\nwarning: Warning\nCaching for the CutFEMEvolver method is currently disabled. This will be re-enabled in the future.\"\n\n\n\n\n\n","category":"type"},{"location":"reference/levelsetevolution/#GridapTopOpt.CutFEMEvolver-Union{Tuple{B}, Tuple{A}, Tuple{B, EmbeddedCollection, A, Any}} where {A, B}","page":"LevelSetEvolution","title":"GridapTopOpt.CutFEMEvolver","text":"CutFEMEvolver(V_φ::B,Ωs::EmbeddedCollection,dΩ_bg::A,h;\n  max_steps=10,\n  γg = 0.1,\n  ode_ls = LUSolver(),\n  ode_nl = ode_ls,\n  ode_solver = MutableRungeKutta(ode_nl, ode_ls, 0.1, :DIRK_CrankNicolson_2_2),\n  assembler=SparseMatrixAssembler(V_φ,V_φ)\n) where {A,B}\n\nCreate an instance of CutFEMEvolver with the space for the level-set V_φ, the EmbeddedCollection Ωs for the triangulation and measures, the measure dΩ_bg for the background mesh, and the mesh size h. The mesh size h can either be a scalar or a CellField object.\n\nThe optional arguments are:\n\ncorrect_ls: Boolean for whether or not to ensure LS DOFs aren't zero this MUST be true for differentiation in unfitted methods.\nmax_steps: Maximum number of steps for the ODE solver.\nγg: Stabilisation parameter for the continuous interior penalty term.\node_ls: Linear solver for the ODE solver.\node_nl: Non-linear solver for the ODE solver.\node_solver: ODE solver, default is MutableRungeKutta(ode_nl, ode_ls, 0.1, :DIRK_CrankNicolson_2_2).\nassembler: Assembler for the finite element space, default is SparseMatrixAssembler(V_φ,V_φ).\n\nNote\n\nThe stepsize dt = 0.1 in MutableRungeKutta is a place-holder and is updated using the γ passed to evolve!.\n\n\n\n\n\n","category":"method"},{"location":"reference/levelsetevolution/#Level-Set-Reinitialisers","page":"LevelSetEvolution","title":"Level-Set Reinitialisers","text":"","category":"section"},{"location":"reference/levelsetevolution/#FiniteDifferenceReinitialiser","page":"LevelSetEvolution","title":"FiniteDifferenceReinitialiser","text":"","category":"section"},{"location":"reference/levelsetevolution/#GridapTopOpt.FiniteDifferenceReinitialiser","page":"LevelSetEvolution","title":"GridapTopOpt.FiniteDifferenceReinitialiser","text":"struct FiniteDifferenceReinitialiser{O}\n\nA standard forward Euler in time finite difference method for solving the reinitialisation equation on order O finite elements in serial or parallel.\n\nBased on the scheme by Osher and Fedkiw (link).\n\nReinitialisation equation\n\nfracpartialphipartial t + mathrmsign(phi_0)(lVertboldsymbolnablaphirVert-1) = 0\n\nwith phi(0boldsymbolx)=phi_0(boldsymbolx) and boldsymbolxin Dtin(0T).\n\nParameters\n\nstencil::Stencil: Spatial finite difference stencil for a single step HJ equation and reinitialisation equation.\nmodel: A CartesianDiscreteModel.\nspace: FE space for level-set function\nperm: A permutation vector\nparams: Tuple of additional params\n\n\n\n\n\n","category":"type"},{"location":"reference/levelsetevolution/#GridapTopOpt.FiniteDifferenceReinitialiser-Tuple{GridapTopOpt.Stencil, Any, Any}","page":"LevelSetEvolution","title":"GridapTopOpt.FiniteDifferenceReinitialiser","text":"FiniteDifferenceReinitialiser(stencil::Stencil,model,space;γ_reinit,tol,max_steps)\n\nCreate an instance of FiniteDifferenceReinitialiser given a stencil, model, FE space, and additional optional arguments. This automatically creates the DoF permutation to handle high-order finite elements.\n\nOptional Arguments\n\nγ_reinit: coeffient on the time step size.\ntol: stopping tolerance for reinitialiser\nmax_steps: number of timesteps\ncorrect_ls: Boolean for whether or not to ensure LS DOFs aren't zero this MUST be true for differentiation in unfitted methods.\n\n\n\n\n\n","category":"method"},{"location":"reference/levelsetevolution/#StabilisedReinitialiser","page":"LevelSetEvolution","title":"StabilisedReinitialiser","text":"","category":"section"},{"location":"reference/levelsetevolution/#GridapTopOpt.StabilisedReinitialiser","page":"LevelSetEvolution","title":"GridapTopOpt.StabilisedReinitialiser","text":"struct StabilisedReinitialiser{V,M} <: Reinitialiser\n\nStabilised FE method for level-set reinitialisation. Artificial viscosity approach (ArtificialViscosity) based on Mallon et al. (2023). DOI: 10.1016/j.cma.2025.118203. Interior jump penalty approach (InteriorPenalty) adapted from that work and replaces the artifical viscosity term with an interior jump penalty term.\n\nParameters\n\nnls::NonlinearSolver: Nonlinear solver for solving the reinitialisation equation\nstabilisation_method::A: A StabilisationMethod method for stabilising the problem\nΩs::B: EmbeddedCollection holding updatable triangulation and measures from GridapEmbedded\ndΩ_bg::D: Background mesh measure\nspace::C: FE space for level-set function\nassembler::Assembler: Assembler for LS FE space\nparams::E: Tuple of Nitsche parameter γd and mesh size h\n\nNote\n\nWe expect the EmbeddedCollection Ωs to contain :dΓ. If this is not available we add it to the recipe list in Ωs and a warning will appear.\n\n\n\n\n\n","category":"type"},{"location":"reference/levelsetevolution/#GridapTopOpt.StabilisedReinitialiser-Union{Tuple{C}, Tuple{B}, Tuple{A}, Tuple{C, EmbeddedCollection, B, Any}} where {A, B, C}","page":"LevelSetEvolution","title":"GridapTopOpt.StabilisedReinitialiser","text":"StabilisedReinitialiser(V_φ::C,Ωs::EmbeddedCollection,dΩ_bg::B,h;\n  γd = 20.0,\n  nls = NewtonSolver(LUSolver();maxiter=20,rtol=1.e-14,verbose=true),\n  assembler=SparseMatrixAssembler(V_φ,V_φ),\n  stabilisation_method::A = InteriorPenalty(V_φ)\n) where {A,B,C}\n\nCreate an instance of StabilisedReinitialiser with the space for the level-set V_φ, the EmbeddedCollection Ωs for the triangulation and measures, the measure dΩ_bg for the background mesh, and the mesh size h. The mesh size h can either be a scalar or a CellField object.\n\nThe optional arguments are:\n\ncorrect_ls: Boolean for whether or not to ensure LS DOFs aren't zero this MUST be true for differentiation in unfitted methods.\nγd: Interface penalty parameter for the reinitialisation equation.\nnls: Nonlinear solver for solving the reinitialisation equation.\nassembler: Assembler for the finite element space.\nstabilisation_method: A StabilisationMethod method for stabilising the problem.\n\n\n\n\n\n","category":"method"},{"location":"reference/levelsetevolution/#HeatReinitialiser","page":"LevelSetEvolution","title":"HeatReinitialiser","text":"","category":"section"},{"location":"reference/levelsetevolution/#GridapTopOpt.HeatReinitialiser","page":"LevelSetEvolution","title":"GridapTopOpt.HeatReinitialiser","text":"struct HeatReinitialiser <: Reinitialiser end\n\nA heat method for reinitialisation of the level-set function as an approximate signed distance function. This is based on Feng and Crane (2024) [doi: 10.1145/3658220].\n\nThis works using in three steps:\n\nStep 1: Solve (I - tΔ)X = {Γ_n on Γ, 0 otherwise} for small t on M\nStep 2: Get Y = X/|X| (L2 projection to ensure we have an FEFunction)\nStep 3: Solve ΔΦ = ∇ ⋅ Y on M with n ⋅ ∇Φ = ∂M_n ⋅ Y on ∂M.\n\nThe resulting Φ is an approximation of the signed distance function. In the above M is our background domain and Γ is the interface defined by the zero isosurface of the level-set function.\n\nNote, in Step 3 we add a penalty term to ensure that the resulting isosurface Φ=0 lies close to φ=0. This results in a multifield tangent space for yφtosdf.\n\nThe implementation is in terms of AffineFEStateMaps to enable AD through the maps using Zygote. The differentiable map φ_to_sdf can be obtained using the function get_lsf_to_sdf_map.\n\nParameters\n\nφ_to_x: AffineFEStateMap mapping from φ to the vector field x (Step 1)\nx_to_y: AffineFEStateMap mapping from the vector field x to the vector field y (Step 2)\nyφ_to_sdf: AffineFEStateMap mapping from the vector field y and φ to the sdf (Step 3)\nΩs: An EmbeddedCollection for holding information regarding the geometry.\n\n\n\n\n\n","category":"type"},{"location":"reference/levelsetevolution/#GridapTopOpt.HeatReinitialiser-Tuple{Any, Any}","page":"LevelSetEvolution","title":"GridapTopOpt.HeatReinitialiser","text":"HeatReinitialiser(V_φ,model;\n  t  = minimum(get_element_diameters(model))^2,\n  γd = 10.0,\n  boundary_tags = \"boundary\",\n  V_xy = build_V_xy(model,V_φ),\n  M_xyφ = MultiFieldFESpace([Vxy,V_φ]),\n  V_sdf = build_V_sdf(model,V_φ),\n  Ωs = build_Ωs(model,boundary_tags,V_φ)\n)\n\nCreate an instance of HeatReinitialiser.\n\nOptional parameters:\n\nt: Time step for the heat equation, default is the square of the minimum element diameter.\nγd: Penalty parameter to preserve level sets, default is 10.\nboundary_tags: Tag/s for the boundary, default is \"boundary\" (e.g., for CartesianDiscreteModel). For your own mesh (e.g., unstructured) covering M, you should provide the tags that consistute ∂M.\n\nAdvanced optional parameters:\n\nV_xy: TestFESpace for the vector field x, default is built using build_V_xy.\nM_xyφ: MultiFieldFESpace for the vector field x and φ, default is built using MultiFieldFESpace([V_xy,V_φ]). This is used in the third step to solve for the signed distance function.\nV_sdf: TestFESpace for the signed distance function, default is built using build_V_sdf.\nΩs: An EmbeddedCollection for holding information regarding the geometry, default is built using build_Ωs\nφ_to_x_ls: Solver for the φtox map, default is LUSolver().\nx_to_y_ls: Solver for the xtoy map, default is LUSolver().\nyφ_to_sdf_ls: Solver for the yφtosdf map, default is LUSolver().\nφ_to_x_adjoint_ls: Adjoint solver for the φtox map, default is φ_to_x_ls.\nx_to_y_adjoint_ls: Adjoint solver for the xtoy map, default is x_to_y_ls.\nyφ_to_sdf_adjoint_ls: Adjoint solver for the yφtosdf map, default is yφ_to_sdf_ls.\n\nnote: Note\nWhen using an unstructured mesh with significant changes in mesh sizes, you should consider testing different values of t, e.g., minimum, maximum, or mean element diameter. It is also possible to set t to be the square of the element size field from get_element_diameter_field: E.g.,hsq(h) = h^2\nt = hsq ∘ get_element_diameter_field(model)We have found that the latter yields better results for some problems.\n\n\n\n\n\n","category":"method"},{"location":"reference/levelsetevolution/#IdentityReinitialiser","page":"LevelSetEvolution","title":"IdentityReinitialiser","text":"","category":"section"},{"location":"reference/levelsetevolution/#GridapTopOpt.IdentityReinitialiser","page":"LevelSetEvolution","title":"GridapTopOpt.IdentityReinitialiser","text":"struct IdentityReinitialiser <: Reinitialiser end\n\nA level-set function reinitialiser that does nothing.\n\n\n\n\n\n","category":"type"},{"location":"reference/levelsetevolution/#Your-own-custom-Evolver","page":"LevelSetEvolution","title":"Your own custom Evolver","text":"","category":"section"},{"location":"reference/levelsetevolution/#GridapTopOpt.Evolver","page":"LevelSetEvolution","title":"GridapTopOpt.Evolver","text":"abstract type Evolver\n\nYour own level-set evolution method can be created by implementing concrete functionality for solve!, get_dof_spacing, and get_ls_space.\n\n\n\n\n\n","category":"type"},{"location":"reference/levelsetevolution/#GridapTopOpt.evolve!-Tuple{GridapTopOpt.Evolver, AbstractVector, AbstractVector, Any, Any}","page":"LevelSetEvolution","title":"GridapTopOpt.evolve!","text":"evolve!(::Evolver,φ::AbstractVector,vel::AbstractVector,γ,cache)\n\nEvolve the level-set function φ using a velocity field vel and parameter γ according to an Evolution method. Reuse the supplied cache.\n\nReturns\n\nφ: The updated level-set function as an AbstractVector\ncache: The cache for the evolver\n\n\n\n\n\n","category":"method"},{"location":"reference/levelsetevolution/#GridapTopOpt.evolve!-Tuple{GridapTopOpt.Evolver, AbstractVector, AbstractVector, Any}","page":"LevelSetEvolution","title":"GridapTopOpt.evolve!","text":"evolve!(::Evolver,φ::AbstractVector,vel::AbstractVector,γ)\n\nEvolve the level-set function φ using a velocity field vel and parameter γ according to an Evolution method.\n\nReturns\n\nφ: The updated level-set function as an AbstractVector\ncache: The cache for the evolver\n\n\n\n\n\n","category":"method"},{"location":"reference/levelsetevolution/#GridapTopOpt.evolve!-Tuple{GridapTopOpt.Evolver, Any, Any, Any}","page":"LevelSetEvolution","title":"GridapTopOpt.evolve!","text":"evolve!(::Evolver,φh,velh,γ)\n\nEvolve the level-set function φh using a velocity field velh and parameter γ according to an Evolution method.\n\nφh and velh should be FEFunctions.\n\nReturns\n\nφ: The updated level-set function as an AbstractVector\ncache: The cache for the evolver\n\n\n\n\n\n","category":"method"},{"location":"reference/levelsetevolution/#GridapTopOpt.evolve!-Tuple{GridapTopOpt.Evolver, Vararg{Any, 4}}","page":"LevelSetEvolution","title":"GridapTopOpt.evolve!","text":"evolve!(::Evolver,φh,velh,γ,cache)\n\nEvolve the level-set function φh using a velocity field velh and parameter γ according to an Evolution method. Reuse the supplied cache.\n\nφh and velh should be FEFunctions.\n\nReturns\n\nφ: The updated level-set function as an AbstractVector\ncache: The cache for the evolver\n\n\n\n\n\n","category":"method"},{"location":"reference/levelsetevolution/#GridapTopOpt.get_ls_space-Tuple{GridapTopOpt.Evolver}","page":"LevelSetEvolution","title":"GridapTopOpt.get_ls_space","text":"get_ls_space(m::Evolver)\n\nReturn the finite element space used for the level-set function.\n\n\n\n\n\n","category":"method"},{"location":"reference/levelsetevolution/#GridapTopOpt.get_min_dof_spacing-Tuple{GridapTopOpt.Evolver}","page":"LevelSetEvolution","title":"GridapTopOpt.get_min_dof_spacing","text":"get_min_dof_spacing(m::Evolver)\n\nReturn the minimum spacing of DOFs for the level-set function.\n\n\n\n\n\n","category":"method"},{"location":"reference/levelsetevolution/#Your-own-custom-Reinitialiser","page":"LevelSetEvolution","title":"Your own custom Reinitialiser","text":"","category":"section"},{"location":"reference/levelsetevolution/#GridapTopOpt.Reinitialiser","page":"LevelSetEvolution","title":"GridapTopOpt.Reinitialiser","text":"abstract type Reinitialiser\n\nYour own level-set reinitialisation method can be created by implementing concrete functionality for solve!.\n\n\n\n\n\n","category":"type"},{"location":"reference/levelsetevolution/#GridapTopOpt.reinit!-Tuple{GridapTopOpt.Reinitialiser, AbstractVector, Any}","page":"LevelSetEvolution","title":"GridapTopOpt.reinit!","text":"reinit!(::Reinitialiser,φ::AbstractVector,cache)\n\nReinitialise the level-set function φ according to an Reinitialiser method. Reuse the supplied cache.\n\nReturns\n\nφ: The updated level-set function as an AbstractVector\ncache: The cache for the reinitialiser\n\n\n\n\n\n","category":"method"},{"location":"reference/levelsetevolution/#GridapTopOpt.reinit!-Tuple{GridapTopOpt.Reinitialiser, AbstractVector}","page":"LevelSetEvolution","title":"GridapTopOpt.reinit!","text":"reinit!(::Reinitialiser,φ::AbstractVector)\n\nReinitialise the level-set function φ according to an Reinitialiser method.\n\nReturns\n\nφ: The updated level-set function as an AbstractVector\ncache: The cache for the reinitialiser\n\n\n\n\n\n","category":"method"},{"location":"reference/levelsetevolution/#GridapTopOpt.reinit!-Tuple{GridapTopOpt.Reinitialiser, Any, Any}","page":"LevelSetEvolution","title":"GridapTopOpt.reinit!","text":"reinit!(::Reinitialiser,φh,cache)\n\nReinitialise the level-set function φh according to an Reinitialiser method. Reuse the supplied cache.\n\nφh should be an FEFunction.\n\nReturns\n\nφ: The updated level-set function as an AbstractVector\ncache: The cache for the reinitialiser\n\n\n\n\n\n","category":"method"},{"location":"reference/levelsetevolution/#GridapTopOpt.reinit!-Tuple{GridapTopOpt.Reinitialiser, Any}","page":"LevelSetEvolution","title":"GridapTopOpt.reinit!","text":"reinit!(::Reinitialiser,φh)\n\nReinitialise the level-set function φh according to an Reinitialiser method.\n\nφh should be an FEFunction.\n\nReturns\n\nφ: The updated level-set function as an AbstractVector\ncache: The cache for the reinitialiser\n\n\n\n\n\n","category":"method"},{"location":"reference/levelsetevolution/#Custom-Stencil-for-finite-difference-methods","page":"LevelSetEvolution","title":"Custom Stencil for finite difference methods","text":"","category":"section"},{"location":"reference/levelsetevolution/#GridapTopOpt.Stencil","page":"LevelSetEvolution","title":"GridapTopOpt.Stencil","text":"abstract type Stencil\n\nFinite difference stencil for a single step of the Hamilton-Jacobi evolution equation and reinitialisation equation.\n\nYour own spatial stencil can be implemented by extending the methods below.\n\n\n\n\n\n","category":"type"},{"location":"reference/levelsetevolution/#GridapTopOpt.evolve!-Tuple{GridapTopOpt.Stencil, Vararg{Any, 6}}","page":"LevelSetEvolution","title":"GridapTopOpt.evolve!","text":"evolve!(::Stencil,φ,vel,Δt,Δx,isperiodic,caches) -> φ\n\nSingle finite difference step of the Hamilton-Jacobi evoluation equation for a given Stencil.\n\n\n\n\n\n","category":"method"},{"location":"reference/levelsetevolution/#GridapTopOpt.reinit!-Tuple{GridapTopOpt.Stencil, Vararg{Any, 7}}","page":"LevelSetEvolution","title":"GridapTopOpt.reinit!","text":"reinit!(::Stencil,φ_new,φ,vel,Δt,Δx,isperiodic,caches) -> φ\n\nSingle finite difference step of the reinitialisation equation for a given Stencil.\n\n\n\n\n\n","category":"method"},{"location":"reference/levelsetevolution/#GridapTopOpt.allocate_caches-Tuple{GridapTopOpt.Stencil, Any, Any}","page":"LevelSetEvolution","title":"GridapTopOpt.allocate_caches","text":"allocate_caches(::Stencil,φ,vel)\n\nAllocate caches for a given Stencil.\n\n\n\n\n\n","category":"method"},{"location":"reference/levelsetevolution/#GridapTopOpt.check_order","page":"LevelSetEvolution","title":"GridapTopOpt.check_order","text":"check_order(::Stencil,order)\n\nThrow error if insufficient reference element order to implement stencil in parallel.\n\n\n\n\n\n","category":"function"},{"location":"reference/optimisers/#Optimisers","page":"Optimisers","title":"Optimisers","text":"","category":"section"},{"location":"reference/optimisers/","page":"Optimisers","title":"Optimisers","text":"In GridapTopOpt we implement optimisation algorithms as iterators that inherit from an abstract type Optimiser. A concrete Optimiser implementation, say OptEg, then implements iterate(m::OptEg) ↦ (var,state) and iterate(m::OptEg,state) ↦ (var,state), where var and state are the available items in the outer loop and internal state of the iterator, respectively. As a result we can iterate over the object m=OptEg(...) using for var in m. The benefit of this implementation is that the internals of the optimisation method can be hidden in the source code while the explicit for loop is still visible to the user. The body of the loop can then be used for auxiliary operations such as writing the optimiser history and other files.","category":"page"},{"location":"reference/optimisers/","page":"Optimisers","title":"Optimisers","text":"The below describes the implemented optimisers along with the OptimiserHistory type. Custom optimisers can be implemented by creating types that inherit from Optimiser and extending the interfaces in Custom optimiser.","category":"page"},{"location":"reference/optimisers/#Lagrangian-and-Augmented-Lagrangian-method","page":"Optimisers","title":"Lagrangian & Augmented Lagrangian method","text":"","category":"section"},{"location":"reference/optimisers/#GridapTopOpt.AugmentedLagrangian","page":"Optimisers","title":"GridapTopOpt.AugmentedLagrangian","text":"struct AugmentedLagrangian <: Optimiser\n\nAn augmented Lagrangian method based on Nocedal and Wright, 2006 (link). Note that this method will function as a Lagrangian method if no constraints are defined in problem::AbstractPDEConstrainedFunctionals.\n\nParameters\n\nproblem::AbstractPDEConstrainedFunctionals: The objective and constraint setup.\nls_evolver::AbstractLevelSetEvolution: Solver for the evolution and reinitisation equations.\nvel_ext::AbstractVelocityExtension: The velocity-extension method for extending shape sensitivities onto the computational domain.\nhistory::OptimiserHistory{Float64}: Historical information for optimisation problem.\nconverged::Function: A function to check optimiser convergence.\nhas_oscillations::Function: A function to check for oscillations.\nparams::NamedTuple: Optimisation parameters.\n\nThe has_oscillations function has been added to avoid oscillations in the iteration history. By default this uses a mean zero crossing algorithm as implemented in ChaosTools. Oscillations checking can be disabled by taking has_oscillations = (args...) -> false.\n\n\n\n\n\n","category":"type"},{"location":"reference/optimisers/#GridapTopOpt.AugmentedLagrangian-Union{Tuple{N}, Tuple{GridapTopOpt.AbstractPDEConstrainedFunctionals{N}, GridapTopOpt.AbstractLevelSetEvolution, GridapTopOpt.AbstractVelocityExtension, Any}} where N","page":"Optimisers","title":"GridapTopOpt.AugmentedLagrangian","text":"AugmentedLagrangian(\n  problem    :: AbstractPDEConstrainedFunctionals{N},\n  ls_evolver :: AbstractLevelSetEvolution,\n  vel_ext    :: AbstractVelocityExtension,\n  φ0;\n  Λ_max = 10^10, ζ = 1.1, update_mod = 5, γ = 0.1, os_γ_mult = 0.75,\n  Λ_update_tol = 0.01,maxiter = 1000, verbose=false, constraint_names = map(i -> Symbol(\"C_$i\"),1:N),\n  converged::Function = default_al_converged, debug = false,\n  has_oscillations::Function = default_has_oscillations\n) where {N,O}\n\nCreate an instance of AugmentedLagrangian with several adjustable defaults.\n\nRequired\n\nproblem::AbstractPDEConstrainedFunctionals: The objective and constraint setup.\nls_evolver::AbstractLevelSetEvolution: Solver for the evolution and reinitisation equations.\nvel_ext::AbstractVelocityExtension: The velocity-extension method for extending shape sensitivities onto the computational domain.\nφ0: An initial level-set function defined as a FEFunction or GridapDistributed equivilent.\n\nOptional defaults\n\nγ = 0.1: Initial coeffient on the time step size for solving the Hamilton-Jacobi evolution equation.\nζ = 1.1: Increase multiplier on Λ every update_mod iterations.\nΛ_max = 10^10: Maximum value on any entry in Λ.\nupdate_mod = 5: Number of iterations before increasing Λ.\nreinit_mod = 1: How often we solve reinitialisation equation.\nmaxiter = 1000: Maximum number of algorithm iterations.\nverbose=false: Verbosity flag.\nconstraint_names = map(i -> Symbol(\"C_$i\"),1:N): Constraint names for history output.\nhas_oscillations::Function = default_has_oscillations: Function to check for oscillations in the history.\ninitial_parameters::Function = default_al_init_params: Function to generate initial λ, Λ. This can be replaced to inject different λ and Λ, for example.\nos_γ_mult = 0.75: Decrease multiplier for γ when has_oscillations returns true\nΛ_update_tol = 0.01: Tolerance of constraint satisfaction for updating Λ. In our testing, this is usually set to 0.01. Some problems, may perform better with a stricter tolerance (e.g., 0.001 or 0.0 to always update).\nconverged::Function = default_hp_converged: Convergence criteria.\ndebug = false: Debug flag.\n\n\n\n\n\n","category":"method"},{"location":"reference/optimisers/#Hilbertian-projection-method","page":"Optimisers","title":"Hilbertian projection method","text":"","category":"section"},{"location":"reference/optimisers/#GridapTopOpt.HilbertianProjection","page":"Optimisers","title":"GridapTopOpt.HilbertianProjection","text":"struct HilbertianProjection <: Optimiser\n\nA Hilbertian projection method as described by Wegert et al., 2023 (link).\n\nParameters\n\nproblem::AbstractPDEConstrainedFunctionals{N}: The objective and constraint setup.\nls_evolver::AbstractLevelSetEvolution: Solver for the evolution and reinitisation equations.\nvel_ext::AbstractVelocityExtension: The velocity-extension method for extending shape sensitivities onto the computational domain.\nprojector::HilbertianProjectionMap: Sensitivity information projector\nhistory::OptimiserHistory{Float64}: Historical information for optimisation problem.\nconverged::Function: A function to check optimiser convergence.\nhas_oscillations::Function: A function to check for oscillations.\nparams::NamedTuple: Optimisation parameters.\n\n\n\n\n\n","category":"type"},{"location":"reference/optimisers/#GridapTopOpt.HilbertianProjection-Union{Tuple{N}, Tuple{GridapTopOpt.AbstractPDEConstrainedFunctionals{N}, GridapTopOpt.AbstractLevelSetEvolution, GridapTopOpt.AbstractVelocityExtension, Any}} where N","page":"Optimisers","title":"GridapTopOpt.HilbertianProjection","text":"HilbertianProjection(\n  problem    :: AbstractPDEConstrainedFunctionals{N},\n  ls_evolver :: AbstractLevelSetEvolution,\n  vel_ext    :: AbstractVelocityExtension,\n  φ0;\n  orthog = HPModifiedGramSchmidt(),\n  λ=0.5, α_min=0.1, α_max=1.0, γ=0.1, reinit_mod = 1,\n  ls_enabled = true, ls_max_iters = 10, ls_δ_inc = 1.1, ls_δ_dec = 0.7,\n  ls_ξ = 1, ls_ξ_reduce_coef = 0.0025, ls_ξ_reduce_abs_tol = 0.01,\n  ls_γ_min = 0.001, ls_γ_max = 0.1,\n  maxiter = 1000, verbose=false, constraint_names = map(i -> Symbol(\"C_$i\"),1:N),\n  converged::Function = default_hp_converged, debug = false,\n  has_oscillations::Function = (ls_enabled ? (args...)->false : default_has_oscillations),\n  os_γ_mult = 0.5\n\n) where N\n\nCreate an instance of HilbertianProjection with several adjustable defaults including the orthogonalisation method. By default the later is HPModifiedGramSchmidt.\n\nRequired\n\nproblem::AbstractPDEConstrainedFunctionals{N}: The objective and constraint setup.\nls_evolver::AbstractLevelSetEvolution: Solver for the evolution and reinitisation equations.\nvel_ext::AbstractVelocityExtension: The velocity-extension method for extending shape sensitivities onto the computational domain.\nφ0: An initial level-set function defined as a FEFunction or GridapDistributed equivilent.\n\nAlgorithm defaults\n\nγ = 0.1: Initial coeffient on the time step size for solving the Hamilton-Jacobi evolution equation.\nmaxiter = 1000: Maximum number of algorithm iterations.\nverbose=false: Verbosity flag.\nconstraint_names = map(i -> Symbol(\"C_$i\"),1:N): Constraint names for history output.\nconverged::Function = default_hp_converged: Convergence criteria.\nhas_oscillations::Function = (ls_enabled ? (args...)->false : default_has_oscillations: By default this is disabled when a line search in enabled.\nos_γ_mult = 0.5: Decrease multiplier for γ when has_oscillations returns true\ndebug = false: Debug flag.\nα_min ∈ [0,1] = 0.1: Controls lower bound on on the projected objective descent coefficent. α_min = 1 ignores the objective function and instead solves a constraint satisfaction problem.\nα_max ∈ [0,1] = 1.0: Controls the upper bound on the projected objective descent coeffient. Typically this shouldn't change unless wanting to approach the optimum 'slower'.\nλ = 0.5: The rate of contraint decrease.\n\nNote that in practice we usually only adjust α_min to control the balance between improving the objective or constraints.\n\nLine search defaults\n\nls_enabled = true: Set whether a line search is used.\nls_max_iters = 10: Maximum number of line search iterations.\nls_δ_inc = 1.1: Increase multiplier for γ on acceptance.\nls_δ_dec = 0.7: Decrease multiplier for γ on rejection.\nls_ξ = 1.0: Line search tolerance for objective reduction.\nls_ξ_reduce_coef = 0.0025: Coeffient on ls_ξ if constraints within tolerance (see below).\nls_ξ_reduce_abs_tol = 0.01: Tolerance on constraints to reduce ls_ξ via ls_ξ_reduce_coef.\nls_γ_min = 0.001: Minimum coeffient on the time step size for solving the HJ evolution equation.\nls_γ_max = 0.1: Maximum coeffient on the time step size for solving the HJ evolution equation.\n\nA more concervative evolution of the boundary can be achieved by decreasing ls_γ_max.\n\nnote: Note\nThe line search has been adjusted so that it is only enforced once the constraints are within a set tolerance. This generally leads to better optimisation histories, especially for problems where constraints are far from saturation and the objective must decrease to improve the constraints.This can be set to always be enfored by taking ls_ξ = 0.0025 and ls_ξ_reduce_coef = 0.1.\n\n\n\n\n\n","category":"method"},{"location":"reference/optimisers/#GridapTopOpt.HPModifiedGramSchmidt","page":"Optimisers","title":"GridapTopOpt.HPModifiedGramSchmidt","text":"HPModifiedGramSchmidt\n\nHigh performance modified Gram-Schmidt. Based on Algorithm 6 in this paper.\n\n\n\n\n\n","category":"type"},{"location":"reference/optimisers/#GridapTopOpt.OrthogonalisationMap","page":"Optimisers","title":"GridapTopOpt.OrthogonalisationMap","text":"OrthogonalisationMap\n\n\n\n\n\n","category":"type"},{"location":"reference/optimisers/#Optimiser-history","page":"Optimisers","title":"Optimiser history","text":"","category":"section"},{"location":"reference/optimisers/#GridapTopOpt.OptimiserHistory","page":"Optimisers","title":"GridapTopOpt.OptimiserHistory","text":"mutable struct OptimiserHistory{T}\n\nTrack historical information on optimisation problem iteration history.\n\nParameters\n\nniter::Int: Current iteration number\nkeys::Vector{Symbol}: Vector of symbols associated to values\nvalues::Dict{Symbol,Vector{T}}: Dictionary of vectors associated to keys\nbundles::Dict{Symbol,Vector{Symbol}}: Groups of symbols (e.g., a group of constraints)\nverbose::SolverVerboseLevel: Verbosity level\nmaxiter::Int: Maximum number of iterations.\n\nBehaviour\n\nIndexing at a specific iteration returns an OptimiserHistorySlice.\nIndexing with a key returns all values of that key\nIndexing with a key and iteration returns value/s of the key at the iteration.\n\n\n\n\n\n","category":"type"},{"location":"reference/optimisers/#GridapTopOpt.OptimiserHistorySlice","page":"Optimisers","title":"GridapTopOpt.OptimiserHistorySlice","text":"struct OptimiserHistorySlice{T} end\n\nA read-only wrapper of OptimiserHistory for IO display of iteration history at a specific iteration.\n\n\n\n\n\n","category":"type"},{"location":"reference/optimisers/#Custom-optimiser","page":"Optimisers","title":"Custom optimiser","text":"","category":"section"},{"location":"reference/optimisers/#GridapTopOpt.Optimiser","page":"Optimisers","title":"GridapTopOpt.Optimiser","text":"abstract type Optimiser\n\nOptimisers in GridapTopOpt.jl are implemented as iterators. Your own optimiser can be implemented by implementing concrete functionality of the below.\n\n\n\n\n\n","category":"type"},{"location":"reference/optimisers/#Base.iterate-Tuple{GridapTopOpt.Optimiser}","page":"Optimisers","title":"Base.iterate","text":"Base.iterate(::Optimiser)\n\nReturn tuple of first iteration state for Optimiser.\n\n\n\n\n\n","category":"method"},{"location":"reference/optimisers/#Base.iterate-Tuple{GridapTopOpt.Optimiser, Any}","page":"Optimisers","title":"Base.iterate","text":"Base.iterate(::Optimiser,state)\n\nReturn tuple of next iteration state given current state for Optimiser.\n\n\n\n\n\n","category":"method"},{"location":"reference/optimisers/#GridapTopOpt.get_history-Tuple{GridapTopOpt.Optimiser}","page":"Optimisers","title":"GridapTopOpt.get_history","text":"get_history(::Optimiser) :: OptimiserHistory\n\nGet OptimiserHistory from Optimiser.\n\n\n\n\n\n","category":"method"},{"location":"reference/optimisers/#GridapTopOpt.converged-Tuple{GridapTopOpt.Optimiser}","page":"Optimisers","title":"GridapTopOpt.converged","text":"converged(::Optimiser)\n\nReturn a Bool that is true if the Optimiser has converged, otherwise false.\n\n\n\n\n\n","category":"method"},{"location":"reference/utilities/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"reference/utilities/#Ersatz-material-interpolation","page":"Utilities","title":"Ersatz material interpolation","text":"","category":"section"},{"location":"reference/utilities/#GridapTopOpt.SmoothErsatzMaterialInterpolation","page":"Utilities","title":"GridapTopOpt.SmoothErsatzMaterialInterpolation","text":"struct SmoothErsatzMaterialInterpolation{M<:Vector{<:Number},N<:Vector{<:Number}}\n\nA wrapper holding parameters and methods for interpolating an integrand across a single boundary partialOmega.\n\nE.g., int fmathrmdOmega = int I(varphi)fmathrmdD where Omegasubset D is described by a level-set function varphi and I is an indicator function.\n\nProperties\n\nη::M: the interpolation or smoothing radius across ∂Ω\nϵ::M: the ersatz material density\nH: a smoothed Heaviside function\nDH: the derivative of H\nI: an indicator function\nρ: a function describing the volume density of Omega (e.g., mathrmVol(Omega) = int rho(varphi))mathrmdD)\n\nNote\n\nWe store η and ϵ as length-one vectors so that updating these values propagates through H, DH, etc.\nTo update η and/or ϵ in an instance m, take m.η .= <VALUE>.\nA conviencence constructor is provided to create an instance given η<:Number and ϵ<:Number.\n\n\n\n\n\n","category":"type"},{"location":"reference/utilities/#Mesh-labelling","page":"Utilities","title":"Mesh labelling","text":"","category":"section"},{"location":"reference/utilities/#GridapTopOpt.update_labels!","page":"Utilities","title":"GridapTopOpt.update_labels!","text":"update_labels!(e::Int,model,f_Γ::Function,name::String)\n\nGiven a tag number e, a DiscreteModel model, an indicator function f_Γ, and a string name, label the corresponding vertices, edges, and faces as name.\n\nNote: f_Γ must recieve a Vector and return a Boolean depending on whether it indicates Γ\n\n\n\n\n\n","category":"function"},{"location":"reference/utilities/#Helpers","page":"Utilities","title":"Helpers","text":"","category":"section"},{"location":"reference/utilities/#GridapTopOpt.initial_lsf","page":"Utilities","title":"GridapTopOpt.initial_lsf","text":"initial_lsf(ξ,a;b)\n\nGenerate a function f according to f(x) = -1/4 ∏ᵢ(cos(ξπ(xᵢ-bᵢ))) - a/4 where x is a vector with components xᵢ.\n\n\n\n\n\n","category":"function"},{"location":"reference/utilities/#GridapTopOpt.isotropic_elast_tensor","page":"Utilities","title":"GridapTopOpt.isotropic_elast_tensor","text":"isotropic_elast_tensor(D::Int,E::M,v::M)\n\nGenerate an isotropic SymFourthOrderTensorValue given a dimension D, Young's modulus E, and Poisson's ratio v.\n\n\n\n\n\n","category":"function"},{"location":"reference/utilities/#GridapTopOpt.get_cartesian_element_sizes","page":"Utilities","title":"GridapTopOpt.get_cartesian_element_sizes","text":"get_cartesian_element_sizes(model)\n\nGiven a CartesianDiscreteModel return the element size as a tuple.\n\n\n\n\n\n","category":"function"},{"location":"reference/utilities/#GridapTopOpt.get_element_diameters","page":"Utilities","title":"GridapTopOpt.get_element_diameters","text":"get_element_diameters(model)\n\nGiven a general unstructured model return the maximum vertex length of a polytope.\n\n\n\n\n\n","category":"function"},{"location":"reference/utilities/#GridapTopOpt.get_element_diameter_field","page":"Utilities","title":"GridapTopOpt.get_element_diameter_field","text":"get_element_diameter_field(model)\n\nGiven a general unstructured model return the maximum vertex length as a CellField over the triangulation.\n\n\n\n\n\n","category":"function"},{"location":"reference/utilities/","page":"Utilities","title":"Utilities","text":"warning: `get_cartesian_element_sizes` vs. `get_element_diameters`\nCurrently, we use different naming for returning the size of elements for a CartesianDiscreteModel and a general DiscreteModel.The function get_element_diameters returns a list of element diameters and should be used for TRI and TET polytopes (this can be extended to QUAD and HEX if needed).\nThe legacy function get_cartesian_element_sizes returns a tuple of a single element size for a mesh with homogenous sizes.","category":"page"},{"location":"examples/TO-with-Zygote/#Topology-optimisation-with-Zygote","page":"Topology optimisation with Zygote","title":"Topology optimisation with Zygote","text":"","category":"section"},{"location":"examples/TO-with-Zygote/","page":"Topology optimisation with Zygote","title":"Topology optimisation with Zygote","text":"note: Note\nThis page is under construction","category":"page"},{"location":"examples/TO-with-Zygote/","page":"Topology optimisation with Zygote","title":"Topology optimisation with Zygote","text":"For now, see discussion in CustomPDEConstrainedFunctionals and v0.3.0 release notes.","category":"page"},{"location":"#GridapTopOpt.jl","page":"Home","title":"GridapTopOpt.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for GridapTopOpt.jl!","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GridapTopOpt.jl is computational toolbox for level set-based topology optimisation implemented in Julia and the Gridap package ecosystem. The core design principle of GridapTopOpt.jl is to provide an extendable framework for solving optimisation problems in serial or parallel with a high-level programming interface and automatic differentiation. See the following publication for further details:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Wegert, Z.J., Manyer, J., Mallon, C.N. et al. GridapTopOpt.jl: a scalable Julia toolbox for level set-based topology optimisation. Struct Multidisc Optim 68, 22 (2025). https://doi.org/10.1007/s00158-024-03927-3","category":"page"},{"location":"#How-to-use-this-documentation","page":"Home","title":"How to use this documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The first step for new users is to visit the Getting Started page.\nA set of tutorials are available as part of the above paper.\nThe detailed documentation is in the Reference section.","category":"page"},{"location":"#Julia-educational-resources","page":"Home","title":"Julia educational resources","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A basic knowledge of the Julia programming language is needed to use the GridapTopOpt.jl package. Here, one can find a list of resources to get started with this programming language.","category":"page"},{"location":"","page":"Home","title":"Home","text":"First steps to learn Julia form the Gridap wiki page.\nOfficial webpage docs.julialang.org\nOfficial list of learning resources julialang.org/learning","category":"page"}]
}
