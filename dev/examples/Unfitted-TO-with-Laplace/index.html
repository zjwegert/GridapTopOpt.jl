<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Topology optimisation on unfitted meshes · GridapTopOpt.jl</title><meta name="title" content="Topology optimisation on unfitted meshes · GridapTopOpt.jl"/><meta property="og:title" content="Topology optimisation on unfitted meshes · GridapTopOpt.jl"/><meta property="twitter:title" content="Topology optimisation on unfitted meshes · GridapTopOpt.jl"/><meta name="description" content="Documentation for GridapTopOpt.jl."/><meta property="og:description" content="Documentation for GridapTopOpt.jl."/><meta property="twitter:description" content="Documentation for GridapTopOpt.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="GridapTopOpt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">GridapTopOpt.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../getting-started/">Getting Started</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../">Introductory examples</a></li><li class="is-active"><a class="tocitem" href>Topology optimisation on unfitted meshes</a><ul class="internal"><li><a class="tocitem" href="#Problem-formulation"><span>Problem formulation</span></a></li><li><a class="tocitem" href="#Unfitted-formulation"><span>Unfitted formulation</span></a></li><li><a class="tocitem" href="#Setup-and-parameters"><span>Setup and parameters</span></a></li><li><a class="tocitem" href="#Mesh-with-refinement"><span>Mesh with refinement</span></a></li><li><a class="tocitem" href="#FESpace-for-level-set-function-and-derivatives"><span>FESpace for level-set function and derivatives</span></a></li><li><a class="tocitem" href="#Background-triangulations-and-measures"><span>Background triangulations and measures</span></a></li><li><a class="tocitem" href="#Embedded-triangulations-and-measures"><span>Embedded triangulations and measures</span></a></li><li><a class="tocitem" href="#Isolated-volume-marking-and-automatic-differentation"><span>Isolated volume marking and automatic differentation</span></a></li><li><a class="tocitem" href="#FE-problem"><span>FE problem</span></a></li><li><a class="tocitem" href="#Evolution"><span>Evolution</span></a></li><li><a class="tocitem" href="#Hilbertian-extension-regularisation-problems"><span>Hilbertian extension-regularisation problems</span></a></li><li><a class="tocitem" href="#Optimiser-and-solution"><span>Optimiser and solution</span></a></li></ul></li><li><a class="tocitem" href="../Fluid-structure_interaction_with_CutFEM/">FSI with CutFEM</a></li><li><a class="tocitem" href="../TO-with-Zygote/">Topology optimisation with Zygote</a></li></ul></li><li><a class="tocitem" href="../../breaking-changes/">Breaking changes</a></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../reference/optimisers/">Optimisers</a></li><li><a class="tocitem" href="../../reference/statemaps/">StateMaps</a></li><li><a class="tocitem" href="../../reference/zygote/">Zygote &amp; GridapTopOpt Compatability</a></li><li><input class="collapse-toggle" id="menuitem-5-4" type="checkbox"/><label class="tocitem" for="menuitem-5-4"><span class="docs-label">LevelSetEvolution</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../reference/levelsetevolution/">LevelSetEvolution</a></li><li><a class="tocitem" href="../../reference/levelsetevolution/finitediff/">Upwind finite difference schemes</a></li><li><a class="tocitem" href="../../reference/levelsetevolution/unfitted/">Unfitted schemes</a></li></ul></li><li><a class="tocitem" href="../../reference/embedded/">Embedded</a></li><li><a class="tocitem" href="../../reference/velext/">Velocity extension</a></li><li><a class="tocitem" href="../../reference/io/">IO</a></li><li><a class="tocitem" href="../../reference/utilities/">Utilities</a></li><li><a class="tocitem" href="../../reference/benchmarking/">Benchmarking</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Topology optimisation on unfitted meshes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Topology optimisation on unfitted meshes</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/zjwegert/GridapTopOpt.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/zjwegert/GridapTopOpt.jl/blob/main/docs/src/examples/Unfitted-TO-with-Laplace.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Topology-optimisation-on-unfitted-meshes"><a class="docs-heading-anchor" href="#Topology-optimisation-on-unfitted-meshes">Topology optimisation on unfitted meshes</a><a id="Topology-optimisation-on-unfitted-meshes-1"></a><a class="docs-heading-anchor-permalink" href="#Topology-optimisation-on-unfitted-meshes" title="Permalink"></a></h1><p>In this tutorial, we will learn:</p><ul><li>How to formulate a Laplace&#39;s equation with CutFEM based on <a href="https://doi.org/10.1002/nme.4823">Burman et al. (2015)</a></li><li>How to use unfitted discretisations from <a href="https://github.com/gridap/GridapEmbedded.jl/">GridapEmbedded</a> in GridapTopOpt</li><li>How to use automatic (unfitted) shape differentation</li></ul><p>This tutorial is for intermediate-level users. You should be familar with the GridapTopOpt framework before attempting this tutorial. In addition, it is recommended that this <a href="https://gridap.github.io/Tutorials/dev/pages/t020_poisson_unfitted/">Gridap tutorial</a> is read before attempting the below.</p><h2 id="Problem-formulation"><a class="docs-heading-anchor" href="#Problem-formulation">Problem formulation</a><a id="Problem-formulation-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-formulation" title="Permalink"></a></h2><p>The goal of this tutorial is to solve a level-set topology optimisation problem with an unfitted discretisation and automatic shape differentiation. To simplify this tutorial, we consider Laplace&#39;s equation for the underlying PDE. Specifically, the PDE-constrained optimisation problem that we consider is</p><p class="math-container">\[\begin{aligned}
    \min_{\Omega\subset D}&amp;~J(\Omega)\coloneqq\int_{\Omega(\phi)}\boldsymbol{\nabla}u\cdot\boldsymbol{\nabla}u~\mathrm{d}\boldsymbol{x}\\
    \text{s.t. }&amp;~C(\Omega)=0,\\
    &amp;~\left\lbrace\begin{aligned}
    -\boldsymbol{\nabla}^2u &amp;= 0~\text{in }\Omega,\\
\boldsymbol{\nabla} u\cdot\boldsymbol{n} &amp;= 1~\text{on }\Gamma_N,\\
\boldsymbol{\nabla} u\cdot\boldsymbol{n} &amp;= 0~\text{on }\Gamma,\\
u &amp;= 0~\text{on }\overline{\Omega}_D,
    \end{aligned}\right.
\end{aligned}\]</p><p>where <span>$C(\Omega)=(\operatorname{Vol}(\Omega) - 0.3)/\operatorname{Vol}(D)$</span> constrains the volume of <span>$\Omega$</span>. The background domain <span>$D$</span> and boundary conditions are shown below:</p><p align="center">
<img src="../Unfitted-TO-with-Laplace.png" width="300">
</p><h2 id="Unfitted-formulation"><a class="docs-heading-anchor" href="#Unfitted-formulation">Unfitted formulation</a><a id="Unfitted-formulation-1"></a><a class="docs-heading-anchor-permalink" href="#Unfitted-formulation" title="Permalink"></a></h2><p>In the following, we discretise the PDE governing <span>$u$</span> using CutFEM based on <a href="https://doi.org/10.1002/nme.4823">Burman et al. (2015)</a>. The weak formulation for this problem is: for <span>$V=H^1(\Omega;u_{\Gamma_D}=0)$</span>, find <span>$u\in V$</span> such that</p><p class="math-container">\[\int_{\Omega(\phi)}\boldsymbol{\nabla}u\cdot\boldsymbol{\nabla}v~\mathrm{d}\boldsymbol{x} + j(u,v) + i(u,v) = \int_{\Gamma_N}v~\mathrm{d}s,~\forall v\in V.\]</p><p>Those who are familiar with deriving the weak form will notice that we have two addition terms in this formulation. The first is the so-called ghost penalty term <span>$j(u,v)$</span> that extends coercivity of the bilinear form from the physical domain to the cut domain. This is given by</p><p class="math-container">\[j(u,v)=\int_{\Gamma_g}\gamma h \llbracket \boldsymbol{n}\cdot\boldsymbol{\nabla}u\rrbracket\llbracket \boldsymbol{n}\cdot\boldsymbol{\nabla}v\rrbracket~\mathrm{d}s.\]</p><p>The second term <span>$i(u,v)$</span> enforces zero temperature within an isolated volumes marked by <span>$\chi$</span>. We can think of these isolated volumes as blobs of material that are not sufficently constrained. As a result, without an additional constraint on these &quot;blobs&quot;, an unfitted discretisation will yield infinite solutions. This term is given by</p><p class="math-container">\[i(u,v) = \int_{\Omega(\phi)}\chi uv~\mathrm{d}\boldsymbol{x}\]</p><p>Note that this only acts on the isolated volumes marked by <span>$\chi$</span>. As a result, the problem is still consistent.</p><h2 id="Setup-and-parameters"><a class="docs-heading-anchor" href="#Setup-and-parameters">Setup and parameters</a><a id="Setup-and-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Setup-and-parameters" title="Permalink"></a></h2><p>As usual, we start by loading the required libraries and defining any parameters:</p><pre><code class="language-julia hljs">using Gridap, Gridap.Adaptivity, Gridap.Geometry
using GridapEmbedded, GridapEmbedded.LevelSetCutters
using GridapTopOpt, GridapSolvers

using GridapTopOpt: StateParamMap

path=&quot;./results/Unfitted_Thermal2D/&quot;
mkpath(path)
# Params
n = 50            # Initial mesh size (pre-refinement)
max_steps = n/5   # Time-steps for evolution equation
vf = 0.3          # Volume fraction
α_coeff = 2       # Regularisation coefficient extension-regularisation
iter_mod = 10     # Write output every iter_mod iterations</code></pre><p>Here, we deictate that the initial mesh size is <span>$50^2$</span> quadrilateral elements, the time steps for the evolution equation is set to <span>$n/5$</span>, the required volume fraction is 0.3, the reguarisation coefficent for the Hilbertian extension-regularisation is 2, and we data files at each iteration.</p><h2 id="Mesh-with-refinement"><a class="docs-heading-anchor" href="#Mesh-with-refinement">Mesh with refinement</a><a id="Mesh-with-refinement-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-with-refinement" title="Permalink"></a></h2><p>For this problem, we use a refined mesh using Gridap&#39;s adaptivity features. In addition, we mark mesh entities that are part of <span>$\overline{\Omega}_D$</span> and <span>$\Gamma_N$</span>:</p><pre><code class="language-julia hljs"># Base model
_model = CartesianDiscreteModel((0,1,0,1),(n,n))
base_model = UnstructuredDiscreteModel(_model)
# Refinement
ref_model = refine(base_model, refinement_method = &quot;barycentric&quot;)
ref_model = refine(ref_model)
ref_model = refine(ref_model)
model = ref_model.model
# Get mesh size
h = minimum(get_element_diameters(model))
hₕ = get_element_diameter_field(model)
# Mark mesh entities
f_Γ_D(x) = (x[1]-0.5)^2 + (x[2]-0.5)^2 &lt;= 0.05^2
f_Γ_N(x) = ((x[1] ≈ 0 || x[1] ≈ 1) &amp;&amp; (0.2 &lt;= x[2] &lt;= 0.3 + eps() || 0.7 - eps() &lt;= x[2] &lt;= 0.8)) ||
  ((x[2] ≈ 0 || x[2] ≈ 1) &amp;&amp; (0.2 &lt;= x[1] &lt;= 0.3 + eps() || 0.7 - eps() &lt;= x[1] &lt;= 0.8))
update_labels!(1,model,f_Γ_D,&quot;Omega_D&quot;)
update_labels!(2,model,f_Γ_N,&quot;Gamma_N&quot;)
writevtk(model,path*&quot;model&quot;)</code></pre><div class="admonition is-warning" id="Warning-86501b1630a634e"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-86501b1630a634e" title="Permalink"></a></header><div class="admonition-body"><p>Non-TET/TRI polytopes are simplexified by GridapEmbedded when cutting. As a result, derivative information from AD will not be correct when using a mesh that isn&#39;t made of TRI/TET. Please use a mesh with TRI/TET polytopes to ensure correctness of derivative results.</p></div></div><h2 id="FESpace-for-level-set-function-and-derivatives"><a class="docs-heading-anchor" href="#FESpace-for-level-set-function-and-derivatives">FESpace for level-set function and derivatives</a><a id="FESpace-for-level-set-function-and-derivatives-1"></a><a class="docs-heading-anchor-permalink" href="#FESpace-for-level-set-function-and-derivatives" title="Permalink"></a></h2><p>In example, we consider piecewise linear cuts defined via a level-set function. As such, the level-set function should be discretised using continuous piecewise-linear finite elements. In addition, we use the same space for the derivatives, except we also constrain the derivative space so that the shape derivatives are zero on <span>$\overline{\Omega}_D$</span> and <span>$\Gamma_N$</span>.</p><pre><code class="language-julia hljs">reffe_scalar = ReferenceFE(lagrangian,Float64,1)
V_φ = TestFESpace(model,reffe_scalar)
V_reg = TestFESpace(model,reffe_scalar;dirichlet_tags=[&quot;Omega_D&quot;,&quot;Gamma_N&quot;])
U_reg = TrialFESpace(V_reg)</code></pre><p>Next, we build the initial level-set function using</p><pre><code class="language-julia hljs">f1 = (x,y) -&gt; -cos(6π*(x-1/12))*cos(6π*(y-1/12))-0.5
f2 = (x,y) -&gt; -cos(6π*(x-3/12))*cos(6π*(y-1/12))-0.5
f3 = (x,y) -&gt; (x-0.5)^2 + (y-0.5)^2 - 0.06^2
f((x,y)) = min(max(f1(x,y),f2(x,y)),f3(x,y))
φh = interpolate(f,V_φ)</code></pre><p>Before defining the triangulation, we need to ensure that the initial cut interface defined by the level-set function does not intersect the vertices in the background domain. We do this using:</p><pre><code class="language-julia hljs">GridapTopOpt.correct_ls!(φh)</code></pre><h2 id="Background-triangulations-and-measures"><a class="docs-heading-anchor" href="#Background-triangulations-and-measures">Background triangulations and measures</a><a id="Background-triangulations-and-measures-1"></a><a class="docs-heading-anchor-permalink" href="#Background-triangulations-and-measures" title="Permalink"></a></h2><p>Next we define the measures for the background domain as usual</p><pre><code class="language-julia hljs">Ω_bg = Triangulation(model)
Γ_N = BoundaryTriangulation(model,tags=&quot;Gamma_N&quot;)
dΩ_bg = Measure(Ω_bg,2)
dΓ_N = Measure(Γ_N,2)
vol_D = sum(∫(1)dΩ_bg)</code></pre><h2 id="Embedded-triangulations-and-measures"><a class="docs-heading-anchor" href="#Embedded-triangulations-and-measures">Embedded triangulations and measures</a><a id="Embedded-triangulations-and-measures-1"></a><a class="docs-heading-anchor-permalink" href="#Embedded-triangulations-and-measures" title="Permalink"></a></h2><p>To make it possible to update the embedded triangulations, measures, and the indicator function we use an <code>EmbeddedCollection</code>. This is given by</p><pre><code class="language-julia hljs">Ωs = EmbeddedCollection(model,φh) do cutgeo,cutgeo_facets,_φh
  Ωin = DifferentiableTriangulation(Triangulation(cutgeo,PHYSICAL),V_φ)
  Γ = DifferentiableTriangulation(EmbeddedBoundary(cutgeo),V_φ)
  Γg = GhostSkeleton(cutgeo)
  Ωact = Triangulation(cutgeo,ACTIVE)
  φ_cell_values = get_cell_dof_values(_φh)
  χ,_ = get_isolated_volumes_mask_polytopal(model,φ_cell_values,[&quot;Omega_D&quot;,])
  (;
    :Ωin  =&gt; Ωin,
    :dΩin =&gt; Measure(Ωin,2),
    :Γg   =&gt; Γg,
    :dΓg  =&gt; Measure(Γg,2),
    :n_Γg =&gt; get_normal_vector(Γg),
    :Γ    =&gt; Γ,
    :dΓ   =&gt; Measure(Γ,2),
    :n_Γ  =&gt; get_normal_vector(Γ),
    :Ωact =&gt; Ωact,
    :χ =&gt; χ
  )
end</code></pre><p>The <code>do</code> statement above provides a recipe for the <code>EmbeddedCollection</code> to generate the data in <code>Ωs</code> that can be accessed, for example, via <code>Ωs.Ωin</code>. The contents of <code>Ωs</code> can then be updated via <code>update_collection!(c::EmbeddedCollection,φh)</code>. In addition, new recipes can be added using <code>add_recipe!(c::EmbeddedCollection,r::Function[,φh])</code>. Inside <code>EmbeddedCollection</code>, cut geometries are created and then passed to recipes when <code>update_collection!</code> is called.</p><h2 id="Isolated-volume-marking-and-automatic-differentation"><a class="docs-heading-anchor" href="#Isolated-volume-marking-and-automatic-differentation">Isolated volume marking and automatic differentation</a><a id="Isolated-volume-marking-and-automatic-differentation-1"></a><a class="docs-heading-anchor-permalink" href="#Isolated-volume-marking-and-automatic-differentation" title="Permalink"></a></h2><p>In the above, we use <code>get_isolated_volumes_mask_polytopal</code> to create a cell field that marks cells based on whether they are connected to <code>Omega_D</code>. In addition, we wrap the cut triangulations inside <a href="https://gridap.github.io/GridapEmbedded.jl/stable/GeometricalDerivatives/#Geometrical-Derivatives"><code>DifferentiableTriangulation</code></a>. This is a wrapper around an embedded triangulation (i.e SubCellTriangulation or SubFacetTriangulation) implementing all the necessary methods to compute derivatives with respect to deformations of the embedded mesh. To do so, it propagates dual numbers into the geometric maps mapping cut subcells/subfacets to the background mesh. We refer to this article for the mathematical discussion:</p><blockquote><p>Wegert, Z.J., Manyer, J., Mallon, C.N. et al. Level-set topology optimisation with unfitted finite elements and automatic shape differentiation. Accepted for publication in Computer Methods in Applied Mechanics and Engineering (2025). <a href="http://arxiv.org/abs/2504.09748">http://arxiv.org/abs/2504.09748</a></p></blockquote><h2 id="FE-problem"><a class="docs-heading-anchor" href="#FE-problem">FE problem</a><a id="FE-problem-1"></a><a class="docs-heading-anchor-permalink" href="#FE-problem" title="Permalink"></a></h2><p>Now that all the measures are defined, lets define the weak form, optimisation functionals, and the FE operators. First, we can define the weak form and optimisation functionals as</p><pre><code class="language-julia hljs">γg = 0.1
a(u,v,φ) = ∫(∇(v)⋅∇(u))Ωs.dΩin +
           ∫((γg*mean(hₕ))*jump(Ωs.n_Γg⋅∇(v))*jump(Ωs.n_Γg⋅∇(u)))Ωs.dΓg +
           ∫(Ωs.χ*v*u)Ωs.dΩin
l(v,φ) = ∫(v)dΓ_N</code></pre><p>and</p><pre><code class="language-julia hljs">J(u,φ) = ∫(∇(u)⋅∇(u))Ωs.dΩin
Vol(u,φ) = ∫(1/vol_D)Ωs.dΩin - ∫(vf/vol_D)dΩ_bg
dVol(q,u,φ) = ∫(-1/vol_D*q/(abs(Ωs.n_Γ ⋅ ∇(φ))))Ωs.dΓ</code></pre><p>We have directly computed the shape derivative of the volume functional using the analytical results by Wegert et al. (2025) referenced above.</p><p>Next, we setup the <code>AffineFEStateMap</code> and <code>PDEConstrainedFunctionals</code> objects. Here we use another new objective <code>EmbeddedCollection_in_φh</code> that is similar to <code>EmbeddedCollection</code> except it does not cut the mesh and only expects recipes that take arguments in <code>φh</code>. This allows us to update the spaces and state maps whenever required. Note that this is different to how we usually setup these objects because we have to recreate the FE spaces and state maps at each iteration. This is because the active mesh for the unfitted discretisation is changing over the course of the level-set evolution. This new <code>state_collection</code> holds the state map, the objective as a <code>StateParamMap</code>, and set of <code>StateParamMap</code> for the constraints. This is given by the follow snippet</p><pre><code class="language-julia hljs">state_collection = EmbeddedCollection_in_φh(model,φh) do _φh
  update_collection!(Ωs,_φh)
  V = TestFESpace(Ωs.Ωact,reffe_scalar;dirichlet_tags=[&quot;Omega_D&quot;])
  U = TrialFESpace(V,0.0)
  state_map = AffineFEStateMap(a,l,U,V,V_φ,U_reg,_φh)
  (;
    :state_map =&gt; state_map,
    :J =&gt; StateParamMap(J,state_map),
    :C =&gt; map(Ci -&gt; StateParamMap(Ci,state_map),[Vol,])
  )
end</code></pre><p>Note that <code>StateParamMap</code> is a wrapper to handle partial differentation of a function in a <code>ChainRules.jl</code> compatible way with caching. See <a href="./../reference/statemaps.html#StateParamMap">this documentation</a> for further information.</p><p>Next, we create the <code>EmbeddedPDEConstrainedFunctionals</code>. This is similar to <code>PDEConstrainedFunctionals</code> except it takes <code>state_collection</code> as the argument and updates the unfitted triangulations where appropriate.</p><pre><code class="language-julia hljs">pcfs = EmbeddedPDEConstrainedFunctionals(state_collection;analytic_dC=(dVol,))</code></pre><h2 id="Evolution"><a class="docs-heading-anchor" href="#Evolution">Evolution</a><a id="Evolution-1"></a><a class="docs-heading-anchor-permalink" href="#Evolution" title="Permalink"></a></h2><p>We now define the evolution and reinitialisation methods for this problem. Here we use unfitted approaches to solve both of these problems</p><p>To set these up, we provide <code>CutFEMEvolve</code> and <code>StabilisedReinit</code> as follows:</p><pre><code class="language-julia hljs">evo = CutFEMEvolve(V_φ,Ωs,dΩ_bg,hₕ;max_steps,γg=0.1)
reinit = StabilisedReinit(V_φ,Ωs,dΩ_bg,hₕ;stabilisation_method=ArtificialViscosity(2.0))</code></pre><p>We then define the <code>UnfittedFEEvolution</code> object that wraps these methods, and we reinitialise our initial level-set function via</p><pre><code class="language-julia hljs">ls_evo = UnfittedFEEvolution(evo,reinit)
reinit!(ls_evo,φh)</code></pre><h2 id="Hilbertian-extension-regularisation-problems"><a class="docs-heading-anchor" href="#Hilbertian-extension-regularisation-problems">Hilbertian extension-regularisation problems</a><a id="Hilbertian-extension-regularisation-problems-1"></a><a class="docs-heading-anchor-permalink" href="#Hilbertian-extension-regularisation-problems" title="Permalink"></a></h2><p>The Hilbertian extension-regularisation approach projects a directional derivative <span>$\mathrm{d}J(\phi;w)$</span> of a functional <span>$J(\phi)$</span> onto a Hilbert space <span>$H$</span> on <span>$D$</span>, typically with additional regularity. This involves solving an identification problem: for Find <span>$g_\Omega\in H$</span> such that</p><p class="math-container">\[\langle g_\Omega,w\rangle_H=-\mathrm{d}J(\phi;w),~\forall w\in H,\]</p><p>where <span>$\langle\cdot,\cdot\rangle_H$</span> is the inner product on <span>$H$</span>. Here, we use <span>$H=H^1_{\Omega_D\cup\Gamma_N}(D)$</span> with the inner product</p><p class="math-container">\[    \langle u,v\rangle_{H}=\int_D\left(\alpha^2\boldsymbol{\nabla} u\cdot\boldsymbol{\nabla} v+uv\right)\mathrm{d}\boldsymbol{x}.\]</p><p>This is implemented as follows:</p><pre><code class="language-julia hljs">α = (α_coeff)^2*hₕ*hₕ
a_hilb(p,q) =∫(α*∇(p)⋅∇(q) + p*q)dΩ_bg;
vel_ext = VelocityExtension(a_hilb,U_reg,V_reg)</code></pre><h2 id="Optimiser-and-solution"><a class="docs-heading-anchor" href="#Optimiser-and-solution">Optimiser and solution</a><a id="Optimiser-and-solution-1"></a><a class="docs-heading-anchor-permalink" href="#Optimiser-and-solution" title="Permalink"></a></h2><p>Finally, for the optimiser we use the <code>AugmentedLagrangian</code> method with the convergence criteria below. In addition, we output data on the background mesh, along with the solution <span>$u_h$</span> on the unfitted triangulation. This is given by the following:</p><pre><code class="language-julia hljs">converged(m) = GridapTopOpt.default_al_converged(
  m;
  L_tol = 0.01*h,
  C_tol = 0.01
)
optimiser = AugmentedLagrangian(pcfs,ls_evo,vel_ext,φh;verbose=true,constraint_names=[:Vol],converged)
for (it,uh,φh) in optimiser
  if iszero(it % iter_mod)
    writevtk(Ω_bg,path*&quot;Omega$it&quot;,cellfields=[&quot;φ&quot;=&gt;φh,&quot;|∇(φ)|&quot;=&gt;(norm ∘ ∇(φh)),&quot;uh&quot;=&gt;uh,&quot;χ&quot;=&gt;Ωs.χ])
    writevtk(Ωs.Ωin,path*&quot;Omega_in$it&quot;,cellfields=[&quot;uh&quot;=&gt;uh])
  end
  write_history(path*&quot;/history.txt&quot;,optimiser.history)
end
it = get_history(optimiser).niter; uh = get_state(pcfs)
writevtk(Ω_bg,path*&quot;Omega$it&quot;,cellfields=[&quot;φ&quot;=&gt;φh,&quot;|∇(φ)|&quot;=&gt;(norm ∘ ∇(φh)),&quot;uh&quot;=&gt;uh,&quot;χ&quot;=&gt;Ωs.χ])
writevtk(Ωs.Ωin,path*&quot;Omega_in$it&quot;,cellfields=[&quot;uh&quot;=&gt;uh])</code></pre><p>Solving this problem results in the following iteration history:</p><p align="center">
<img src="../Unfitted-TO-with-Laplace-result.gif" width="300">
</p><p>The full script for this problem can be found in <code>scripts/Examples/Unfitted/Thermal2D_CutFEM.jl</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introductory examples</a><a class="docs-footer-nextpage" href="../Fluid-structure_interaction_with_CutFEM/">FSI with CutFEM »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.13.0 on <span class="colophon-date" title="Friday 4 July 2025 03:02">Friday 4 July 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
