<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Minimum thermal compliance · GridapTopOpt.jl</title><meta name="title" content="Minimum thermal compliance · GridapTopOpt.jl"/><meta property="og:title" content="Minimum thermal compliance · GridapTopOpt.jl"/><meta property="twitter:title" content="Minimum thermal compliance · GridapTopOpt.jl"/><meta name="description" content="Documentation for GridapTopOpt.jl."/><meta property="og:description" content="Documentation for GridapTopOpt.jl."/><meta property="twitter:description" content="Documentation for GridapTopOpt.jl."/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">GridapTopOpt.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><a class="tocitem" href="../../../getting-started/">Getting Started</a></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../../../reference/optimisers/">Optimisers</a></li><li><a class="tocitem" href="../../../reference/chainrules/">ChainRules</a></li><li><a class="tocitem" href="../../../reference/levelsetevolution/">LevelSetEvolution</a></li><li><a class="tocitem" href="../../../reference/velext/">Velocity extension</a></li><li><a class="tocitem" href="../../../reference/io/">IO</a></li><li><a class="tocitem" href="../../../reference/utilities/">Utilities</a></li><li><a class="tocitem" href="../../../reference/benchmarking/">Benchmarking</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Minimum thermal compliance</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Minimum thermal compliance</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/zjwegert/GridapTopOpt.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/zjwegert/GridapTopOpt.jl/blob/main/docs/src/deprecated/tutorials/minimum_thermal_compliance.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Minimum-thermal-compliance"><a class="docs-heading-anchor" href="#Minimum-thermal-compliance">Minimum thermal compliance</a><a id="Minimum-thermal-compliance-1"></a><a class="docs-heading-anchor-permalink" href="#Minimum-thermal-compliance" title="Permalink"></a></h1><p>The goal of this tutorial is to learn</p><ul><li>How to formulate a topology optimisation problem</li><li>How to describe the problem over a fixed computational domain <span>$D$</span> via the level-set method.</li><li>How to setup and solve the problem in GridapTopOpt</li></ul><p>We consider the following extensions at the end of the tutorial:</p><ul><li>How to extend problems to 3D and utilise PETSc solvers</li><li>How to solve problems with nonlinear state equations and use automatic differentiation</li><li>How to run problems in MPI mode</li></ul><p>We will first consider formulation of the state equations and a topology optimisation problem in a continuous setting. We will then discretise via a level set function in a fixed computational regime. Note that this approach corresponds to an &quot;optimise-then-discretise&quot; approach [4] where shape derivatives are calculated analytically in the continuous space then relaxed via a level set function <span>$\varphi$</span>. Automatic differentiation can be used to calculate these quantities and is discussed <a href="../../usage/ad/">here</a>.</p><h2 id="State-equations"><a class="docs-heading-anchor" href="#State-equations">State equations</a><a id="State-equations-1"></a><a class="docs-heading-anchor-permalink" href="#State-equations" title="Permalink"></a></h2><p>The homogeneous steady-state heat equation (equivalently Laplace&#39;s equation) is perhaps one of the most well-understood partial differential equations and usually the first introduced to an undergraduate student in applied mathematics. For this reason, we will use it to describe the heat transfer through a solid and how one comes to the notion of optimising the shape of that solid.</p><p>Consider the geometric conditions outlined in the Figure 1 and suppose that we prescribe the following conditions:</p><ul><li><em>Heat source</em>: unitary normal heat flow across <span>$\Gamma_{N}$</span>.</li><li><em>Insulating</em>: zero normal heat flow across <span>$\partial\Omega\setminus\Gamma_N$</span>,</li><li><em>Heat sink</em>: zero heat on <span>$\Gamma_D$</span>.</li></ul><table><tr><th style="text-align: center"><img src="../2d_min_thermal_comp_setup.png" alt/></th></tr><tr><td style="text-align: center">Figure 1: The setup for the two-dimensional minimum thermal compliance problem</td></tr></table><p>Physically we can imagine this as describing the transfer of heat through a domain <span>$\Omega$</span> from the sources to the sinks. From a mathematical perspective, we can write down the partial differential equations describing this as</p><p class="math-container">\[\begin{aligned}
-\nabla(\kappa\nabla u) &amp;= 0~\text{in }\Omega,\\
\kappa\nabla u\cdot\boldsymbol{n} &amp;= g~\text{on }\Gamma_N,\\
\kappa\nabla u\cdot\boldsymbol{n} &amp;= 0~\text{on }\partial\Omega\setminus\Gamma_N,\\
u &amp;= 0~\text{on }\Gamma_D.
\end{aligned}\]</p><p>where <span>$\kappa$</span> is the diffusivity through <span>$\Omega$</span> and <span>$\boldsymbol{n}$</span> is the unit normal on the boundary. The weak formulation of the above strong formulation can be found by multiplying by a test function <span>$v$</span> and applying integration by parts. This gives</p><p class="math-container">\[\begin{aligned}
&amp;\textit{Find }u\in H^1_{\Gamma_D}(\Omega)\textit{ such that}\\
&amp;\int_{\Omega}\kappa\boldsymbol{\nabla}u\cdot\boldsymbol{\nabla}v~\mathrm{d}\boldsymbol{x} = \int_{\Gamma_N}gv~\mathrm{d}s,~\forall v\in H^1_{\Gamma_D}(\Omega)
\end{aligned}\]</p><p>where <span>$H^1_{\Gamma_D}(\Omega)=\{v\in H^1(\Omega):~v=0\text{ on }\Gamma_D\}$</span>.</p><h2 id="Optimisation-problem"><a class="docs-heading-anchor" href="#Optimisation-problem">Optimisation problem</a><a id="Optimisation-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Optimisation-problem" title="Permalink"></a></h2><p>For this tutorial, we consider minimising the thermal compliance (or dissipated energy) as discussed in [1,2]. The corresponding optimisation problem is</p><p class="math-container">\[\begin{aligned}
\min_{\Omega\in\mathcal{U}}&amp;~J(\Omega)=\int_{\Omega}\kappa\lvert\boldsymbol{\nabla}u\rvert^2~\mathrm{d}\boldsymbol{x}\\
\text{s.t. }&amp;~\operatorname{Vol}(\Omega)=V_f,\\
&amp;\left\{
\begin{aligned}
&amp;\textit{Find }u\in H^1_{\Gamma_D}(\Omega)\textit{ such that}\\
&amp;\int_{\Omega}\kappa\boldsymbol{\nabla}u\cdot\boldsymbol{\nabla}v~\mathrm{d}\boldsymbol{x} = \int_{\Gamma_N}gv~\mathrm{d}s,~\forall v\in H^1_{\Gamma_D}(\Omega)
\end{aligned}
\right.
\end{aligned}\]</p><p>where <span>$\operatorname{Vol}(\Omega)=\int_\Omega1~\mathrm{d}\boldsymbol{x}$</span>. This objective is equivalent to equivalent to maximising the heat transfer efficiency through <span>$\Omega$</span>.</p><h2 id="Shape-differentiation"><a class="docs-heading-anchor" href="#Shape-differentiation">Shape differentiation</a><a id="Shape-differentiation-1"></a><a class="docs-heading-anchor-permalink" href="#Shape-differentiation" title="Permalink"></a></h2><p>We consider the change in quantities under the variation of the domain using <em>shape derivatives</em>. For the purpose of this tutorial we will give the mathematical description of a shape derivative along with the shape derivatives of the functionals <span>$J$</span> and <span>$\operatorname{Vol}$</span>. Further discussion can be found in [3,4].</p><p>Suppose that we consider smooth variations of the domain <span>$\Omega$</span> of the form <span>$\Omega_{\boldsymbol{\theta}} =(\boldsymbol{I}+\boldsymbol{\theta})(\Omega)$</span>, where <span>$\boldsymbol{\theta} \in W^{1,\infty}(\mathbb{R}^d,\mathbb{R}^d)$</span>. Then the following definition and lemma follow:</p><div class="admonition is-info"><header class="admonition-header">Definition [3]</header><div class="admonition-body"><p>The shape derivative of <span>$J(\Omega)$</span> at <span>$\Omega$</span> is defined as the Fréchet derivative in <span>$W^{1, \infty}(\mathbb{R}^d, \mathbb{R}^d)$</span> at <span>$\boldsymbol{\theta}$</span> of the application <span>$\boldsymbol{\theta} \rightarrow J(\Omega_{\boldsymbol{\theta}})$</span>, i.e.,</p><p class="math-container">\[J(\Omega_{\boldsymbol{\theta}})(\Omega)=J(\Omega)+J^{\prime}(\Omega)(\boldsymbol{\theta})+\mathrm{o}(\boldsymbol{\theta})\]</p><p>with <span>$\lim _{\boldsymbol{\theta} \rightarrow 0} \frac{\lvert\mathrm{o}(\boldsymbol{\theta})\rvert}{\|\boldsymbol{\theta}\|}=0,$</span> where the shape derivative <span>$J^{\prime}(\Omega)$</span> is a continuous linear form on <span>$W^{1, \infty}(\mathbb{R}^d, \mathbb{R}^d)$</span></p></div></div><p>The shape derivatives of <span>$J$</span> and <span>$\operatorname{Vol}$</span> are then</p><p class="math-container">\[J&#39;(\Omega)(\boldsymbol{\theta}) = -\int_{\Gamma}\kappa\boldsymbol{\nabla}(u)\cdot\boldsymbol{\nabla}(u)~\boldsymbol{\theta}\cdot\boldsymbol{n}~\mathrm{d}s\]</p><p>and</p><p class="math-container">\[\operatorname{Vol}&#39;(\Omega)(\boldsymbol{\theta}) = \int_{\Gamma}\boldsymbol{\theta}\cdot\boldsymbol{n}~\mathrm{d}s\]</p><p>where <span>$\Gamma = \partial\Omega\setminus(\Gamma_D\cup\Gamma_N)$</span>. The first of these follows from Céa&#39;s formal method (see discussion in [3,4]), while the latter result follows from application of Lemma 4 of [3]. Finally, taking a deformation field according to <span>$\boldsymbol{\theta}=-q\boldsymbol{n}$</span> amounts to a descent direction according to the definition above. This gives</p><p class="math-container">\[J&#39;(\Omega)(-q\boldsymbol{n}) = \int_{\Gamma}q\kappa\boldsymbol{\nabla}(u)\cdot\boldsymbol{\nabla}(u)~\mathrm{d}s\]</p><p>and</p><p class="math-container">\[\operatorname{Vol}&#39;(\Omega)(-q\boldsymbol{n}) = -\int_{\Gamma}q~\mathrm{d}s.\]</p><h2 id="Discretisation-via-a-level-set"><a class="docs-heading-anchor" href="#Discretisation-via-a-level-set">Discretisation via a level set</a><a id="Discretisation-via-a-level-set-1"></a><a class="docs-heading-anchor-permalink" href="#Discretisation-via-a-level-set" title="Permalink"></a></h2><p>Suppose that we attribute a level set function <span>$\varphi:D\rightarrow\mathbb{R}$</span> to our domain <span>$\Omega\subset D$</span> with <span>$\bar{\Omega}=\lbrace \boldsymbol{x}:\varphi(\boldsymbol{x})\leq0\rbrace$</span> and <span>$\Omega^\complement=\lbrace \boldsymbol{x}:\varphi(\boldsymbol{x})&gt;0\rbrace$</span>. We can then define a smooth characteristic function <span>$I:\mathbb{R}\rightarrow[\epsilon,1]$</span> as <span>$I(\varphi)=(1-H(\varphi))+\epsilon H(\varphi)$</span> where <span>$H$</span> is a smoothed Heaviside function with smoothing radius <span>$\eta$</span>, and <span>$\epsilon\ll1$</span> allows for an ersatz material approximation. Of course, <span>$\epsilon$</span> can be taken as zero depending on the computational regime. Over the fixed computational domain we may relax integrals to be over all of <span>$D$</span> via <span>$\mathrm{d}\boldsymbol{x}= H(\varphi)~\mathrm{d}\boldsymbol{x}$</span> and <span>$\mathrm{d}s = H&#39;(\varphi)\lvert\nabla\varphi\rvert~\mathrm{d}\boldsymbol{x}$</span>. The above optimisation problem then rewrites in terms of <span>$\varphi$</span> as</p><p class="math-container">\[\begin{aligned}
\min_{\varphi}&amp;~J(\varphi)=\int_{D}I(\varphi)\kappa\lvert\boldsymbol{\nabla}u\rvert^2~\mathrm{d}\boldsymbol{x}\\
\text{s.t. }&amp;~C(\varphi)=0,\\
&amp;\left\{
\begin{aligned}
&amp;\textit{Find }u\in H^1_{\Gamma_D}(D)\\
&amp;\int_{D}I(\varphi)\kappa\boldsymbol{\nabla}(u)\cdot\boldsymbol{\nabla}(v)~\mathrm{d}\boldsymbol{x} = \int_{\Gamma_N}v~\mathrm{d}s,~\forall v\in H^1_{\Gamma_D}(D)
\end{aligned}
\right.
\end{aligned}\]</p><p>where we retain an exact triangulation and measure of  <span>$\Gamma_N$</span> as this is a fixed boundary. In addition, we have rewritten the volume constraint as</p><p class="math-container">\[\begin{aligned}
C(\varphi)&amp;=\int_D (\rho(\varphi) - V_f)/\operatorname{Vol}(D)~\mathrm{d}\boldsymbol{x}\\
&amp;=\int_D \rho(\varphi)~\mathrm{d}\boldsymbol{x}/\operatorname{Vol}(D) - V_f\\
&amp;=\int_\Omega~\mathrm{d}\boldsymbol{x}/\operatorname{Vol}(D)-V_f = \operatorname{Vol}(\Omega)/\operatorname{Vol}(D)-V_f
\end{aligned}\]</p><p>where <span>$\rho(\varphi)=1-H(\varphi)$</span> is the smoothed volume density function.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In GridapTopOpt we assume constraints are of the integral form above.</p></div></div><p>The shape derivatives from the previous section can be relaxed over the computational domain as</p><p class="math-container">\[J&#39;(\varphi)(-q\boldsymbol{n}) = \int_{D}q\kappa\boldsymbol{\nabla}(u)\cdot\boldsymbol{\nabla}(u)H&#39;(\varphi)\lvert\nabla\varphi\rvert~\mathrm{d}\boldsymbol{x}\]</p><p>and</p><p class="math-container">\[C&#39;(\varphi)(-q\boldsymbol{n}) = -\int_{D}qH&#39;(\varphi)\lvert\nabla\varphi\rvert~\mathrm{d}\boldsymbol{x}/\operatorname{Vol}(D).\]</p><h2 id="Computational-method"><a class="docs-heading-anchor" href="#Computational-method">Computational method</a><a id="Computational-method-1"></a><a class="docs-heading-anchor-permalink" href="#Computational-method" title="Permalink"></a></h2><p>In the following, we discuss the implementation of the above optimisation problem in GridapTopOpt. For the purpose of this tutorial we break the computational formulation into chunks.</p><p>The first step in creating our script is to load any packages required:</p><pre><code class="language-julia hljs">using GridapTopOpt, Gridap</code></pre><h3 id="Parameters"><a class="docs-heading-anchor" href="#Parameters">Parameters</a><a id="Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Parameters" title="Permalink"></a></h3><p>The following are user defined parameters for the problem. These parameters will be discussed over the course of this tutorial.</p><pre><code class="language-julia hljs"># FE parameters
order = 1                                               # Finite element order
xmax = ymax = 1.0                                       # Domain size
dom = (0,xmax,0,ymax)                                   # Bounding domain
el_size = (200,200)                                     # Mesh partition size
prop_Γ_N = 0.2                                          # Γ_N size parameter
prop_Γ_D = 0.2                                          # Γ_D size parameter
f_Γ_N(x) = (x[1] ≈ xmax &amp;&amp;                              # Γ_N indicator function
  ymax/2-ymax*prop_Γ_N/2 - eps() &lt;= x[2] &lt;= ymax/2+ymax*prop_Γ_N/2 + eps())
f_Γ_D(x) = (x[1] ≈ 0.0 &amp;&amp;                               # Γ_D indicator function
  (x[2] &lt;= ymax*prop_Γ_D + eps() || x[2] &gt;= ymax-ymax*prop_Γ_D - eps()))
# FD parameters
γ = 0.1                                                 # HJ equation time step coefficient
γ_reinit = 0.5                                          # Reinit. equation time step coefficient
max_steps = floor(Int,minimum(el_size)/10)              # Max steps for advection
tol = 1/(5order^2)/minimum(el_size)                     # Advection tolerance
# Problem parameters
κ = 1                                                   # Diffusivity
g = 1                                                   # Heat flow in
vf = 0.4                                                # Volume fraction constraint
lsf_func = initial_lsf(4,0.2)                           # Initial level set function
iter_mod = 10                                           # Output VTK files every 10th iteration
path = &quot;./results/tut1/&quot;                                # Output path
mkpath(path)                                            # Create path</code></pre><h3 id="Finite-element-setup"><a class="docs-heading-anchor" href="#Finite-element-setup">Finite element setup</a><a id="Finite-element-setup-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-element-setup" title="Permalink"></a></h3><p>We first create a Cartesian mesh over <span>$[0,x_{\max}]\times[0,y_{\max}]$</span> with partition size <code>el_size</code> by creating an object <code>CartesianDiscreteModel</code>. In addition, we label the boundaries <span>$\Gamma_D$</span> and <span>$\Gamma_N$</span> using the <a href="../../../reference/utilities/#GridapTopOpt.update_labels!"><code>update_labels!</code></a> function.</p><pre><code class="language-julia hljs"># Model
model = CartesianDiscreteModel(dom,el_size);
update_labels!(1,model,f_Γ_D,&quot;Gamma_D&quot;)
update_labels!(2,model,f_Γ_N,&quot;Gamma_N&quot;)</code></pre><p>The first argument of <a href="../../../reference/utilities/#GridapTopOpt.update_labels!"><code>update_labels!</code></a> indicates the label number associated to the region as indicated by the functions <code>f_Γ_D</code> and <code>f_Γ_N</code>. These functions should take a vector <code>x</code> and return <code>true</code> or <code>false</code> depending on whether a point is present in this region.</p><p>Once the model is defined we create an integration mesh and measure for both <span>$\Omega$</span> and <span>$\Gamma_N$</span>. These are built using</p><pre><code class="language-julia hljs"># Triangulation and measures
Ω = Triangulation(model)
Γ_N = BoundaryTriangulation(model,tags=&quot;Gamma_N&quot;)
dΩ = Measure(Ω,2*order)
dΓ_N = Measure(Γ_N,2*order)</code></pre><p>where <code>2*order</code> indicates the quadrature degree for numerical integration.</p><p>The final stage of the finite element setup is the approximation of the finite element spaces. This is given as follows:</p><pre><code class="language-julia hljs"># Spaces
reffe = ReferenceFE(lagrangian,Float64,order)
V = TestFESpace(model,reffe;dirichlet_tags=[&quot;Gamma_D&quot;])
U = TrialFESpace(V,0.0)
V_φ = TestFESpace(model,reffe)
V_reg = TestFESpace(model,reffe;dirichlet_tags=[&quot;Gamma_N&quot;])
U_reg = TrialFESpace(V_reg,0)</code></pre><p>In the above, we first define a scalar-valued Lagrangian reference element. This is then used to define the test space <code>V</code> and trial space <code>U</code> corresponding to <span>$H^1_{\Gamma_{D}}(\Omega)$</span>. We then construct an FE space <code>V_φ</code> over which the level set function is defined, along with an FE test space <code>V_reg</code> and trial space <code>U_reg</code> over which derivatives are defined. We require that <code>V_reg</code> and <code>U_reg</code> have zero Dirichlet boundary conditions over regions where the extended shape sensitivity is zero. In general, we allow Dirichlet boundaries to have non-zero shape sensitivity.</p><h3 id="Initial-level-set-function-and-interpolant"><a class="docs-heading-anchor" href="#Initial-level-set-function-and-interpolant">Initial level set function and interpolant</a><a id="Initial-level-set-function-and-interpolant-1"></a><a class="docs-heading-anchor-permalink" href="#Initial-level-set-function-and-interpolant" title="Permalink"></a></h3><p>We interpolate an initial level set function onto <code>V_φ</code> given a function <code>lsf_func</code> using the <code>interpolate</code> provided by Gridap.</p><pre><code class="language-julia hljs"># Level set and interpolator
φh = interpolate(lsf_func,V_φ)</code></pre><p>For this problem we set <code>lsf_func</code> using the function <a href="../../../reference/utilities/#GridapTopOpt.initial_lsf"><code>initial_lsf</code></a> in the problem parameters. This generates an initial level set according to</p><p class="math-container">\[\varphi_{\xi,a}(\boldsymbol{x})=-\frac{1}{4} \prod_i^D(\cos(\xi\pi x_i)) - a/4\]</p><p>with <span>$\xi,a=(4,0.2)$</span> and <span>$D=2$</span> in two dimensions.</p><p>We also generate a smooth characteristic function of radius <span>$\eta$</span> using:</p><pre><code class="language-julia hljs">interp = SmoothErsatzMaterialInterpolation(η = 2*maximum(get_el_Δ(model)))
I,H,DH,ρ = interp.I,interp.H,interp.DH,interp.ρ</code></pre><p>This the <a href="../../../reference/utilities/#GridapTopOpt.SmoothErsatzMaterialInterpolation"><code>SmoothErsatzMaterialInterpolation</code></a> structure defines the characteristic or interpolator <code>I</code>, the smoothed Heaviside function <code>H</code> and it&#39;s derivative <code>DH</code>, and the smoothed density function <code>ρ</code>. Below we visualise <code>φh</code> and the smoothed density function <code>ρ</code> at <code>φh</code>:</p><table><tr><th style="text-align: center"><img src="../2d_min_thermal_comp_initial_lsf_combined.png" alt/></th></tr><tr><td style="text-align: center">Figure 2: A visualisation of the initial level set function and the interpolated density function <span>$\rho$</span> for <span>$\Omega$</span>.</td></tr></table><p>Optional: we can generate a VTK file for visualisation in Paraview via</p><pre><code class="language-julia hljs">writevtk(Ω,&quot;initial_lsf&quot;,cellfields=[&quot;phi&quot;=&gt;φh,
  &quot;ρ(phi)&quot;=&gt;(ρ ∘ φh),&quot;|nabla(phi)|&quot;=&gt;(norm ∘ ∇(φh))])</code></pre><p>Note that the operator <code>∘</code> is used to compose other Julia <code>Functions</code> with Gridap <code>FEFunctions</code>. This will be used extensively as we progress through the tutorial.</p><h3 id="Weak-formulation-and-the-state-map"><a class="docs-heading-anchor" href="#Weak-formulation-and-the-state-map">Weak formulation and the state map</a><a id="Weak-formulation-and-the-state-map-1"></a><a class="docs-heading-anchor-permalink" href="#Weak-formulation-and-the-state-map" title="Permalink"></a></h3><p>The weak formulation for the problem above can be written as</p><pre><code class="language-julia hljs"># Weak formulation
a(u,v,φ,dΩ,dΓ_N) = ∫((I ∘ φ)*κ*∇(u)⋅∇(v))dΩ
l(v,φ,dΩ,dΓ_N) = ∫(g*v)dΓ_N</code></pre><p>where the <code>∘</code> operator composes the interpolator <code>I</code> with the level set function <code>φ</code>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The measures must be included as arguments at the end of all functionals. This ensures compatibility with Gridap&#39;s automatic differentiation.</p></div></div><p>At this point we can build an <a href="../../../reference/chainrules/#AffineFEStateMap"><code>AffineFEStateMap</code></a>. This structure is designed to</p><ol><li>Enable the forward problem that solves a Gridap <code>AffineFEOperator</code>; and</li><li>Encode the implicit dependence of the solution <code>u</code> on the level set function <code>φ</code> to enable the differentiation of <code>u</code>.</li></ol><pre><code class="nohighlight hljs">state_map = AffineFEStateMap(a,l,U,V,V_φ,U_reg,φh,dΩ,dΓ_N)</code></pre><h3 id="Optimisation-functionals"><a class="docs-heading-anchor" href="#Optimisation-functionals">Optimisation functionals</a><a id="Optimisation-functionals-1"></a><a class="docs-heading-anchor-permalink" href="#Optimisation-functionals" title="Permalink"></a></h3><p>The objective functional <span>$J$</span> and it&#39;s shape derivative is given by</p><pre><code class="language-julia hljs"># Objective and constraints
J(u,φ,dΩ,dΓ_N) = ∫((I ∘ φ)*κ*∇(u)⋅∇(u))dΩ
dJ(q,u,φ,dΩ,dΓ_N) = ∫(κ*∇(u)⋅∇(u)*q*(DH ∘ φ)*(norm ∘ ∇(φ)))dΩ</code></pre><p>while the constraint on the volume and its derivative is</p><pre><code class="language-julia hljs">vol_D = sum(∫(1)dΩ)
C(u,φ,dΩ,dΓ_N) = ∫(((ρ ∘ φ) - vf)/vol_D)dΩ
dC(q,u,φ,dΩ,dΓ_N) = ∫(-1/vol_D*q*(DH ∘ φ)*(norm ∘ ∇(φ)))dΩ</code></pre><p>We can now create an object <a href="../../../reference/chainrules/#PDEConstrainedFunctionals"><code>PDEConstrainedFunctionals</code></a> that handles the objective and constraints, and their analytic or automatic differentiation.</p><pre><code class="language-julia hljs">pcfs = PDEConstrainedFunctionals(J,[C],state_map,analytic_dJ=dJ,analytic_dC=[dC])</code></pre><p>In this case, the analytic shape derivatives are passed as optional arguments. When these are not given, automatic differentiation in <span>$φ$</span> is used.</p><h3 id="Velocity-extension-regularisation-method"><a class="docs-heading-anchor" href="#Velocity-extension-regularisation-method">Velocity extension-regularisation method</a><a id="Velocity-extension-regularisation-method-1"></a><a class="docs-heading-anchor-permalink" href="#Velocity-extension-regularisation-method" title="Permalink"></a></h3><p>The Hilbertian extension-regularisation [4] method involves solving an identification problem over a Hilbert space <span>$H$</span> on <span>$D$</span> with inner product <span>$\langle\cdot,\cdot\rangle_H$</span>: <em>Find</em> <span>$g_\Omega\in H$</span> <em>such that</em> <span>$\langle g_\Omega,q\rangle_H =-J^{\prime}(\Omega)(q\boldsymbol{n})~ \forall q\in H.$</span></p><p>This provides two benefits:</p><ol><li>It naturally extends the shape sensitivity from <span>$\partial\Omega$</span> onto the bounding domain <span>$D$</span>; and</li><li>ensures a descent direction for <span>$J(\Omega)$</span> with additional regularity (i.e., <span>$H$</span> as opposed to <span>$L^2(\partial\Omega)$</span>).</li></ol><p>For our problem above we take the inner product</p><p class="math-container">\[\langle p,q\rangle_H=\int_{D}\alpha^2\nabla(p)\nabla(q)+pq~\mathrm{d}\boldsymbol{x},\]</p><p>where <span>$\alpha$</span> is the smoothing length scale. Equivalently in our script we have</p><pre><code class="language-julia hljs"># Velocity extension
α = 4*maximum(get_el_Δ(model))
a_hilb(p,q) =∫(α^2*∇(p)⋅∇(q) + p*q)dΩ</code></pre><p>We then build an object <a href="../../../reference/velext/#GridapTopOpt.VelocityExtension"><code>VelocityExtension</code></a>. This object provides a method <a href="../../../reference/velext/#GridapTopOpt.project!-Tuple{VelocityExtension, AbstractVector}"><code>project!</code></a> that applies the Hilbertian velocity-extension method to a given shape derivative.</p><pre><code class="language-julia hljs">vel_ext = VelocityExtension(a_hilb,U_reg,V_reg)</code></pre><h3 id="Advection-and-reinitialisation"><a class="docs-heading-anchor" href="#Advection-and-reinitialisation">Advection and reinitialisation</a><a id="Advection-and-reinitialisation-1"></a><a class="docs-heading-anchor-permalink" href="#Advection-and-reinitialisation" title="Permalink"></a></h3><p>To advect the level set function, we solve the Hamilton-Jacobi evolution equation [3,4,5]. This is given by</p><p class="math-container">\[\frac{\partial\phi}{\partial t} + V(\boldsymbol{x})\lVert\boldsymbol{\nabla}\phi\rVert = 0,\]</p><p>with <span>$\phi(0,\boldsymbol{x})=\phi_0(\boldsymbol{x})$</span> and <span>$\boldsymbol{x}\in D,~t\in(0,T)$</span>.</p><p>After advection of the interface, we solve the reinitialisation equation to find an equivalent signed distance function for the given level set function. This is given by</p><p class="math-container">\[\frac{\partial\phi}{\partial t} + \mathrm{sign}(\phi_0)(\lVert\boldsymbol{\nabla}\phi\rVert-1) = 0,\]</p><p>with <span>$\phi(0,\boldsymbol{x})=\phi_0(\boldsymbol{x})$</span> and <span>$\boldsymbol{x}\in D,~t\in(0,T)$</span>.</p><p>Both of these equations can be solved numerically on a Cartesian mesh using a first order Godunov upwind difference scheme based on [5]. This functionality is provided by the following objects:</p><pre><code class="language-julia hljs"># Finite difference scheme
scheme = FirstOrderStencil(length(el_size),Float64)
ls_evo = HamiltonJacobiEvolution(scheme,model,V_φ,tol,max_steps)</code></pre><p>In the above we first build an object <a href="../../../reference/levelsetevolution/#GridapTopOpt.FirstOrderStencil"><code>FirstOrderStencil</code></a> that represents a finite difference stencil for a single step of the Hamilton-Jacobi evolution equation and reinitialisation equation. We use <code>length(el_size)</code> to indicate the dimension of the problem. We then create an <a href="../../../reference/levelsetevolution/#HamiltonJacobiEvolution"><code>HamiltonJacobiEvolution</code></a> which enables finite differencing on order <code>O</code> finite elements in serial or parallel. The <a href="../../../reference/levelsetevolution/#HamiltonJacobiEvolution"><code>HamiltonJacobiEvolution</code></a> object provides two important methods <a href="../../../reference/levelsetevolution/#GridapTopOpt.evolve!"><code>evolve!</code></a> and <a href="../../../reference/levelsetevolution/#GridapTopOpt.reinit!"><code>reinit!</code></a> that correspond to solving the Hamilton-Jacobi evolution equation and reinitialisation equation, respectively.</p><h3 id="Optimiser,-visualisation-and-IO"><a class="docs-heading-anchor" href="#Optimiser,-visualisation-and-IO">Optimiser, visualisation and IO</a><a id="Optimiser,-visualisation-and-IO-1"></a><a class="docs-heading-anchor-permalink" href="#Optimiser,-visualisation-and-IO" title="Permalink"></a></h3><p>We may now create the optimiser object. This structure holds all information regarding the optimisation problem that we wish to solve and implements an optimisation algorithm as a Julia <a href="https://docs.julialang.org/en/v1/manual/interfaces/">iterator</a>. For the purpose of this tutorial we use a standard augmented Lagrangian method based on [6]. In our script, we create an instance of the <a href="../../../reference/optimisers/#GridapTopOpt.AugmentedLagrangian"><code>AugmentedLagrangian</code></a> via</p><pre><code class="language-julia hljs"># Optimiser
optimiser = AugmentedLagrangian(pcfs,ls_evo,vel_ext,φh;γ,γ_reinit,verbose=true,constraint_names=[:Vol])</code></pre><p>As optimisers inheriting from <a href="../../../reference/optimisers/#GridapTopOpt.Optimiser"><code>GridapTopOpt.Optimiser</code></a> implement Julia&#39;s iterator functionality, we can solve the optimisation problem to convergence by iterating over the optimiser:</p><pre><code class="language-julia hljs"># Solve
for (it,uh,φh) in optimiser end</code></pre><p>This allows the user to inject code between iterations. For example, we can write VTK files for visualisation and save the history using the following:</p><pre><code class="language-julia hljs"># Solve
for (it,uh,φh) in optimiser
  data = [&quot;phi&quot;=&gt;φh,&quot;H(phi)&quot;=&gt;(H ∘ φh),&quot;|nabla(phi)|&quot;=&gt;(norm ∘ ∇(φh)),&quot;uh&quot;=&gt;uh]
  iszero(it % iter_mod) &amp;&amp; (writevtk(Ω,path*&quot;struc_$it&quot;,cellfields=data);GC.gc())
  write_history(path*&quot;/history.txt&quot;,get_history(optimiser))
end</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Due to a possible memory leak in Julia 1.9.* IO, we include a call to the garbage collector using <code>GC.gc()</code>.</p></div></div><p>Depending on whether we use <code>iszero(it % iter_mod)</code>, the VTK file for the final structure may need to be saved using</p><pre><code class="language-julia hljs"># Final structure
it = get_history(optimiser).niter; uh = get_state(pcfs)
writevtk(Ω,path*&quot;_$it&quot;,cellfields=[&quot;phi&quot;=&gt;φh,
  &quot;H(phi)&quot;=&gt;(H ∘ φh),&quot;|nabla(phi)|&quot;=&gt;(norm ∘ ∇(φh)),&quot;uh&quot;=&gt;uh])</code></pre><h3 id="The-full-script"><a class="docs-heading-anchor" href="#The-full-script">The full script</a><a id="The-full-script-1"></a><a class="docs-heading-anchor-permalink" href="#The-full-script" title="Permalink"></a></h3><details><summary>Script 1: combining the above gives (click me!)</summary><pre><code class="language-julia hljs">using Gridap, GridapTopOpt

# FE parameters
order = 1                                               # Finite element order
xmax = ymax = 1.0                                       # Domain size
dom = (0,xmax,0,ymax)                                   # Bounding domain
el_size = (200,200)                                     # Mesh partition size
prop_Γ_N = 0.2                                          # Γ_N size parameter
prop_Γ_D = 0.2                                          # Γ_D size parameter
f_Γ_N(x) = (x[1] ≈ xmax &amp;&amp;                              # Γ_N indicator function
  ymax/2-ymax*prop_Γ_N/2 - eps() &lt;= x[2] &lt;= ymax/2+ymax*prop_Γ_N/2 + eps())
f_Γ_D(x) = (x[1] ≈ 0.0 &amp;&amp;                               # Γ_D indicator function
  (x[2] &lt;= ymax*prop_Γ_D + eps() || x[2] &gt;= ymax-ymax*prop_Γ_D - eps()))
# FD parameters
γ = 0.1                                                 # HJ equation time step coefficient
γ_reinit = 0.5                                          # Reinit. equation time step coefficient
max_steps = floor(Int,minimum(el_size)/10)              # Max steps for advection
tol = 1/(5order^2)/minimum(el_size)          # Advection tolerance
# Problem parameters
κ = 1                                                   # Diffusivity
g = 1                                                   # Heat flow in
vf = 0.4                                                # Volume fraction constraint
lsf_func = initial_lsf(4,0.2)                           # Initial level set function
iter_mod = 10                                           # Output VTK files every 10th iteration
path = &quot;./results/tut1/&quot;                                # Output path
mkpath(path)                                            # Create path
# Model
model = CartesianDiscreteModel(dom,el_size);
update_labels!(1,model,f_Γ_D,&quot;Gamma_D&quot;)
update_labels!(2,model,f_Γ_N,&quot;Gamma_N&quot;)
# Triangulation and measures
Ω = Triangulation(model)
Γ_N = BoundaryTriangulation(model,tags=&quot;Gamma_N&quot;)
dΩ = Measure(Ω,2*order)
dΓ_N = Measure(Γ_N,2*order)
# Spaces
reffe = ReferenceFE(lagrangian,Float64,order)
V = TestFESpace(model,reffe;dirichlet_tags=[&quot;Gamma_D&quot;])
U = TrialFESpace(V,0.0)
V_φ = TestFESpace(model,reffe)
V_reg = TestFESpace(model,reffe;dirichlet_tags=[&quot;Gamma_N&quot;])
U_reg = TrialFESpace(V_reg,0)
# Level set and interpolator
φh = interpolate(lsf_func,V_φ)
interp = SmoothErsatzMaterialInterpolation(η = 2*maximum(get_el_Δ(model)))
I,H,DH,ρ = interp.I,interp.H,interp.DH,interp.ρ
# Weak formulation
a(u,v,φ,dΩ,dΓ_N) = ∫((I ∘ φ)*κ*∇(u)⋅∇(v))dΩ
l(v,φ,dΩ,dΓ_N) = ∫(g*v)dΓ_N
state_map = AffineFEStateMap(a,l,U,V,V_φ,U_reg,φh,dΩ,dΓ_N)
# Objective and constraints
J(u,φ,dΩ,dΓ_N) = ∫((I ∘ φ)*κ*∇(u)⋅∇(u))dΩ
dJ(q,u,φ,dΩ,dΓ_N) = ∫(κ*∇(u)⋅∇(u)*q*(DH ∘ φ)*(norm ∘ ∇(φ)))dΩ
vol_D = sum(∫(1)dΩ)
C(u,φ,dΩ,dΓ_N) = ∫(((ρ ∘ φ) - vf)/vol_D)dΩ
dC(q,u,φ,dΩ,dΓ_N) = ∫(-1/vol_D*q*(DH ∘ φ)*(norm ∘ ∇(φ)))dΩ
pcfs = PDEConstrainedFunctionals(J,[C],state_map,analytic_dJ=dJ,analytic_dC=[dC])
# Velocity extension
α = 4*maximum(get_el_Δ(model))
a_hilb(p,q) =∫(α^2*∇(p)⋅∇(q) + p*q)dΩ
vel_ext = VelocityExtension(a_hilb,U_reg,V_reg)
# Finite difference scheme
scheme = FirstOrderStencil(length(el_size),Float64)
ls_evo = HamiltonJacobiEvolution(scheme,model,V_φ,tol,max_steps)
# Optimiser
optimiser = AugmentedLagrangian(pcfs,ls_evo,vel_ext,φh;γ,γ_reinit,verbose=true,constraint_names=[:Vol])
# Solve
for (it,uh,φh) in optimiser
  data = [&quot;phi&quot;=&gt;φh,&quot;H(phi)&quot;=&gt;(H ∘ φh),&quot;|nabla(phi)|&quot;=&gt;(norm ∘ ∇(φh)),&quot;uh&quot;=&gt;uh]
  iszero(it % iter_mod) &amp;&amp; (writevtk(Ω,path*&quot;struc_$it&quot;,cellfields=data);GC.gc())
  write_history(path*&quot;/history.txt&quot;,get_history(optimiser))
end
# Final structure
it = get_history(optimiser).niter; uh = get_state(pcfs)
writevtk(Ω,path*&quot;struc_$it&quot;,cellfields=[&quot;phi&quot;=&gt;φh,
  &quot;H(phi)&quot;=&gt;(H ∘ φh),&quot;|nabla(phi)|&quot;=&gt;(norm ∘ ∇(φh)),&quot;uh&quot;=&gt;uh])</code></pre></details><p>Running this problem until convergence gives a final result of</p><pre><code class="nohighlight hljs">Iteration: 102 | L=1.1256e-01, J=1.1264e-01, Vol=-3.6281e-04, γ=5.6250e-02</code></pre><p>with the optimised domain <span>$\Omega$</span> given by</p><table><tr><th style="text-align: center"><img src="../2d_min_thermal_comp_final_struc.png" alt/></th></tr><tr><td style="text-align: center">Figure 3: Visualisation of <span>$\Omega$</span> using the isovolume with <span>$\varphi\leq0$</span>.</td></tr></table><h2 id="Extensions"><a class="docs-heading-anchor" href="#Extensions">Extensions</a><a id="Extensions-1"></a><a class="docs-heading-anchor-permalink" href="#Extensions" title="Permalink"></a></h2><p>In the following we outline several extensions to the avoid optimisation problem.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>We assume that PETSc and MPI have been installed correctly. Please see <a href="../../usage/petsc/">PETSc instructions</a> and <a href="../../usage/mpi-mode/">MPI instructions</a> for additional information.</p></div></div><h3 id="3D-with-PETSc"><a class="docs-heading-anchor" href="#3D-with-PETSc">3D with PETSc</a><a id="3D-with-PETSc-1"></a><a class="docs-heading-anchor-permalink" href="#3D-with-PETSc" title="Permalink"></a></h3><p>The first and most straightforward in terms of programmatic changes is extending the problem to 3D. For this extension, we consider the following setup for the boundary conditions:</p><table><tr><th style="text-align: center"><img src="../3d_min_thermal_comp.png" alt/></th></tr><tr><td style="text-align: center">Figure 4: The setup for the three-dimensional minimum thermal compliance problem.</td></tr></table><p>We use a unit cube for the bounding domain <span>$D$</span> with <span>$50^3$</span> elements. This corresponds to changing lines 5-7 in the above script to</p><pre><code class="language-julia hljs">xmax=ymax=zmax=1.0                                      # Domain size
dom = (0,xmax,0,ymax,0,zmax)                            # Bounding domain
el_size = (100,100,100)                                 # Mesh partition size</code></pre><p>To apply the boundary conditions per Figure 4, we also adjust the boundary indicator functions on lines 10-13 to</p><pre><code class="language-julia hljs">f_Γ_N(x) = (x[1] ≈ xmax) &amp;&amp;                             # Γ_N indicator function
  (ymax/2-ymax*prop_Γ_N/2 - eps() &lt;= x[2] &lt;= ymax/2+ymax*prop_Γ_N/2 + eps()) &amp;&amp;
  (zmax/2-zmax*prop_Γ_N/2 - eps() &lt;= x[3] &lt;= zmax/2+zmax*prop_Γ_N/2 + eps())
f_Γ_D(x) = (x[1] ≈ 0.0) &amp;&amp;                              # Γ_D indicator function
  (x[2] &lt;= ymax*prop_Γ_D + eps() || x[2] &gt;= ymax-ymax*prop_Γ_D - eps()) &amp;&amp;
  (x[3] &lt;= zmax*prop_Γ_D + eps() || x[3] &gt;= zmax-zmax*prop_Γ_D - eps())</code></pre><p>We adjust the output path on line 25 to be</p><pre><code class="language-julia hljs">path = &quot;./results/tut1_3d/&quot;                             # Output path</code></pre><p>Finally, we adjust the finite difference parameters on lines 17-18 to</p><pre><code class="language-julia hljs">max_steps = floor(Int,minimum(el_size)/3)               # Max steps for advection
tol = 1/(2order^2)/minimum(el_size)           # Advection tolerance</code></pre><details><summary>Script 2: combining the above gives (click me!)</summary><pre><code class="language-julia hljs">using Gridap, GridapTopOpt

# FE parameters
order = 1                                               # Finite element order
xmax=ymax=zmax=1.0                                      # Domain size
dom = (0,xmax,0,ymax,0,zmax)                            # Bounding domain
el_size = (100,100,100)                                 # Mesh partition size
prop_Γ_N = 0.2                                          # Γ_N size parameter
prop_Γ_D = 0.2                                          # Γ_D size parameter
f_Γ_N(x) = (x[1] ≈ xmax) &amp;&amp;                             # Γ_N indicator function
  (ymax/2-ymax*prop_Γ_N/2 - eps() &lt;= x[2] &lt;= ymax/2+ymax*prop_Γ_N/2 + eps()) &amp;&amp;
  (zmax/2-zmax*prop_Γ_N/2 - eps() &lt;= x[3] &lt;= zmax/2+zmax*prop_Γ_N/2 + eps())
f_Γ_D(x) = (x[1] ≈ 0.0) &amp;&amp;                              # Γ_D indicator function
  (x[2] &lt;= ymax*prop_Γ_D + eps() || x[2] &gt;= ymax-ymax*prop_Γ_D - eps()) &amp;&amp;
  (x[3] &lt;= zmax*prop_Γ_D + eps() || x[3] &gt;= zmax-zmax*prop_Γ_D - eps())
# FD parameters
γ = 0.1                                                 # HJ equation time step coefficient
γ_reinit = 0.5                                          # Reinit. equation time step coefficient
max_steps = floor(Int,minimum(el_size)/3)               # Max steps for advection
tol = 1/(2order^2)/minimum(el_size)           # Advection tolerance
# Problem parameters
κ = 1                                                   # Diffusivity
g = 1                                                   # Heat flow in
vf = 0.4                                                # Volume fraction constraint
lsf_func = initial_lsf(4,0.2)                           # Initial level set function
iter_mod = 10                                           # Output VTK files every 10th iteration
path = &quot;./results/tut1_3d/&quot;                             # Output path
mkpath(path)                                            # Create path
# Model
model = CartesianDiscreteModel(dom,el_size);
update_labels!(1,model,f_Γ_D,&quot;Gamma_D&quot;)
update_labels!(2,model,f_Γ_N,&quot;Gamma_N&quot;)
# Triangulation and measures
Ω = Triangulation(model)
Γ_N = BoundaryTriangulation(model,tags=&quot;Gamma_N&quot;)
dΩ = Measure(Ω,2*order)
dΓ_N = Measure(Γ_N,2*order)
# Spaces
reffe = ReferenceFE(lagrangian,Float64,order)
V = TestFESpace(model,reffe;dirichlet_tags=[&quot;Gamma_D&quot;])
U = TrialFESpace(V,0.0)
V_φ = TestFESpace(model,reffe)
V_reg = TestFESpace(model,reffe;dirichlet_tags=[&quot;Gamma_N&quot;])
U_reg = TrialFESpace(V_reg,0)
# Level set and interpolator
φh = interpolate(lsf_func,V_φ)
interp = SmoothErsatzMaterialInterpolation(η = 2*maximum(get_el_Δ(model)))
I,H,DH,ρ = interp.I,interp.H,interp.DH,interp.ρ
# Weak formulation
a(u,v,φ,dΩ,dΓ_N) = ∫((I ∘ φ)*κ*∇(u)⋅∇(v))dΩ
l(v,φ,dΩ,dΓ_N) = ∫(g*v)dΓ_N
state_map = AffineFEStateMap(a,l,U,V,V_φ,U_reg,φh,dΩ,dΓ_N)
# Objective and constraints
J(u,φ,dΩ,dΓ_N) = ∫((I ∘ φ)*κ*∇(u)⋅∇(u))dΩ
dJ(q,u,φ,dΩ,dΓ_N) = ∫(κ*∇(u)⋅∇(u)*q*(DH ∘ φ)*(norm ∘ ∇(φ)))dΩ
vol_D = sum(∫(1)dΩ)
C(u,φ,dΩ,dΓ_N) = ∫(((ρ ∘ φ) - vf)/vol_D)dΩ
dC(q,u,φ,dΩ,dΓ_N) = ∫(-1/vol_D*q*(DH ∘ φ)*(norm ∘ ∇(φ)))dΩ
pcfs = PDEConstrainedFunctionals(J,[C],state_map,analytic_dJ=dJ,analytic_dC=[dC])
# Velocity extension
α = 4*maximum(get_el_Δ(model))
a_hilb(p,q) =∫(α^2*∇(p)⋅∇(q) + p*q)dΩ
vel_ext = VelocityExtension(a_hilb,U_reg,V_reg)
# Finite difference scheme
scheme = FirstOrderStencil(length(el_size),Float64)
ls_evo = HamiltonJacobiEvolution(scheme,model,V_φ,tol,max_steps)
# Optimiser
optimiser = AugmentedLagrangian(pcfs,ls_evo,vel_ext,φh;γ,γ_reinit,verbose=true,constraint_names=[:Vol])
# Solve
for (it,uh,φh) in optimiser
  data = [&quot;phi&quot;=&gt;φh,&quot;H(phi)&quot;=&gt;(H ∘ φh),&quot;|nabla(phi)|&quot;=&gt;(norm ∘ ∇(φh)),&quot;uh&quot;=&gt;uh]
  iszero(it % iter_mod) &amp;&amp; (writevtk(Ω,path*&quot;struc_$it&quot;,cellfields=data);GC.gc())
  write_history(path*&quot;/history.txt&quot;,get_history(optimiser))
end
# Final structure
it = get_history(optimiser).niter; uh = get_state(pcfs)
writevtk(Ω,path*&quot;struc_$it&quot;,cellfields=[&quot;phi&quot;=&gt;φh,
  &quot;H(phi)&quot;=&gt;(H ∘ φh),&quot;|nabla(phi)|&quot;=&gt;(norm ∘ ∇(φh)),&quot;uh&quot;=&gt;uh])</code></pre></details><p>At this stage the problem will not be possible to run as we&#39;re using a standard LU solver. For this reason we now consider adjusting Script 2 to use an iterative solver provided by PETSc. We rely on the GridapPETSc satellite package to utilise PETSc. This provides the necessary structures to efficiently interface with the linear and nonlinear solvers provided by the PETSc library. To call GridapPETSc we change line 1 of Script 2 to</p><pre><code class="language-julia hljs">using Gridap, GridapPETSc, SparseMatricesCSR, GridapTopOpt</code></pre><p>We also use <code>SparseMatricesCSR</code> as PETSc is based on the <code>SparseMatrixCSR</code> datatype. We then replace line 52 and 63 with</p><pre><code class="language-julia hljs"># State map
Tm = SparseMatrixCSR{0,PetscScalar,PetscInt}
Tv = Vector{PetscScalar}
state_map = AffineFEStateMap(
  a,l,U,V,V_φ,U_reg,φh,dΩ,dΓ_N;
  assem_U = SparseMatrixAssembler(Tm,Tv,U,V),
  assem_adjoint = SparseMatrixAssembler(Tm,Tv,V,U),
  assem_deriv = SparseMatrixAssembler(Tm,Tv,U_reg,U_reg),
  ls = PETScLinearSolver(),adjoint_ls = PETScLinearSolver()
)</code></pre><p>and</p><pre><code class="language-julia hljs">vel_ext = VelocityExtension(
    a_hilb, U_reg, V_reg;
    assem = SparseMatrixAssembler(Tm,Tv,U_reg,V_reg),
    ls = PETScLinearSolver()
  )</code></pre><p>respectively. Here we specify that the <code>SparseMatrixAssembler</code> should be based on the <code>SparseMatrixCSR</code> datatype along with the globals <code>PetscScalar</code> and <code>PetscInt</code>. We then set the linear solver, adjoint solver, and linear solver for the velocity extension to be the <code>PETScLinearSolver()</code>. The <code>PETScLinearSolver</code> is a wrapper for the PETSc solver as specified by the solver options (see below).</p><p>Finally, we wrap the entire script in a function and call it inside a <code>GridapPETSc.with</code> block. This ensures that PETSc is safely initialised. This should take the form</p><pre><code class="language-Julia hljs">using Gridap, GridapPETSc, SparseMatricesCSR, GridapTopOpt

function main()
  ...
end

solver_options = &quot;-pc_type gamg -ksp_type cg -ksp_error_if_not_converged true
  -ksp_converged_reason -ksp_rtol 1.0e-12&quot;
GridapPETSc.with(args=split(solver_options)) do
  main()
end</code></pre><p>We utilise a conjugate gradient method with geometric algebraic multigrid preconditioner using the <code>solver_options</code> string. This should match the PETSc database keys (see <a href="https://petsc.org/release/manual/ksp/#ch-ksp">documentation</a>).</p><details><summary>Script 3: combining the above gives (click me!)</summary><pre><code class="language-julia hljs">using Gridap, GridapPETSc, SparseMatricesCSR, GridapTopOpt

function main()
  # FE parameters
  order = 1                                               # Finite element order
  xmax=ymax=zmax=1.0                                      # Domain size
  dom = (0,xmax,0,ymax,0,zmax)                            # Bounding domain
  el_size = (100,100,100)                                 # Mesh partition size
  prop_Γ_N = 0.2                                          # Γ_N size parameter
  prop_Γ_D = 0.2                                          # Γ_D size parameter
  f_Γ_N(x) = (x[1] ≈ xmax) &amp;&amp;                             # Γ_N indicator function
    (ymax/2-ymax*prop_Γ_N/2 - eps() &lt;= x[2] &lt;= ymax/2+ymax*prop_Γ_N/2 + eps()) &amp;&amp;
    (zmax/2-zmax*prop_Γ_N/2 - eps() &lt;= x[3] &lt;= zmax/2+zmax*prop_Γ_N/2 + eps())
  f_Γ_D(x) = (x[1] ≈ 0.0) &amp;&amp;                              # Γ_D indicator function
    (x[2] &lt;= ymax*prop_Γ_D + eps() || x[2] &gt;= ymax-ymax*prop_Γ_D - eps()) &amp;&amp;
    (x[3] &lt;= zmax*prop_Γ_D + eps() || x[3] &gt;= zmax-zmax*prop_Γ_D - eps())
  # FD parameters
  γ = 0.1                                                 # HJ equation time step coefficient
  γ_reinit = 0.5                                          # Reinit. equation time step coefficient
  max_steps = floor(Int,minimum(el_size)/3)               # Max steps for advection
  tol = 1/(2order^2)/minimum(el_size)           # Advection tolerance
  # Problem parameters
  κ = 1                                                   # Diffusivity
  g = 1                                                   # Heat flow in
  vf = 0.4                                                # Volume fraction constraint
  lsf_func = initial_lsf(4,0.2)                           # Initial level set function
  iter_mod = 10                                           # Output VTK files every 10th iteration
  path = &quot;./results/tut1_3d_petsc/&quot;                       # Output path
  mkpath(path)                                            # Create path
  # Model
  model = CartesianDiscreteModel(dom,el_size);
  update_labels!(1,model,f_Γ_D,&quot;Gamma_D&quot;)
  update_labels!(2,model,f_Γ_N,&quot;Gamma_N&quot;)
  # Triangulation and measures
  Ω = Triangulation(model)
  Γ_N = BoundaryTriangulation(model,tags=&quot;Gamma_N&quot;)
  dΩ = Measure(Ω,2*order)
  dΓ_N = Measure(Γ_N,2*order)
  # Spaces
  reffe = ReferenceFE(lagrangian,Float64,order)
  V = TestFESpace(model,reffe;dirichlet_tags=[&quot;Gamma_D&quot;])
  U = TrialFESpace(V,0.0)
  V_φ = TestFESpace(model,reffe)
  V_reg = TestFESpace(model,reffe;dirichlet_tags=[&quot;Gamma_N&quot;])
  U_reg = TrialFESpace(V_reg,0)
  # Level set and interpolator
  φh = interpolate(lsf_func,V_φ)
  interp = SmoothErsatzMaterialInterpolation(η = 2*maximum(get_el_Δ(model)))
  I,H,DH,ρ = interp.I,interp.H,interp.DH,interp.ρ
  # Weak formulation
  a(u,v,φ,dΩ,dΓ_N) = ∫((I ∘ φ)*κ*∇(u)⋅∇(v))dΩ
  l(v,φ,dΩ,dΓ_N) = ∫(g*v)dΓ_N
  # State map
  Tm = SparseMatrixCSR{0,PetscScalar,PetscInt}
  Tv = Vector{PetscScalar}
  state_map = AffineFEStateMap(
    a,l,U,V,V_φ,U_reg,φh,dΩ,dΓ_N;
    assem_U = SparseMatrixAssembler(Tm,Tv,U,V),
    assem_adjoint = SparseMatrixAssembler(Tm,Tv,V,U),
    assem_deriv = SparseMatrixAssembler(Tm,Tv,U_reg,U_reg),
    ls = PETScLinearSolver(),adjoint_ls = PETScLinearSolver()
  )
  # Objective and constraints
  J(u,φ,dΩ,dΓ_N) = ∫((I ∘ φ)*κ*∇(u)⋅∇(u))dΩ
  dJ(q,u,φ,dΩ,dΓ_N) = ∫(κ*∇(u)⋅∇(u)*q*(DH ∘ φ)*(norm ∘ ∇(φ)))dΩ
  vol_D = sum(∫(1)dΩ)
  C(u,φ,dΩ,dΓ_N) = ∫(((ρ ∘ φ) - vf)/vol_D)dΩ
  dC(q,u,φ,dΩ,dΓ_N) = ∫(-1/vol_D*q*(DH ∘ φ)*(norm ∘ ∇(φ)))dΩ
  pcfs = PDEConstrainedFunctionals(J,[C],state_map,analytic_dJ=dJ,analytic_dC=[dC])
  # Velocity extension
  α = 4*maximum(get_el_Δ(model))
  a_hilb(p,q) =∫(α^2*∇(p)⋅∇(q) + p*q)dΩ
  vel_ext = VelocityExtension(
    a_hilb, U_reg, V_reg;
    assem = SparseMatrixAssembler(Tm,Tv,U_reg,V_reg),
    ls = PETScLinearSolver()
  )
  # Finite difference scheme
  scheme = FirstOrderStencil(length(el_size),Float64)
  ls_evo = HamiltonJacobiEvolution(scheme,model,V_φ,tol,max_steps)
  # Optimiser
  optimiser = AugmentedLagrangian(pcfs,ls_evo,vel_ext,φh;γ,γ_reinit,verbose=true,constraint_names=[:Vol])
  # Solve
  for (it,uh,φh) in optimiser
    data = [&quot;phi&quot;=&gt;φh,&quot;H(phi)&quot;=&gt;(H ∘ φh),&quot;|nabla(phi)|&quot;=&gt;(norm ∘ ∇(φh)),&quot;uh&quot;=&gt;uh]
    iszero(it % iter_mod) &amp;&amp; (writevtk(Ω,path*&quot;struc_$it&quot;,cellfields=data);GC.gc())
    write_history(path*&quot;/history.txt&quot;,get_history(optimiser))
  end
  # Final structure
  it = get_history(optimiser).niter; uh = get_state(pcfs)
  writevtk(Ω,path*&quot;struc_$it&quot;,cellfields=[&quot;phi&quot;=&gt;φh,
    &quot;H(phi)&quot;=&gt;(H ∘ φh),&quot;|nabla(phi)|&quot;=&gt;(norm ∘ ∇(φh)),&quot;uh&quot;=&gt;uh])
end

solver_options = &quot;-pc_type gamg -ksp_type cg -ksp_error_if_not_converged true
  -ksp_converged_reason -ksp_rtol 1.0e-12&quot;
GridapPETSc.with(args=split(solver_options)) do
  main()
end</code></pre></details><p>We can run this script and visualise the initial and final structures using Paraview:</p><table><tr><th style="text-align: center"><img src="../3d_min_thermal_combined.png" alt/></th></tr><tr><td style="text-align: center">Figure 5: Visualisation of initial structure (left) and final structure (right) for Script 3 using the isovolume with <span>$\varphi\leq0$</span>.</td></tr></table><h3 id="Serial-to-MPI"><a class="docs-heading-anchor" href="#Serial-to-MPI">Serial to MPI</a><a id="Serial-to-MPI-1"></a><a class="docs-heading-anchor-permalink" href="#Serial-to-MPI" title="Permalink"></a></h3><p>Script 3 contains no parallelism to enable further speedup or scalability. To enable MPI-based computing we rely on the tools implemented in PartitionedArrays and GridapDistributed. Further information regarding these packages and how they interface with GridapTopOpt can be found <a href="../../usage/mpi-mode/">here</a>. To add these packages we adjust the first line of our script:</p><pre><code class="language-julia hljs">using Gridap, GridapPETSc, GridapDistributed, PartitionedArrays, SparseMatricesCSR, GridapTopOpt</code></pre><p>Before we change any parts of the function <code>main</code>, we adjust the end of the script to safely launch MPI inside a Julia <code>do</code> block. We replace lines 95-99 in Script 3 with</p><pre><code class="language-julia hljs">with_mpi() do distribute
  mesh_partition = (2,2,2)
  solver_options = &quot;-pc_type gamg -ksp_type cg -ksp_error_if_not_converged true
    -ksp_converged_reason -ksp_rtol 1.0e-12&quot;
  GridapPETSc.with(args=split(solver_options)) do
    main(mesh_partition,distribute)
  end
end</code></pre><p>We use <code>mesh_partition = (2,2,2)</code> to set the number of partitions of the Cartesian mesh in each axial direction. For this example we end up with a total of 8 partitions. We then pass <code>main</code> two arguments: <code>mesh_partition</code> and <code>distribute</code>. We use these to to create MPI ranks at the start of <code>main</code>:</p><pre><code class="language-julia hljs">function main(mesh_partition,distribute)
  ranks = distribute(LinearIndices((prod(mesh_partition),)))
  ...</code></pre><p>We then adjust lines 28-31 as follows:</p><pre><code class="language-julia hljs">  path = &quot;./results/tut1_3d_petsc_mpi/&quot;                   # Output path
  i_am_main(ranks) &amp;&amp; mkpath(path)                        # Create path
  # Model
  model = CartesianDiscreteModel(ranks,mesh_partition,dom,el_size);</code></pre><p>The function <code>i_am_main</code> returns true only on the first processor. This function is useful for ensuring certain operations only happen once instead of several times across each executable. In addition, we now create a partitioned Cartesian model using <code>CartesianDiscreteModel(ranks,mesh_partition,dom,el_size)</code>. Finally, we adjust line 82 to ensure that verbosity only happens on the first processors:</p><pre><code class="language-julia hljs">optimiser = AugmentedLagrangian(pcfs,ls_evo,vel_ext,φh;
  γ,γ_reinit,verbose=i_am_main(ranks),constraint_names=[:Vol])</code></pre><p>That&#39;s it! These are the only changes that are necessary to run your application using MPI.</p><details><summary>Script 4: combining the above gives (click me!)</summary><pre><code class="language-julia hljs">using Gridap, GridapPETSc, GridapDistributed, PartitionedArrays, SparseMatricesCSR, GridapTopOpt

function main(mesh_partition,distribute)
  ranks = distribute(LinearIndices((prod(mesh_partition),)))
  # FE parameters
  order = 1                                               # Finite element order
  xmax=ymax=zmax=1.0                                      # Domain size
  dom = (0,xmax,0,ymax,0,zmax)                            # Bounding domain
  el_size = (100,100,100)                                 # Mesh partition size
  prop_Γ_N = 0.2                                          # Γ_N size parameter
  prop_Γ_D = 0.2                                          # Γ_D size parameter
  f_Γ_N(x) = (x[1] ≈ xmax) &amp;&amp;                             # Γ_N indicator function
    (ymax/2-ymax*prop_Γ_N/2 - eps() &lt;= x[2] &lt;= ymax/2+ymax*prop_Γ_N/2 + eps()) &amp;&amp;
    (zmax/2-zmax*prop_Γ_N/2 - eps() &lt;= x[3] &lt;= zmax/2+zmax*prop_Γ_N/2 + eps())
  f_Γ_D(x) = (x[1] ≈ 0.0) &amp;&amp;                              # Γ_D indicator function
    (x[2] &lt;= ymax*prop_Γ_D + eps() || x[2] &gt;= ymax-ymax*prop_Γ_D - eps()) &amp;&amp;
    (x[3] &lt;= zmax*prop_Γ_D + eps() || x[3] &gt;= zmax-zmax*prop_Γ_D - eps())
  # FD parameters
  γ = 0.1                                                 # HJ equation time step coefficient
  γ_reinit = 0.5                                          # Reinit. equation time step coefficient
  max_steps = floor(Int,minimum(el_size)/3)               # Max steps for advection
  tol = 1/(2order^2)/minimum(el_size)           # Advection tolerance
  # Problem parameters
  κ = 1                                                   # Diffusivity
  g = 1                                                   # Heat flow in
  vf = 0.4                                                # Volume fraction constraint
  lsf_func = initial_lsf(4,0.2)                           # Initial level set function
  iter_mod = 10                                           # Output VTK files every 10th iteration
  path = &quot;./results/tut1_3d_petsc_mpi/&quot;                   # Output path
  i_am_main(ranks) &amp;&amp; mkpath(path)                        # Create path
  # Model
  model = CartesianDiscreteModel(ranks,mesh_partition,dom,el_size);
  update_labels!(1,model,f_Γ_D,&quot;Gamma_D&quot;)
  update_labels!(2,model,f_Γ_N,&quot;Gamma_N&quot;)
  # Triangulation and measures
  Ω = Triangulation(model)
  Γ_N = BoundaryTriangulation(model,tags=&quot;Gamma_N&quot;)
  dΩ = Measure(Ω,2*order)
  dΓ_N = Measure(Γ_N,2*order)
  # Spaces
  reffe = ReferenceFE(lagrangian,Float64,order)
  V = TestFESpace(model,reffe;dirichlet_tags=[&quot;Gamma_D&quot;])
  U = TrialFESpace(V,0.0)
  V_φ = TestFESpace(model,reffe)
  V_reg = TestFESpace(model,reffe;dirichlet_tags=[&quot;Gamma_N&quot;])
  U_reg = TrialFESpace(V_reg,0)
  # Level set and interpolator
  φh = interpolate(lsf_func,V_φ)
  interp = SmoothErsatzMaterialInterpolation(η = 2*maximum(get_el_Δ(model)))
  I,H,DH,ρ = interp.I,interp.H,interp.DH,interp.ρ
  # Weak formulation
  a(u,v,φ,dΩ,dΓ_N) = ∫((I ∘ φ)*κ*∇(u)⋅∇(v))dΩ
  l(v,φ,dΩ,dΓ_N) = ∫(g*v)dΓ_N
  # State map
  Tm = SparseMatrixCSR{0,PetscScalar,PetscInt}
  Tv = Vector{PetscScalar}
  state_map = AffineFEStateMap(
    a,l,U,V,V_φ,U_reg,φh,dΩ,dΓ_N;
    assem_U = SparseMatrixAssembler(Tm,Tv,U,V),
    assem_adjoint = SparseMatrixAssembler(Tm,Tv,V,U),
    assem_deriv = SparseMatrixAssembler(Tm,Tv,U_reg,U_reg),
    ls = PETScLinearSolver(),adjoint_ls = PETScLinearSolver()
  )
  # Objective and constraints
  J(u,φ,dΩ,dΓ_N) = ∫((I ∘ φ)*κ*∇(u)⋅∇(u))dΩ
  dJ(q,u,φ,dΩ,dΓ_N) = ∫(κ*∇(u)⋅∇(u)*q*(DH ∘ φ)*(norm ∘ ∇(φ)))dΩ
  vol_D = sum(∫(1)dΩ)
  C(u,φ,dΩ,dΓ_N) = ∫(((ρ ∘ φ) - vf)/vol_D)dΩ
  dC(q,u,φ,dΩ,dΓ_N) = ∫(-1/vol_D*q*(DH ∘ φ)*(norm ∘ ∇(φ)))dΩ
  pcfs = PDEConstrainedFunctionals(J,[C],state_map,analytic_dJ=dJ,analytic_dC=[dC])
  # Velocity extension
  α = 4*maximum(get_el_Δ(model))
  a_hilb(p,q) =∫(α^2*∇(p)⋅∇(q) + p*q)dΩ
  vel_ext = VelocityExtension(
    a_hilb, U_reg, V_reg;
    assem = SparseMatrixAssembler(Tm,Tv,U_reg,V_reg),
    ls = PETScLinearSolver()
  )
  # Finite difference scheme
  scheme = FirstOrderStencil(length(el_size),Float64)
  ls_evo = HamiltonJacobiEvolution(scheme,model,V_φ,tol,max_steps)
  # Optimiser
  optimiser = AugmentedLagrangian(pcfs,ls_evo,vel_ext,φh;
    γ,γ_reinit,verbose=i_am_main(ranks),constraint_names=[:Vol])
  # Solve
  for (it,uh,φh) in optimiser
    data = [&quot;phi&quot;=&gt;φh,&quot;H(phi)&quot;=&gt;(H ∘ φh),&quot;|nabla(phi)|&quot;=&gt;(norm ∘ ∇(φh)),&quot;uh&quot;=&gt;uh]
    iszero(it % iter_mod) &amp;&amp; (writevtk(Ω,path*&quot;struc_$it&quot;,cellfields=data);GC.gc())
    write_history(path*&quot;/history.txt&quot;,get_history(optimiser))
  end
  # Final structure
  it = get_history(optimiser).niter; uh = get_state(pcfs)
  writevtk(Ω,path*&quot;struc_$it&quot;,cellfields=[&quot;phi&quot;=&gt;φh,
    &quot;H(phi)&quot;=&gt;(H ∘ φh),&quot;|nabla(phi)|&quot;=&gt;(norm ∘ ∇(φh)),&quot;uh&quot;=&gt;uh])
end

with_mpi() do distribute
  mesh_partition = (2,2,2)
  solver_options = &quot;-pc_type gamg -ksp_type cg -ksp_error_if_not_converged true
    -ksp_converged_reason -ksp_rtol 1.0e-12&quot;
  GridapPETSc.with(args=split(solver_options)) do
    main(mesh_partition,distribute)
  end
end</code></pre></details><p>We can then run this script by calling <a href="https://juliaparallel.org/MPI.jl/stable/usage/#Julia-wrapper-for-mpiexec"><code>mpiexecjl</code></a> using bash:</p><pre><code class="language-bash hljs">mpiexecjl -n 8 julia tut1_3d_petsc_mpi.jl</code></pre><p>This gives the same final result as the previous script.</p><h3 id="Nonlinear-thermal-conductivity"><a class="docs-heading-anchor" href="#Nonlinear-thermal-conductivity">Nonlinear thermal conductivity</a><a id="Nonlinear-thermal-conductivity-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear-thermal-conductivity" title="Permalink"></a></h3><p>Our final extension considers two-dimensional nonlinear thermal conductivity problem:</p><p class="math-container">\[\begin{aligned}
-\nabla(\kappa(u)\nabla u) &amp;= 0~\text{in }\Omega,\\
\kappa(u)\nabla u\cdot\boldsymbol{n} &amp;= g~\text{on }\Gamma_N,\\
\kappa(u)\nabla u\cdot\boldsymbol{n} &amp;= 0~\text{on }\partial\Omega\setminus\Gamma_N,\\
u &amp;= 0~\text{on }\Gamma_D.
\end{aligned}\]</p><p>where <span>$\kappa(u)=\kappa_0\exp{\xi u}$</span>. The weak formulation for this problem with relaxation over the computational domain is: <em>Find</em> <span>$u\in H^1_{\Gamma_D}(D)$</span> <em>such that</em> <span>$R(u,v;\varphi)=0$</span> for all <span>$v\in H^1_{\Gamma_D}(D)$</span> where</p><p class="math-container">\[R(u,v;\varphi) = \int_{D}I(\varphi)\kappa(u)\boldsymbol{\nabla}u\cdot\boldsymbol{\nabla}v~\mathrm{d}\boldsymbol{x} - \int_{\Gamma_N}gv~\mathrm{d}\boldsymbol{x}.\]</p><p>As we&#39;re considering a 2D problem, we consider modifications of Script 1 as follows. First, we introduce a nonlinear diffusivity by replacing line 20 with</p><pre><code class="language-julia hljs">κ(u) = exp(-u)                                          # Diffusivity</code></pre><p>We then replace the <code>a</code> and <code>l</code> on line 48 and 49 by the residual <code>R</code> given by</p><pre><code class="language-julia hljs">R(u,v,φ,dΩ,dΓ_N) = ∫((I ∘ φ)*(κ ∘ u)*∇(u)⋅∇(v))dΩ - ∫(g*v)dΓ_N</code></pre><p>In addition we replace the <code>AffineFEStateMap</code> on line 50 with a <a href="../../../reference/chainrules/#NonlinearFEStateMap"><code>NonlinearFEStateMap</code></a>. This enables automatic differentiation when the forward problem is nonlinear.</p><pre><code class="language-julia hljs">state_map = NonlinearFEStateMap(R,U,V,V_φ,U_reg,φh,dΩ,dΓ_N)</code></pre><p>This by default implements a standard <code>NewtonSolver</code> from GridapSolvers while utilising an LU solver for intermediate linear solves involving the Jacobian. As with other <code>FEStateMap</code> types, this constructor can optionally take assemblers and different solvers (e.g., PETSc solvers).</p><p>Next, we replace the objective functional on line 52 with</p><pre><code class="language-julia hljs">J(u,φ,dΩ,dΓ_N) = ∫((I ∘ φ)*(κ ∘ u)*∇(u)⋅∇(u))dΩ</code></pre><p>For this problem we utilise automatic differentiation as the analytic calculation of the sensitivity is somewhat involved. We therefore remove line 53 and replace line 57 with</p><pre><code class="language-julia hljs">pcfs = PDEConstrainedFunctionals(J,[C],state_map,analytic_dC=[dC])</code></pre><p>Notice that the argument <code>analytic_dJ=...</code> has been removed, this enables the AD capability. We now have everything we need to run a nonlinear problem.</p><details><summary>Script 5: combining the above gives (click me!)</summary><pre><code class="language-julia hljs">using Gridap, GridapTopOpt

# FE parameters
order = 1                                               # Finite element order
xmax = ymax = 1.0                                       # Domain size
dom = (0,xmax,0,ymax)                                   # Bounding domain
el_size = (200,200)                                     # Mesh partition size
prop_Γ_N = 0.2                                          # Γ_N size parameter
prop_Γ_D = 0.2                                          # Γ_D size parameter
f_Γ_N(x) = (x[1] ≈ xmax &amp;&amp;                              # Γ_N indicator function
  ymax/2-ymax*prop_Γ_N/2 - eps() &lt;= x[2] &lt;= ymax/2+ymax*prop_Γ_N/2 + eps())
f_Γ_D(x) = (x[1] ≈ 0.0 &amp;&amp;                               # Γ_D indicator function
  (x[2] &lt;= ymax*prop_Γ_D + eps() || x[2] &gt;= ymax-ymax*prop_Γ_D - eps()))
# FD parameters
γ = 0.1                                                 # HJ equation time step coefficient
γ_reinit = 0.5                                          # Reinit. equation time step coefficient
max_steps = floor(Int,minimum(el_size)/10)              # Max steps for advection
tol = 1/(5order^2)/minimum(el_size)          # Advection tolerance
# Problem parameters
κ(u) = exp(-u)                                          # Diffusivity
g = 1                                                   # Heat flow in
vf = 0.4                                                # Volume fraction constraint
lsf_func = initial_lsf(4,0.2)                           # Initial level set function
iter_mod = 10                                           # Output VTK files every 10th iteration
path = &quot;./results/tut1_nonlinear/&quot;                      # Output path
mkpath(path)                                            # Create path
# Model
model = CartesianDiscreteModel(dom,el_size);
update_labels!(1,model,f_Γ_D,&quot;Gamma_D&quot;)
update_labels!(2,model,f_Γ_N,&quot;Gamma_N&quot;)
# Triangulation and measures
Ω = Triangulation(model)
Γ_N = BoundaryTriangulation(model,tags=&quot;Gamma_N&quot;)
dΩ = Measure(Ω,2*order)
dΓ_N = Measure(Γ_N,2*order)
# Spaces
reffe = ReferenceFE(lagrangian,Float64,order)
V = TestFESpace(model,reffe;dirichlet_tags=[&quot;Gamma_D&quot;])
U = TrialFESpace(V,0.0)
V_φ = TestFESpace(model,reffe)
V_reg = TestFESpace(model,reffe;dirichlet_tags=[&quot;Gamma_N&quot;])
U_reg = TrialFESpace(V_reg,0)
# Level set and interpolator
φh = interpolate(lsf_func,V_φ)
interp = SmoothErsatzMaterialInterpolation(η = 2*maximum(get_el_Δ(model)))
I,H,DH,ρ = interp.I,interp.H,interp.DH,interp.ρ
# Weak formulation
R(u,v,φ,dΩ,dΓ_N) = ∫((I ∘ φ)*(κ ∘ u)*∇(u)⋅∇(v))dΩ - ∫(g*v)dΓ_N
state_map = NonlinearFEStateMap(R,U,V,V_φ,U_reg,φh,dΩ,dΓ_N)
# Objective and constraints
J(u,φ,dΩ,dΓ_N) = ∫((I ∘ φ)*(κ ∘ u)*∇(u)⋅∇(u))dΩ
vol_D = sum(∫(1)dΩ)
C(u,φ,dΩ,dΓ_N) = ∫(((ρ ∘ φ) - vf)/vol_D)dΩ
dC(q,u,φ,dΩ,dΓ_N) = ∫(-1/vol_D*q*(DH ∘ φ)*(norm ∘ ∇(φ)))dΩ
pcfs = PDEConstrainedFunctionals(J,[C],state_map,analytic_dC=[dC])
# Velocity extension
α = 4*maximum(get_el_Δ(model))
a_hilb(p,q) =∫(α^2*∇(p)⋅∇(q) + p*q)dΩ
vel_ext = VelocityExtension(a_hilb,U_reg,V_reg)
# Finite difference scheme
scheme = FirstOrderStencil(length(el_size),Float64)
ls_evo = HamiltonJacobiEvolution(scheme,model,V_φ,tol,max_steps)
# Optimiser
optimiser = AugmentedLagrangian(pcfs,ls_evo,vel_ext,φh;γ,γ_reinit,verbose=true,constraint_names=[:Vol])
# Solve
for (it,uh,φh) in optimiser
  data = [&quot;phi&quot;=&gt;φh,&quot;H(phi)&quot;=&gt;(H ∘ φh),&quot;|nabla(phi)|&quot;=&gt;(norm ∘ ∇(φh)),&quot;uh&quot;=&gt;uh]
  iszero(it % iter_mod) &amp;&amp; (writevtk(Ω,path*&quot;struc_$it&quot;,cellfields=data);GC.gc())
  write_history(path*&quot;/history.txt&quot;,get_history(optimiser))
end
# Final structure
it = get_history(optimiser).niter; uh = get_state(pcfs)
writevtk(Ω,path*&quot;struc_$it&quot;,cellfields=[&quot;phi&quot;=&gt;φh,
  &quot;H(phi)&quot;=&gt;(H ∘ φh),&quot;|nabla(phi)|&quot;=&gt;(norm ∘ ∇(φh)),&quot;uh&quot;=&gt;uh])</code></pre></details><p>Running this problem until convergence gives a final result of</p><pre><code class="nohighlight hljs">Iteration:  95 | L=1.6554e-01, J=1.6570e-01, Vol=-2.8836e-04, γ=7.5000e-02</code></pre><p>with the optimised domain <span>$\Omega$</span> given by</p><table><tr><th style="text-align: center"><img src="../2d_min_thermal_nl_final_struc.png" alt/></th></tr><tr><td style="text-align: center">Figure 6: Visualisation of <span>$\Omega$</span> using the isovolume with <span>$\varphi\leq0$</span>.</td></tr></table><p>A 3D example of a nonlinear thermal conductivity problem can be found under <code>scripts/MPI/3d_nonlinear_thermal_compliance_ALM.jl</code>.</p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><blockquote><ol><li><p><em>Z. Guo, X. Cheng, and Z. Xia. Least dissipation principle of heat transport potential capacity and its application in heat conduction  optimization. Chinese Science Bulletin, 48(4):406–410, Feb 2003. ISSN 1861-9541. doi: 10.1007/BF03183239.</em></p></li><li><p><em>C. Zhuang, Z. Xiong, and H. Ding. A level set method for topology optimization of heat conduction problem under multiple load cases. Computer Methods in Applied Mechanics and Engineering, 196(4–6):1074–1084, Jan 2007. ISSN 00457825. doi: 10.1016/j.cma.2006.08.005.</em></p></li><li><p><em>Allaire G, Jouve F, Toader AM (2004) Structural optimization using sensitivity analysis and a level-set method. Journal of Computational Physics 194(1):363–393. doi: 10.1016/j.jcp.2003.09.032</em></p></li><li><p><em>Allaire G, Dapogny C, Jouve F (2021) Shape and topology optimization, vol 22, Elsevier, p 1–132. doi: 10.1016/bs.hna.2020.10.004</em></p></li><li><p><em>Osher S, Fedkiw R (2006) Level Set Methods and Dynamic Implicit Surfaces, 1st edn. Applied Mathematical Sciences, Springer Science &amp; Business Media. doi: 10.1007/b98879</em></p></li><li><p><em>Nocedal J, Wright SJ (2006) Numerical optimization, 2nd edn. Springer series in operations research, Springer, New York. doi: 10.1007/978-0-387-40065-5</em></p></li></ol></blockquote></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Wednesday 15 May 2024 01:00">Wednesday 15 May 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
