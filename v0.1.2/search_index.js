var documenterSearchIndex = {"docs":
[{"location":"reference/benchmarking/#Benchmarking","page":"Benchmarking","title":"Benchmarking","text":"","category":"section"},{"location":"reference/benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"GridapTopOpt.benchmark","category":"page"},{"location":"reference/benchmarking/#GridapTopOpt.benchmark","page":"Benchmarking","title":"GridapTopOpt.benchmark","text":"benchmark(f, args, ranks; nreps, reset!)\n\nBenchmark a function f that takes arguments args.\n\nIn MPI mode, benchmark will always return the maximum CPU time across all ranks. This behaviour can be changed by overwritting process_timer.\n\nImportant\n\nThe input ranks allows the user to provide the MPI ranks, benchmark will not function correctly in MPI mode if these are not supplied. In serial, set ranks = nothing.\n\nOptional\n\nnreps = 10: Number of benchmark repetitions\nreset!= (x...) -> nothing: Function for resetting inital data (e.g., level-set function varphi).\n\n\n\n\n\n","category":"function"},{"location":"reference/benchmarking/#Existing-benchmark-methods","page":"Benchmarking","title":"Existing benchmark methods","text":"","category":"section"},{"location":"reference/benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"GridapTopOpt.benchmark_optimizer\nGridapTopOpt.benchmark_single_iteration\nGridapTopOpt.benchmark_forward_problem\nGridapTopOpt.benchmark_advection\nGridapTopOpt.benchmark_reinitialisation\nGridapTopOpt.benchmark_velocity_extension\nGridapTopOpt.benchmark_hilbertian_projection_map","category":"page"},{"location":"reference/benchmarking/#GridapTopOpt.benchmark_optimizer","page":"Benchmarking","title":"GridapTopOpt.benchmark_optimizer","text":"benchmark_optimizer(m::Optimiser, niter, ranks; nreps)\n\nGiven an optimiser m, benchmark niter iterations.\n\n\n\n\n\n","category":"function"},{"location":"reference/benchmarking/#GridapTopOpt.benchmark_single_iteration","page":"Benchmarking","title":"GridapTopOpt.benchmark_single_iteration","text":"benchmark_single_iteration(m::Optimiser, ranks; nreps)\n\nGiven an optimiser m, benchmark a single iteration after 0th iteration.\n\n\n\n\n\n","category":"function"},{"location":"reference/benchmarking/#GridapTopOpt.benchmark_forward_problem","page":"Benchmarking","title":"GridapTopOpt.benchmark_forward_problem","text":"benchmark_forward_problem(m::AbstractFEStateMap, φh, ranks; nreps)\n\nBenchmark the forward FE solve given m::AbstractFEStateMap and a level-set function φh. See forward_solve! for input types.\n\n\n\n\n\n","category":"function"},{"location":"reference/benchmarking/#GridapTopOpt.benchmark_advection","page":"Benchmarking","title":"GridapTopOpt.benchmark_advection","text":"benchmark_advection(stencil::LevelSetEvolution, φ0, v0, γ, ranks; nreps)\n\nBenchmark solving the Hamilton-Jacobi evolution equation given a stencil, level-set function φ0, velocity function v0, and time step coefficient γ. See evolve! for input types.\n\n\n\n\n\n","category":"function"},{"location":"reference/benchmarking/#GridapTopOpt.benchmark_reinitialisation","page":"Benchmarking","title":"GridapTopOpt.benchmark_reinitialisation","text":"benchmark_reinitialisation(stencil::LevelSetEvolution, φ0, γ_reinit, ranks; nreps)\n\nBenchmark solving the reinitialisation equation given a stencil, level-set function φ0, and time step coefficient γ. See reinit! for input types.\n\n\n\n\n\n","category":"function"},{"location":"reference/benchmarking/#GridapTopOpt.benchmark_velocity_extension","page":"Benchmarking","title":"GridapTopOpt.benchmark_velocity_extension","text":"benchmark_velocity_extension(ext::VelocityExtension, v0, ranks; nreps)\n\nBenchmark the Hilbertian velocity-extension method ext given a RHS v0. See project! for input types.\n\n\n\n\n\n","category":"function"},{"location":"reference/benchmarking/#GridapTopOpt.benchmark_hilbertian_projection_map","page":"Benchmarking","title":"GridapTopOpt.benchmark_hilbertian_projection_map","text":"benchmark_hilbertian_projection_map(m::HilbertianProjectionMap, dV, C, dC, K, ranks; nreps)\n\nBenchmark update_descent_direction! for HilbertianProjectionMap given a objective sensitivity dV, constraint values C, constraint sensitivities dC, and stiffness matrix K for the velocity-extension.\n\n\n\n\n\n","category":"function"},{"location":"deprecated/usage/mpi-mode/#MPI-and-PartitionedArrays.jl","page":"MPI and PartitionedArrays.jl","title":"MPI and PartitionedArrays.jl","text":"","category":"section"},{"location":"reference/chainrules/#ChainRules","page":"ChainRules","title":"ChainRules","text":"","category":"section"},{"location":"reference/chainrules/#PDEConstrainedFunctionals","page":"ChainRules","title":"PDEConstrainedFunctionals","text":"","category":"section"},{"location":"reference/chainrules/","page":"ChainRules","title":"ChainRules","text":"GridapTopOpt.PDEConstrainedFunctionals\nGridapTopOpt.evaluate!\nGridapTopOpt.evaluate_functionals!\nGridapTopOpt.evaluate_derivatives!\nGridapTopOpt.get_state","category":"page"},{"location":"reference/chainrules/#GridapTopOpt.PDEConstrainedFunctionals","page":"ChainRules","title":"GridapTopOpt.PDEConstrainedFunctionals","text":"struct PDEConstrainedFunctionals{N,A}\n\nAn object that computes the objective, constraints, and their derivatives.\n\nImplementation\n\nThis implementation computes derivatives of a integral quantity\n\nF(u(varphi)varphimathrmdOmega_1mathrmdOmega_2) = Sigma_iint_Omega_i f_i(varphi)mathrmdOmega\n\nwith respect to an auxiliary parameter varphi where u is the solution to a PDE and implicitly depends on varphi. This requires two pieces of information:\n\nComputation of fracpartial Fpartial u and fracpartial Fpartial varphi (handled by StateParamIntegrandWithMeasure).\nComputation of fracpartial Fpartial u fracpartial upartial varphi at varphi and u using the adjoint method (handled by AbstractFEStateMap). I.e., let\nfracpartial Fpartial u fracpartial upartial varphi = -lambda^intercal fracpartial mathcalRpartial varphi\nwhere mathcalR is the residual and solve the (linear) adjoint problem:\nfracpartial mathcalRpartial u^intercallambda = fracpartial Fpartial u^intercal\n\nThe gradient is then fracpartial Fpartial varphi = fracpartial Fpartial varphi - fracpartial Fpartial ufracpartial upartial varphi.\n\nParameters\n\nJ: A StateParamIntegrandWithMeasure corresponding to the objective.\nC: A vector of StateParamIntegrandWithMeasure corresponding to the constraints.\ndJ: The DoFs for the objective sensitivity.\ndC: The DoFs for each constraint sensitivity.\nanalytic_dJ: a Function for computing the analytic objective sensitivity.\nanalytic_dC: A vector of Function for computing the analytic objective sensitivities.\nstate_map::A: The state map for the problem.\n\nNote\n\nIf analytic_dJ = nothing automatic differentiation will be used.\nIf analytic_dC[i] = nothing automatic differentiation will be used for C[i].\n\n\n\n\n\n","category":"type"},{"location":"reference/chainrules/#Gridap.Arrays.evaluate!","page":"ChainRules","title":"Gridap.Arrays.evaluate!","text":"Fields.evaluate!(pcf::PDEConstrainedFunctionals,φh)\n\nEvaluate the objective and constraints, and their derivatives at φh.\n\n\n\n\n\n","category":"function"},{"location":"reference/chainrules/#GridapTopOpt.evaluate_functionals!","page":"ChainRules","title":"GridapTopOpt.evaluate_functionals!","text":"evaluate_functionals!(pcf::PDEConstrainedFunctionals,φh)\n\nEvaluate the objective and constraints at φh.\n\n\n\n\n\n","category":"function"},{"location":"reference/chainrules/#GridapTopOpt.evaluate_derivatives!","page":"ChainRules","title":"GridapTopOpt.evaluate_derivatives!","text":"evaluate_derivatives!(pcf::PDEConstrainedFunctionals,φh)\n\nEvaluate the derivatives of the objective and constraints at φh.\n\n\n\n\n\n","category":"function"},{"location":"reference/chainrules/#GridapTopOpt.get_state","page":"ChainRules","title":"GridapTopOpt.get_state","text":"get_state(m::AbstractFEStateMap)\n\nReturn the solution/state u to the FE problem.\n\n\n\n\n\n","category":"function"},{"location":"reference/chainrules/#StateParamIntegrandWithMeasure","page":"ChainRules","title":"StateParamIntegrandWithMeasure","text":"","category":"section"},{"location":"reference/chainrules/","page":"ChainRules","title":"ChainRules","text":"GridapTopOpt.StateParamIntegrandWithMeasure\nGridapTopOpt.rrule(u_to_j::GridapTopOpt.StateParamIntegrandWithMeasure,uh,φh)","category":"page"},{"location":"reference/chainrules/#GridapTopOpt.StateParamIntegrandWithMeasure","page":"ChainRules","title":"GridapTopOpt.StateParamIntegrandWithMeasure","text":"struct StateParamIntegrandWithMeasure{A<:IntegrandWithMeasure,B,C,D}\n\nA wrapper to handle partial differentation of an IntegrandWithMeasure of a specific form (see below) in a ChainRules.jl compatible way with caching.\n\nAssumptions\n\nWe assume that we have a IntegrandWithMeasure of the following form:\n\nF(u,φ,dΩ₁,dΩ₂,...) = ∫(f(u,φ))dΩ₁ + ∫(g(u,φ))dΩ₂ + ...,.\n\nwhere u and φ are each expected to inherit from Union{FEFunction,MultiFieldFEFunction} or the GridapDistributed equivalent.\n\n\n\n\n\n","category":"type"},{"location":"reference/chainrules/#ChainRulesCore.rrule-Tuple{GridapTopOpt.StateParamIntegrandWithMeasure, Any, Any}","page":"ChainRules","title":"ChainRulesCore.rrule","text":"ChainRulesCore.rrule(u_to_j::StateParamIntegrandWithMeasure,uh,φh)\n\nReturn the evaluation of a StateParamIntegrandWithMeasure and a a function for evaluating the pullback of u_to_j. This enables compatiblity with ChainRules.jl\n\n\n\n\n\n","category":"method"},{"location":"reference/chainrules/#Implemented-types-of-AbstractFEStateMap","page":"ChainRules","title":"Implemented types of AbstractFEStateMap","text":"","category":"section"},{"location":"reference/chainrules/","page":"ChainRules","title":"ChainRules","text":"GridapTopOpt.AbstractFEStateMap","category":"page"},{"location":"reference/chainrules/#GridapTopOpt.AbstractFEStateMap","page":"ChainRules","title":"GridapTopOpt.AbstractFEStateMap","text":"abstract type AbstractFEStateMap\n\nTypes inheriting from this abstract type should enable the evaluation and differentiation of the solution to an FE problem u that implicitly depends on an auxiliary parameter φ.\n\n\n\n\n\n","category":"type"},{"location":"reference/chainrules/#AffineFEStateMap","page":"ChainRules","title":"AffineFEStateMap","text":"","category":"section"},{"location":"reference/chainrules/","page":"ChainRules","title":"ChainRules","text":"GridapTopOpt.AffineFEStateMap\nGridapTopOpt.AffineFEStateMap(a::Function,l::Function,U,V,V_φ,U_reg,φh,dΩ...;assem_U = SparseMatrixAssembler(U,V),assem_adjoint = SparseMatrixAssembler(V,U),assem_deriv = SparseMatrixAssembler(U_reg,U_reg),ls::LinearSolver = LUSolver(),adjoint_ls::LinearSolver = LUSolver())","category":"page"},{"location":"reference/chainrules/#GridapTopOpt.AffineFEStateMap","page":"ChainRules","title":"GridapTopOpt.AffineFEStateMap","text":"struct AffineFEStateMap{A,B,C,D,E,F} <: AbstractFEStateMap\n\nA structure to enable the forward problem and pullback for affine finite element operators AffineFEOperator.\n\nParameters\n\nbiform::A: IntegrandWithMeasure defining the bilinear form.\nliform::B: IntegrandWithMeasure defining the linear form.\nspaces::C: Tuple of finite element spaces.\nplb_caches::D: A cache for the pullback operator.\nfwd_caches::E: A cache for the forward problem.\nadj_caches::F: A cache for the adjoint problem.\n\n\n\n\n\n","category":"type"},{"location":"reference/chainrules/#GridapTopOpt.AffineFEStateMap-Tuple{Function, Function, Any, Any, Any, Any, Any, Vararg{Any}}","page":"ChainRules","title":"GridapTopOpt.AffineFEStateMap","text":"AffineFEStateMap(\n  a::Function,l::Function,\n  U,V,V_φ,U_reg,φh,dΩ...;\n  assem_U = SparseMatrixAssembler(U,V),\n  assem_adjoint = SparseMatrixAssembler(V,U),\n  assem_deriv = SparseMatrixAssembler(U_reg,U_reg),\n  ls::LinearSolver = LUSolver(),\n  adjoint_ls::LinearSolver = LUSolver()\n)\n\nCreate an instance of AffineFEStateMap given the bilinear form a and linear form l as Function types, trial and test spaces U and V, the FE space V_φ for φh, the FE space U_reg for derivatives, and the measures as additional arguments.\n\nOptional arguments enable specification of assemblers and linear solvers.\n\n\n\n\n\n","category":"method"},{"location":"reference/chainrules/#NonlinearFEStateMap","page":"ChainRules","title":"NonlinearFEStateMap","text":"","category":"section"},{"location":"reference/chainrules/","page":"ChainRules","title":"ChainRules","text":"GridapTopOpt.NonlinearFEStateMap\nGridapTopOpt.NonlinearFEStateMap(res::Function,U,V,V_φ,U_reg,φh,dΩ...;assem_U = SparseMatrixAssembler(U,V),assem_adjoint = SparseMatrixAssembler(V,U),assem_deriv = SparseMatrixAssembler(U_reg,U_reg),nls::NonlinearSolver = NewtonSolver(LUSolver();maxiter=50,rtol=1.e-8,verbose=true),adjoint_ls::LinearSolver = LUSolver())","category":"page"},{"location":"reference/chainrules/#GridapTopOpt.NonlinearFEStateMap","page":"ChainRules","title":"GridapTopOpt.NonlinearFEStateMap","text":"struct NonlinearFEStateMap{A,B,C,D,E,F} <: AbstractFEStateMap\n\nA structure to enable the forward problem and pullback for nonlinear finite element operators.\n\nParameters\n\nres::A: an IntegrandWithMeasure defining the residual of the problem.\njac::B: a Function defining Jacobian of the residual.\nspaces::C: Tuple of finite element spaces.\nplb_caches::D: A cache for the pullback operator.\nfwd_caches::E: A cache for the forward problem.\nadj_caches::F: A cache for the adjoint problem.\n\n\n\n\n\n","category":"type"},{"location":"reference/chainrules/#GridapTopOpt.NonlinearFEStateMap-Tuple{Function, Any, Any, Any, Any, Any, Vararg{Any}}","page":"ChainRules","title":"GridapTopOpt.NonlinearFEStateMap","text":"NonlinearFEStateMap(\n  res::Function,U,V,V_φ,U_reg,φh,dΩ...;\n  assem_U = SparseMatrixAssembler(U,V),\n  assem_adjoint = SparseMatrixAssembler(V,U),\n  assem_deriv = SparseMatrixAssembler(U_reg,U_reg),\n  nls::NonlinearSolver = NewtonSolver(LUSolver();maxiter=50,rtol=1.e-8,verbose=true),\n  adjoint_ls::LinearSolver = LUSolver()\n)\n\nCreate an instance of NonlinearFEStateMap given the residual res as a Function type, trial and test spaces U and V, the FE space V_φ for φh, the FE space U_reg for derivatives, and the measures as additional arguments.\n\nOptional arguments enable specification of assemblers, nonlinear solver, and adjoint (linear) solver.\n\n\n\n\n\n","category":"method"},{"location":"reference/chainrules/#RepeatingAffineFEStateMap","page":"ChainRules","title":"RepeatingAffineFEStateMap","text":"","category":"section"},{"location":"reference/chainrules/","page":"ChainRules","title":"ChainRules","text":"GridapTopOpt.RepeatingAffineFEStateMap\nGridapTopOpt.RepeatingAffineFEStateMap(nblocks::Int,a::Function,l::Vector{<:Function},U0,V0,V_φ,U_reg,φh,dΩ...;assem_U = SparseMatrixAssembler(U0,V0),assem_adjoint = SparseMatrixAssembler(V0,U0),assem_deriv = SparseMatrixAssembler(U_reg,U_reg),ls::LinearSolver = LUSolver(),adjoint_ls::LinearSolver = LUSolver())","category":"page"},{"location":"reference/chainrules/#GridapTopOpt.RepeatingAffineFEStateMap","page":"ChainRules","title":"GridapTopOpt.RepeatingAffineFEStateMap","text":"struct RepeatingAffineFEStateMap <: AbstractFEStateMap\n\nA structure to enable the forward problem and pullback for affine finite element operators AffineFEOperator with multiple linear forms but only a single bilinear form.\n\nParameters\n\nbiform: IntegrandWithMeasure defining the bilinear form.\nliform: A vector of IntegrandWithMeasure defining the linear forms.\nspaces: Repeated finite element spaces.\nspaces_0: Original finite element spaces that are being repeated.\nplb_caches: A cache for the pullback operator.\nfwd_caches: A cache for the forward problem.\nadj_caches: A cache for the adjoint problem.\n\n\n\n\n\n","category":"type"},{"location":"reference/chainrules/#GridapTopOpt.RepeatingAffineFEStateMap-Tuple{Int64, Function, Vector{<:Function}, Any, Any, Any, Any, Any, Vararg{Any}}","page":"ChainRules","title":"GridapTopOpt.RepeatingAffineFEStateMap","text":"RepeatingAffineFEStateMap(\n  nblocks::Int,a::Function,l::Vector{<:Function},\n  U0,V0,V_φ,U_reg,φh,dΩ...;\n  assem_U = SparseMatrixAssembler(U0,V0),\n  assem_adjoint = SparseMatrixAssembler(V0,U0),\n  assem_deriv = SparseMatrixAssembler(U_reg,U_reg),\n  ls::LinearSolver = LUSolver(),\n  adjoint_ls::LinearSolver = LUSolver()\n)\n\nCreate an instance of RepeatingAffineFEStateMap given the number of blocks nblocks, a bilinear form a, a vector of linear form l as Function types, the trial and test spaces U and V, the FE space V_φ for φh, the FE space U_reg for derivatives, and the measures as additional arguments.\n\nOptional arguments enable specification of assemblers and linear solvers.\n\nNote\n\nThe resulting FEFunction will be a MultiFieldFEFunction (or GridapDistributed equivalent) where each field corresponds to an entry in the vector of linear forms\n\n\n\n\n\n","category":"method"},{"location":"reference/chainrules/#Advanced","page":"ChainRules","title":"Advanced","text":"","category":"section"},{"location":"reference/chainrules/#Inheriting-from-AbstractFEStateMap","page":"ChainRules","title":"Inheriting from AbstractFEStateMap","text":"","category":"section"},{"location":"reference/chainrules/#Existing-methods","page":"ChainRules","title":"Existing methods","text":"","category":"section"},{"location":"reference/chainrules/","page":"ChainRules","title":"ChainRules","text":"GridapTopOpt.rrule(φ_to_u::GridapTopOpt.AbstractFEStateMap,φh)\nGridapTopOpt.pullback","category":"page"},{"location":"reference/chainrules/#ChainRulesCore.rrule-Tuple{GridapTopOpt.AbstractFEStateMap, Any}","page":"ChainRules","title":"ChainRulesCore.rrule","text":"rrule(φ_to_u::AbstractFEStateMap,φh)\n\nReturn the evaluation of a AbstractFEStateMap and a a function for evaluating the pullback of φ_to_u. This enables compatiblity with ChainRules.jl\n\n\n\n\n\n","category":"method"},{"location":"reference/chainrules/#GridapTopOpt.pullback","page":"ChainRules","title":"GridapTopOpt.pullback","text":"pullback(φ_to_u::AbstractFEStateMap,uh,φh,du;updated)\n\nCompute ∂F∂u*dudφ at φh and uh using the adjoint method. I.e., let\n\n∂F∂u*dudφ = -λᵀ*dRdφ\n\nand solve the adjoint problem dRduᵀ*λ = ∂F∂uᵀ using adjoint_solve!.\n\n\n\n\n\n","category":"function"},{"location":"reference/chainrules/#Required-to-implement","page":"ChainRules","title":"Required to implement","text":"","category":"section"},{"location":"reference/chainrules/","page":"ChainRules","title":"ChainRules","text":"GridapTopOpt.forward_solve!\nGridapTopOpt.adjoint_solve!\nGridapTopOpt.update_adjoint_caches!\nGridapTopOpt.dRdφ\nGridapTopOpt.get_state(::GridapTopOpt.AbstractFEStateMap)\nGridapTopOpt.get_measure\nGridapTopOpt.get_spaces\nGridapTopOpt.get_assemblers\nGridapTopOpt.get_trial_space\nGridapTopOpt.get_test_space\nGridapTopOpt.get_aux_space\nGridapTopOpt.get_deriv_space\nGridapTopOpt.get_pde_assembler\nGridapTopOpt.get_deriv_assembler","category":"page"},{"location":"reference/chainrules/#GridapTopOpt.forward_solve!","page":"ChainRules","title":"GridapTopOpt.forward_solve!","text":"forward_solve!(φ_to_u::AbstractFEStateMap,φh)\n\nEvaluate the forward problem u given φ. This should compute the FE problem.\n\n\n\n\n\n","category":"function"},{"location":"reference/chainrules/#GridapTopOpt.adjoint_solve!","page":"ChainRules","title":"GridapTopOpt.adjoint_solve!","text":"adjoint_solve!(φ_to_u::AbstractFEStateMap,du::AbstractVector)\n\nEvaluate the solution to the adjoint problem given a RHS vector ∂F∂u denoted du. This should solve the linear problem dRduᵀ*λ = ∂F∂uᵀ.\n\n\n\n\n\n","category":"function"},{"location":"reference/chainrules/#GridapTopOpt.update_adjoint_caches!","page":"ChainRules","title":"GridapTopOpt.update_adjoint_caches!","text":"update_adjoint_caches!(φ_to_u::AbstractFEStateMap,uh,φh)\n\nUpdate the cache for the adjoint problem. This is usually a tuple of objects.\n\n\n\n\n\n","category":"function"},{"location":"reference/chainrules/#GridapTopOpt.dRdφ","page":"ChainRules","title":"GridapTopOpt.dRdφ","text":"dRdφ(φ_to_u::AbstractFEStateMap,uh,vh,φh)\n\nCompute the derivative with respect to φh of the residual R.\n\n\n\n\n\n","category":"function"},{"location":"reference/chainrules/#GridapTopOpt.get_state-Tuple{GridapTopOpt.AbstractFEStateMap}","page":"ChainRules","title":"GridapTopOpt.get_state","text":"get_state(m::AbstractFEStateMap)\n\nReturn the solution/state u to the FE problem.\n\n\n\n\n\n","category":"method"},{"location":"reference/chainrules/#GridapTopOpt.get_measure","page":"ChainRules","title":"GridapTopOpt.get_measure","text":"get_measure(m::AbstractFEStateMap)\n\nReturn the measures associated with the FE problem.\n\n\n\n\n\n","category":"function"},{"location":"reference/chainrules/#GridapTopOpt.get_spaces","page":"ChainRules","title":"GridapTopOpt.get_spaces","text":"get_spaces(m::AbstractFEStateMap)\n\nReturn a collection of FE spaces. The first four entires should correspond to get_trial_space, get_test_space, get_aux_space, and get_deriv_space unless these are overloaded for a particular implementation.\n\n\n\n\n\n","category":"function"},{"location":"reference/chainrules/#GridapTopOpt.get_assemblers","page":"ChainRules","title":"GridapTopOpt.get_assemblers","text":"get_assemblers(m::AbstractFEStateMap)\n\nReturn a collection of assemblers. The first two entires should correspond to get_pde_assembler and get_deriv_assembler unless these are overloaded for a particular implementation.\n\n\n\n\n\n","category":"function"},{"location":"reference/chainrules/#GridapTopOpt.get_trial_space","page":"ChainRules","title":"GridapTopOpt.get_trial_space","text":"get_trial_space(m::AbstractFEStateMap)\n\nReturn trial space for FE problem.\n\n\n\n\n\n","category":"function"},{"location":"reference/chainrules/#GridapTopOpt.get_test_space","page":"ChainRules","title":"GridapTopOpt.get_test_space","text":"get_test_space(m::AbstractFEStateMap)\n\nReturn test space for FE problem.\n\n\n\n\n\n","category":"function"},{"location":"reference/chainrules/#GridapTopOpt.get_aux_space","page":"ChainRules","title":"GridapTopOpt.get_aux_space","text":"get_aux_space(m::AbstractFEStateMap)\n\nReturn space for auxillary parameter.\n\n\n\n\n\n","category":"function"},{"location":"reference/chainrules/#GridapTopOpt.get_deriv_space","page":"ChainRules","title":"GridapTopOpt.get_deriv_space","text":"get_deriv_space(m::AbstractFEStateMap)\n\nReturn space for derivatives.\n\n\n\n\n\n","category":"function"},{"location":"reference/chainrules/#GridapTopOpt.get_pde_assembler","page":"ChainRules","title":"GridapTopOpt.get_pde_assembler","text":"get_pde_assembler(m::AbstractFEStateMap)\n\nReturn assembler for FE problem.\n\n\n\n\n\n","category":"function"},{"location":"reference/chainrules/#GridapTopOpt.get_deriv_assembler","page":"ChainRules","title":"GridapTopOpt.get_deriv_assembler","text":"get_deriv_assembler(m::AbstractFEStateMap)\n\nReturn assembler for derivatives.\n\n\n\n\n\n","category":"function"},{"location":"reference/chainrules/#IntegrandWithMeasure","page":"ChainRules","title":"IntegrandWithMeasure","text":"","category":"section"},{"location":"reference/chainrules/","page":"ChainRules","title":"ChainRules","text":"GridapTopOpt.IntegrandWithMeasure\nGridapTopOpt.gradient\nGridapTopOpt.jacobian","category":"page"},{"location":"reference/chainrules/#GridapTopOpt.IntegrandWithMeasure","page":"ChainRules","title":"GridapTopOpt.IntegrandWithMeasure","text":"struct IntegrandWithMeasure{A,B<:Tuple}\n\nA wrapper to enable serial or parallel partial differentation of an integral F using Gridap.gradient. This is required to allow automatic differentation with DistributedMeasure.\n\nProperties\n\nF  :: A: A function that returns a DomainContribution or DistributedDomainContribution.\ndΩ :: B: A tuple of measures.\n\n\n\n\n\n","category":"type"},{"location":"reference/chainrules/#Gridap.Fields.gradient","page":"ChainRules","title":"Gridap.Fields.gradient","text":"Gridap.gradient(F::IntegrandWithMeasure,uh::Vector,K::Int)\n\nGiven an an IntegrandWithMeasure F and a vector of FEFunctions uh (excluding measures) evaluate the partial derivative of F.F with respect to uh[K].\n\nExample\n\nSuppose uh and φh are FEFunctions with measures dΩ and dΓ_N. Then the partial derivative of a function J wrt to φh is computed via\n\nJ(u,φ,dΩ,dΓ_N) = ∫(f(u,φ))dΩ + ∫(g(u,φ))dΓ_N\nJ_iwm = IntegrandWithMeasure(J,(dΩ,dΓ_N))\n∂J∂φh = ∇(J_iwm,[uh,φh],2)\n\nwhere f and g are user defined.\n\n\n\n\n\n","category":"function"},{"location":"reference/chainrules/#Gridap.Algebra.jacobian","page":"ChainRules","title":"Gridap.Algebra.jacobian","text":"Gridap.jacobian(F::IntegrandWithMeasure,uh::Vector,K::Int)\n\nGiven an an IntegrandWithMeasure F and a vector of FEFunctions or CellField uh (excluding measures) evaluate the Jacobian F.F with respect to uh[K].\n\n\n\n\n\n","category":"function"},{"location":"deprecated/tutorials/minimum_thermal_compliance/#Minimum-thermal-compliance","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"","category":"section"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"The goal of this tutorial is to learn","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"How to formulate a topology optimisation problem\nHow to describe the problem over a fixed computational domain D via the level-set method.\nHow to setup and solve the problem in GridapTopOpt","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"We consider the following extensions at the end of the tutorial:","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"How to extend problems to 3D and utilise PETSc solvers\nHow to solve problems with nonlinear state equations and use automatic differentiation\nHow to run problems in MPI mode","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"We will first consider formulation of the state equations and a topology optimisation problem in a continuous setting. We will then discretise via a level set function in a fixed computational regime. Note that this approach corresponds to an \"optimise-then-discretise\" approach [4] where shape derivatives are calculated analytically in the continuous space then relaxed via a level set function varphi. Automatic differentiation can be used to calculate these quantities and is discussed here.","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/#State-equations","page":"Minimum thermal compliance","title":"State equations","text":"","category":"section"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"The homogeneous steady-state heat equation (equivalently Laplace's equation) is perhaps one of the most well-understood partial differential equations and usually the first introduced to an undergraduate student in applied mathematics. For this reason, we will use it to describe the heat transfer through a solid and how one comes to the notion of optimising the shape of that solid.","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"Consider the geometric conditions outlined in the Figure 1 and suppose that we prescribe the following conditions:","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"Heat source: unitary normal heat flow across Gamma_N.\nInsulating: zero normal heat flow across partialOmegasetminusGamma_N,\nHeat sink: zero heat on Gamma_D.","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"(Image: )\nFigure 1: The setup for the two-dimensional minimum thermal compliance problem","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"Physically we can imagine this as describing the transfer of heat through a domain Omega from the sources to the sinks. From a mathematical perspective, we can write down the partial differential equations describing this as","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"beginaligned\n-nabla(kappanabla u) = 0textin Omega\nkappanabla ucdotboldsymboln = gtexton Gamma_N\nkappanabla ucdotboldsymboln = 0texton partialOmegasetminusGamma_N\nu = 0texton Gamma_D\nendaligned","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"where kappa is the diffusivity through Omega and boldsymboln is the unit normal on the boundary. The weak formulation of the above strong formulation can be found by multiplying by a test function v and applying integration by parts. This gives","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"beginaligned\ntextitFind uin H^1_Gamma_D(Omega)textit such that\nint_Omegakappaboldsymbolnablaucdotboldsymbolnablavmathrmdboldsymbolx = int_Gamma_Ngvmathrmdsforall vin H^1_Gamma_D(Omega)\nendaligned","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"where H^1_Gamma_D(Omega)=vin H^1(Omega)v=0text on Gamma_D.","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/#Optimisation-problem","page":"Minimum thermal compliance","title":"Optimisation problem","text":"","category":"section"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"For this tutorial, we consider minimising the thermal compliance (or dissipated energy) as discussed in [1,2]. The corresponding optimisation problem is","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"beginaligned\nmin_OmegainmathcalUJ(Omega)=int_Omegakappalvertboldsymbolnablaurvert^2mathrmdboldsymbolx\ntextst operatornameVol(Omega)=V_f\nleft\nbeginaligned\ntextitFind uin H^1_Gamma_D(Omega)textit such that\nint_Omegakappaboldsymbolnablaucdotboldsymbolnablavmathrmdboldsymbolx = int_Gamma_Ngvmathrmdsforall vin H^1_Gamma_D(Omega)\nendaligned\nright\nendaligned","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"where operatornameVol(Omega)=int_Omega1mathrmdboldsymbolx. This objective is equivalent to equivalent to maximising the heat transfer efficiency through Omega.","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/#Shape-differentiation","page":"Minimum thermal compliance","title":"Shape differentiation","text":"","category":"section"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"We consider the change in quantities under the variation of the domain using shape derivatives. For the purpose of this tutorial we will give the mathematical description of a shape derivative along with the shape derivatives of the functionals J and operatornameVol. Further discussion can be found in [3,4].","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"Suppose that we consider smooth variations of the domain Omega of the form Omega_boldsymboltheta =(boldsymbolI+boldsymboltheta)(Omega), where boldsymboltheta in W^1infty(mathbbR^dmathbbR^d). Then the following definition and lemma follow:","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"note: Definition [3]\nThe shape derivative of J(Omega) at Omega is defined as the Fréchet derivative in W^1 infty(mathbbR^d mathbbR^d) at boldsymboltheta of the application boldsymboltheta rightarrow J(Omega_boldsymboltheta), i.e.,J(Omega_boldsymboltheta)(Omega)=J(Omega)+J^prime(Omega)(boldsymboltheta)+mathrmo(boldsymboltheta)with lim _boldsymboltheta rightarrow 0 fraclvertmathrmo(boldsymboltheta)rvertboldsymboltheta=0 where the shape derivative J^prime(Omega) is a continuous linear form on W^1 infty(mathbbR^d mathbbR^d)","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"The shape derivatives of J and operatornameVol are then","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"J(Omega)(boldsymboltheta) = -int_Gammakappaboldsymbolnabla(u)cdotboldsymbolnabla(u)boldsymbolthetacdotboldsymbolnmathrmds","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"and","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"operatornameVol(Omega)(boldsymboltheta) = int_Gammaboldsymbolthetacdotboldsymbolnmathrmds","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"where Gamma = partialOmegasetminus(Gamma_DcupGamma_N). The first of these follows from Céa's formal method (see discussion in [3,4]), while the latter result follows from application of Lemma 4 of [3]. Finally, taking a deformation field according to boldsymboltheta=-qboldsymboln amounts to a descent direction according to the definition above. This gives","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"J(Omega)(-qboldsymboln) = int_Gammaqkappaboldsymbolnabla(u)cdotboldsymbolnabla(u)mathrmds","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"and","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"operatornameVol(Omega)(-qboldsymboln) = -int_Gammaqmathrmds","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/#Discretisation-via-a-level-set","page":"Minimum thermal compliance","title":"Discretisation via a level set","text":"","category":"section"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"Suppose that we attribute a level set function varphiDrightarrowmathbbR to our domain Omegasubset D with barOmega=lbrace boldsymbolxvarphi(boldsymbolx)leq0rbrace and Omega^complement=lbrace boldsymbolxvarphi(boldsymbolx)0rbrace. We can then define a smooth characteristic function ImathbbRrightarrowepsilon1 as I(varphi)=(1-H(varphi))+epsilon H(varphi) where H is a smoothed Heaviside function with smoothing radius eta, and epsilonll1 allows for an ersatz material approximation. Of course, epsilon can be taken as zero depending on the computational regime. Over the fixed computational domain we may relax integrals to be over all of D via mathrmdboldsymbolx= H(varphi)mathrmdboldsymbolx and mathrmds = H(varphi)lvertnablavarphirvertmathrmdboldsymbolx. The above optimisation problem then rewrites in terms of varphi as","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"beginaligned\nmin_varphiJ(varphi)=int_DI(varphi)kappalvertboldsymbolnablaurvert^2mathrmdboldsymbolx\ntextst C(varphi)=0\nleft\nbeginaligned\ntextitFind uin H^1_Gamma_D(D)\nint_DI(varphi)kappaboldsymbolnabla(u)cdotboldsymbolnabla(v)mathrmdboldsymbolx = int_Gamma_Nvmathrmdsforall vin H^1_Gamma_D(D)\nendaligned\nright\nendaligned","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"where we retain an exact triangulation and measure of  Gamma_N as this is a fixed boundary. In addition, we have rewritten the volume constraint as","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"beginaligned\nC(varphi)=int_D (rho(varphi) - V_f)operatornameVol(D)mathrmdboldsymbolx\n=int_D rho(varphi)mathrmdboldsymbolxoperatornameVol(D) - V_f\n=int_OmegamathrmdboldsymbolxoperatornameVol(D)-V_f = operatornameVol(Omega)operatornameVol(D)-V_f\nendaligned","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"where rho(varphi)=1-H(varphi) is the smoothed volume density function.","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"note: Note\nIn GridapTopOpt we assume constraints are of the integral form above.","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"The shape derivatives from the previous section can be relaxed over the computational domain as","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"J(varphi)(-qboldsymboln) = int_Dqkappaboldsymbolnabla(u)cdotboldsymbolnabla(u)H(varphi)lvertnablavarphirvertmathrmdboldsymbolx","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"and","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"C(varphi)(-qboldsymboln) = -int_DqH(varphi)lvertnablavarphirvertmathrmdboldsymbolxoperatornameVol(D)","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/#Computational-method","page":"Minimum thermal compliance","title":"Computational method","text":"","category":"section"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"In the following, we discuss the implementation of the above optimisation problem in GridapTopOpt. For the purpose of this tutorial we break the computational formulation into chunks.","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"The first step in creating our script is to load any packages required:","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"using GridapTopOpt, Gridap","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/#Parameters","page":"Minimum thermal compliance","title":"Parameters","text":"","category":"section"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"The following are user defined parameters for the problem. These parameters will be discussed over the course of this tutorial.","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"# FE parameters\norder = 1                                               # Finite element order\nxmax = ymax = 1.0                                       # Domain size\ndom = (0,xmax,0,ymax)                                   # Bounding domain\nel_size = (200,200)                                     # Mesh partition size\nprop_Γ_N = 0.2                                          # Γ_N size parameter\nprop_Γ_D = 0.2                                          # Γ_D size parameter\nf_Γ_N(x) = (x[1] ≈ xmax &&                              # Γ_N indicator function\n  ymax/2-ymax*prop_Γ_N/2 - eps() <= x[2] <= ymax/2+ymax*prop_Γ_N/2 + eps())\nf_Γ_D(x) = (x[1] ≈ 0.0 &&                               # Γ_D indicator function\n  (x[2] <= ymax*prop_Γ_D + eps() || x[2] >= ymax-ymax*prop_Γ_D - eps()))\n# FD parameters\nγ = 0.1                                                 # HJ equation time step coefficient\nγ_reinit = 0.5                                          # Reinit. equation time step coefficient\nmax_steps = floor(Int,minimum(el_size)/10)              # Max steps for advection\ntol = 1/(5order^2)/minimum(el_size)                     # Advection tolerance\n# Problem parameters\nκ = 1                                                   # Diffusivity\ng = 1                                                   # Heat flow in\nvf = 0.4                                                # Volume fraction constraint\nlsf_func = initial_lsf(4,0.2)                           # Initial level set function\niter_mod = 10                                           # Output VTK files every 10th iteration\npath = \"./results/tut1/\"                                # Output path\nmkpath(path)                                            # Create path","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/#Finite-element-setup","page":"Minimum thermal compliance","title":"Finite element setup","text":"","category":"section"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"We first create a Cartesian mesh over 0x_maxtimes0y_max with partition size el_size by creating an object CartesianDiscreteModel. In addition, we label the boundaries Gamma_D and Gamma_N using the update_labels! function.","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"# Model\nmodel = CartesianDiscreteModel(dom,el_size);\nupdate_labels!(1,model,f_Γ_D,\"Gamma_D\")\nupdate_labels!(2,model,f_Γ_N,\"Gamma_N\")","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"The first argument of update_labels! indicates the label number associated to the region as indicated by the functions f_Γ_D and f_Γ_N. These functions should take a vector x and return true or false depending on whether a point is present in this region.","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"Once the model is defined we create an integration mesh and measure for both Omega and Gamma_N. These are built using","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"# Triangulation and measures\nΩ = Triangulation(model)\nΓ_N = BoundaryTriangulation(model,tags=\"Gamma_N\")\ndΩ = Measure(Ω,2*order)\ndΓ_N = Measure(Γ_N,2*order)","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"where 2*order indicates the quadrature degree for numerical integration.","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"The final stage of the finite element setup is the approximation of the finite element spaces. This is given as follows:","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"# Spaces\nreffe = ReferenceFE(lagrangian,Float64,order)\nV = TestFESpace(model,reffe;dirichlet_tags=[\"Gamma_D\"])\nU = TrialFESpace(V,0.0)\nV_φ = TestFESpace(model,reffe)\nV_reg = TestFESpace(model,reffe;dirichlet_tags=[\"Gamma_N\"])\nU_reg = TrialFESpace(V_reg,0)","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"In the above, we first define a scalar-valued Lagrangian reference element. This is then used to define the test space V and trial space U corresponding to H^1_Gamma_D(Omega). We then construct an FE space V_φ over which the level set function is defined, along with an FE test space V_reg and trial space U_reg over which derivatives are defined. We require that V_reg and U_reg have zero Dirichlet boundary conditions over regions where the extended shape sensitivity is zero. In general, we allow Dirichlet boundaries to have non-zero shape sensitivity.","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/#Initial-level-set-function-and-interpolant","page":"Minimum thermal compliance","title":"Initial level set function and interpolant","text":"","category":"section"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"We interpolate an initial level set function onto V_φ given a function lsf_func using the interpolate provided by Gridap.","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"# Level set and interpolator\nφh = interpolate(lsf_func,V_φ)","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"For this problem we set lsf_func using the function initial_lsf in the problem parameters. This generates an initial level set according to","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"varphi_xia(boldsymbolx)=-frac14 prod_i^D(cos(xipi x_i)) - a4","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"with xia=(402) and D=2 in two dimensions.","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"We also generate a smooth characteristic function of radius eta using:","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"interp = SmoothErsatzMaterialInterpolation(η = 2*maximum(get_el_Δ(model)))\nI,H,DH,ρ = interp.I,interp.H,interp.DH,interp.ρ","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"This the SmoothErsatzMaterialInterpolation structure defines the characteristic or interpolator I, the smoothed Heaviside function H and it's derivative DH, and the smoothed density function ρ. Below we visualise φh and the smoothed density function ρ at φh:","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"(Image: )\nFigure 2: A visualisation of the initial level set function and the interpolated density function rho for Omega.","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"Optional: we can generate a VTK file for visualisation in Paraview via","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"writevtk(Ω,\"initial_lsf\",cellfields=[\"phi\"=>φh,\n  \"ρ(phi)\"=>(ρ ∘ φh),\"|nabla(phi)|\"=>(norm ∘ ∇(φh))])","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"Note that the operator ∘ is used to compose other Julia Functions with Gridap FEFunctions. This will be used extensively as we progress through the tutorial.","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/#Weak-formulation-and-the-state-map","page":"Minimum thermal compliance","title":"Weak formulation and the state map","text":"","category":"section"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"The weak formulation for the problem above can be written as","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"# Weak formulation\na(u,v,φ,dΩ,dΓ_N) = ∫((I ∘ φ)*κ*∇(u)⋅∇(v))dΩ\nl(v,φ,dΩ,dΓ_N) = ∫(g*v)dΓ_N","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"where the ∘ operator composes the interpolator I with the level set function φ.","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"warning: Warning\nThe measures must be included as arguments at the end of all functionals. This ensures compatibility with Gridap's automatic differentiation.","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"At this point we can build an AffineFEStateMap. This structure is designed to","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"Enable the forward problem that solves a Gridap AffineFEOperator; and\nEncode the implicit dependence of the solution u on the level set function φ to enable the differentiation of u.","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"state_map = AffineFEStateMap(a,l,U,V,V_φ,U_reg,φh,dΩ,dΓ_N)","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/#Optimisation-functionals","page":"Minimum thermal compliance","title":"Optimisation functionals","text":"","category":"section"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"The objective functional J and it's shape derivative is given by","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"# Objective and constraints\nJ(u,φ,dΩ,dΓ_N) = ∫((I ∘ φ)*κ*∇(u)⋅∇(u))dΩ\ndJ(q,u,φ,dΩ,dΓ_N) = ∫(κ*∇(u)⋅∇(u)*q*(DH ∘ φ)*(norm ∘ ∇(φ)))dΩ","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"while the constraint on the volume and its derivative is","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"vol_D = sum(∫(1)dΩ)\nC(u,φ,dΩ,dΓ_N) = ∫(((ρ ∘ φ) - vf)/vol_D)dΩ\ndC(q,u,φ,dΩ,dΓ_N) = ∫(-1/vol_D*q*(DH ∘ φ)*(norm ∘ ∇(φ)))dΩ","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"We can now create an object PDEConstrainedFunctionals that handles the objective and constraints, and their analytic or automatic differentiation.","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"pcfs = PDEConstrainedFunctionals(J,[C],state_map,analytic_dJ=dJ,analytic_dC=[dC])","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"In this case, the analytic shape derivatives are passed as optional arguments. When these are not given, automatic differentiation in φ is used.","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/#Velocity-extension-regularisation-method","page":"Minimum thermal compliance","title":"Velocity extension-regularisation method","text":"","category":"section"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"The Hilbertian extension-regularisation [4] method involves solving an identification problem over a Hilbert space H on D with inner product langlecdotcdotrangle_H: Find g_Omegain H such that langle g_Omegaqrangle_H =-J^prime(Omega)(qboldsymboln) forall qin H","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"This provides two benefits:","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"It naturally extends the shape sensitivity from partialOmega onto the bounding domain D; and\nensures a descent direction for J(Omega) with additional regularity (i.e., H as opposed to L^2(partialOmega)).","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"For our problem above we take the inner product","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"langle pqrangle_H=int_Dalpha^2nabla(p)nabla(q)+pqmathrmdboldsymbolx","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"where alpha is the smoothing length scale. Equivalently in our script we have","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"# Velocity extension\nα = 4*maximum(get_el_Δ(model))\na_hilb(p,q) =∫(α^2*∇(p)⋅∇(q) + p*q)dΩ","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"We then build an object VelocityExtension. This object provides a method project! that applies the Hilbertian velocity-extension method to a given shape derivative.","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"vel_ext = VelocityExtension(a_hilb,U_reg,V_reg)","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/#Advection-and-reinitialisation","page":"Minimum thermal compliance","title":"Advection and reinitialisation","text":"","category":"section"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"To advect the level set function, we solve the Hamilton-Jacobi evolution equation [3,4,5]. This is given by","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"fracpartialphipartial t + V(boldsymbolx)lVertboldsymbolnablaphirVert = 0","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"with phi(0boldsymbolx)=phi_0(boldsymbolx) and boldsymbolxin Dtin(0T).","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"After advection of the interface, we solve the reinitialisation equation to find an equivalent signed distance function for the given level set function. This is given by","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"fracpartialphipartial t + mathrmsign(phi_0)(lVertboldsymbolnablaphirVert-1) = 0","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"with phi(0boldsymbolx)=phi_0(boldsymbolx) and boldsymbolxin Dtin(0T).","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"Both of these equations can be solved numerically on a Cartesian mesh using a first order Godunov upwind difference scheme based on [5]. This functionality is provided by the following objects:","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"# Finite difference scheme\nscheme = FirstOrderStencil(length(el_size),Float64)\nls_evo = HamiltonJacobiEvolution(scheme,model,V_φ,tol,max_steps)","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"In the above we first build an object FirstOrderStencil that represents a finite difference stencil for a single step of the Hamilton-Jacobi evolution equation and reinitialisation equation. We use length(el_size) to indicate the dimension of the problem. We then create an HamiltonJacobiEvolution which enables finite differencing on order O finite elements in serial or parallel. The HamiltonJacobiEvolution object provides two important methods evolve! and reinit! that correspond to solving the Hamilton-Jacobi evolution equation and reinitialisation equation, respectively.","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/#Optimiser,-visualisation-and-IO","page":"Minimum thermal compliance","title":"Optimiser, visualisation and IO","text":"","category":"section"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"We may now create the optimiser object. This structure holds all information regarding the optimisation problem that we wish to solve and implements an optimisation algorithm as a Julia iterator. For the purpose of this tutorial we use a standard augmented Lagrangian method based on [6]. In our script, we create an instance of the AugmentedLagrangian via","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"# Optimiser\noptimiser = AugmentedLagrangian(pcfs,ls_evo,vel_ext,φh;γ,γ_reinit,verbose=true,constraint_names=[:Vol])","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"As optimisers inheriting from GridapTopOpt.Optimiser implement Julia's iterator functionality, we can solve the optimisation problem to convergence by iterating over the optimiser:","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"# Solve\nfor (it,uh,φh) in optimiser end","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"This allows the user to inject code between iterations. For example, we can write VTK files for visualisation and save the history using the following:","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"# Solve\nfor (it,uh,φh) in optimiser\n  data = [\"phi\"=>φh,\"H(phi)\"=>(H ∘ φh),\"|nabla(phi)|\"=>(norm ∘ ∇(φh)),\"uh\"=>uh]\n  iszero(it % iter_mod) && (writevtk(Ω,path*\"struc_$it\",cellfields=data);GC.gc())\n  write_history(path*\"/history.txt\",get_history(optimiser))\nend","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"warning: Warning\nDue to a possible memory leak in Julia 1.9.* IO, we include a call to the garbage collector using GC.gc().","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"Depending on whether we use iszero(it % iter_mod), the VTK file for the final structure may need to be saved using","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"# Final structure\nit = get_history(optimiser).niter; uh = get_state(pcfs)\nwritevtk(Ω,path*\"_$it\",cellfields=[\"phi\"=>φh,\n  \"H(phi)\"=>(H ∘ φh),\"|nabla(phi)|\"=>(norm ∘ ∇(φh)),\"uh\"=>uh])","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/#The-full-script","page":"Minimum thermal compliance","title":"The full script","text":"","category":"section"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"<details><summary>Script 1: combining the above gives (click me!)</summary>","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"using Gridap, GridapTopOpt\n\n# FE parameters\norder = 1                                               # Finite element order\nxmax = ymax = 1.0                                       # Domain size\ndom = (0,xmax,0,ymax)                                   # Bounding domain\nel_size = (200,200)                                     # Mesh partition size\nprop_Γ_N = 0.2                                          # Γ_N size parameter\nprop_Γ_D = 0.2                                          # Γ_D size parameter\nf_Γ_N(x) = (x[1] ≈ xmax &&                              # Γ_N indicator function\n  ymax/2-ymax*prop_Γ_N/2 - eps() <= x[2] <= ymax/2+ymax*prop_Γ_N/2 + eps())\nf_Γ_D(x) = (x[1] ≈ 0.0 &&                               # Γ_D indicator function\n  (x[2] <= ymax*prop_Γ_D + eps() || x[2] >= ymax-ymax*prop_Γ_D - eps()))\n# FD parameters\nγ = 0.1                                                 # HJ equation time step coefficient\nγ_reinit = 0.5                                          # Reinit. equation time step coefficient\nmax_steps = floor(Int,minimum(el_size)/10)              # Max steps for advection\ntol = 1/(5order^2)/minimum(el_size)          # Advection tolerance\n# Problem parameters\nκ = 1                                                   # Diffusivity\ng = 1                                                   # Heat flow in\nvf = 0.4                                                # Volume fraction constraint\nlsf_func = initial_lsf(4,0.2)                           # Initial level set function\niter_mod = 10                                           # Output VTK files every 10th iteration\npath = \"./results/tut1/\"                                # Output path\nmkpath(path)                                            # Create path\n# Model\nmodel = CartesianDiscreteModel(dom,el_size);\nupdate_labels!(1,model,f_Γ_D,\"Gamma_D\")\nupdate_labels!(2,model,f_Γ_N,\"Gamma_N\")\n# Triangulation and measures\nΩ = Triangulation(model)\nΓ_N = BoundaryTriangulation(model,tags=\"Gamma_N\")\ndΩ = Measure(Ω,2*order)\ndΓ_N = Measure(Γ_N,2*order)\n# Spaces\nreffe = ReferenceFE(lagrangian,Float64,order)\nV = TestFESpace(model,reffe;dirichlet_tags=[\"Gamma_D\"])\nU = TrialFESpace(V,0.0)\nV_φ = TestFESpace(model,reffe)\nV_reg = TestFESpace(model,reffe;dirichlet_tags=[\"Gamma_N\"])\nU_reg = TrialFESpace(V_reg,0)\n# Level set and interpolator\nφh = interpolate(lsf_func,V_φ)\ninterp = SmoothErsatzMaterialInterpolation(η = 2*maximum(get_el_Δ(model)))\nI,H,DH,ρ = interp.I,interp.H,interp.DH,interp.ρ\n# Weak formulation\na(u,v,φ,dΩ,dΓ_N) = ∫((I ∘ φ)*κ*∇(u)⋅∇(v))dΩ\nl(v,φ,dΩ,dΓ_N) = ∫(g*v)dΓ_N\nstate_map = AffineFEStateMap(a,l,U,V,V_φ,U_reg,φh,dΩ,dΓ_N)\n# Objective and constraints\nJ(u,φ,dΩ,dΓ_N) = ∫((I ∘ φ)*κ*∇(u)⋅∇(u))dΩ\ndJ(q,u,φ,dΩ,dΓ_N) = ∫(κ*∇(u)⋅∇(u)*q*(DH ∘ φ)*(norm ∘ ∇(φ)))dΩ\nvol_D = sum(∫(1)dΩ)\nC(u,φ,dΩ,dΓ_N) = ∫(((ρ ∘ φ) - vf)/vol_D)dΩ\ndC(q,u,φ,dΩ,dΓ_N) = ∫(-1/vol_D*q*(DH ∘ φ)*(norm ∘ ∇(φ)))dΩ\npcfs = PDEConstrainedFunctionals(J,[C],state_map,analytic_dJ=dJ,analytic_dC=[dC])\n# Velocity extension\nα = 4*maximum(get_el_Δ(model))\na_hilb(p,q) =∫(α^2*∇(p)⋅∇(q) + p*q)dΩ\nvel_ext = VelocityExtension(a_hilb,U_reg,V_reg)\n# Finite difference scheme\nscheme = FirstOrderStencil(length(el_size),Float64)\nls_evo = HamiltonJacobiEvolution(scheme,model,V_φ,tol,max_steps)\n# Optimiser\noptimiser = AugmentedLagrangian(pcfs,ls_evo,vel_ext,φh;γ,γ_reinit,verbose=true,constraint_names=[:Vol])\n# Solve\nfor (it,uh,φh) in optimiser\n  data = [\"phi\"=>φh,\"H(phi)\"=>(H ∘ φh),\"|nabla(phi)|\"=>(norm ∘ ∇(φh)),\"uh\"=>uh]\n  iszero(it % iter_mod) && (writevtk(Ω,path*\"struc_$it\",cellfields=data);GC.gc())\n  write_history(path*\"/history.txt\",get_history(optimiser))\nend\n# Final structure\nit = get_history(optimiser).niter; uh = get_state(pcfs)\nwritevtk(Ω,path*\"struc_$it\",cellfields=[\"phi\"=>φh,\n  \"H(phi)\"=>(H ∘ φh),\"|nabla(phi)|\"=>(norm ∘ ∇(φh)),\"uh\"=>uh])","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"</details>","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"Running this problem until convergence gives a final result of","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"Iteration: 102 | L=1.1256e-01, J=1.1264e-01, Vol=-3.6281e-04, γ=5.6250e-02","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"with the optimised domain Omega given by","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"(Image: )\nFigure 3: Visualisation of Omega using the isovolume with varphileq0.","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/#Extensions","page":"Minimum thermal compliance","title":"Extensions","text":"","category":"section"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"In the following we outline several extensions to the avoid optimisation problem.","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"note: Note\nWe assume that PETSc and MPI have been installed correctly. Please see PETSc instructions and MPI instructions for additional information.","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/#3D-with-PETSc","page":"Minimum thermal compliance","title":"3D with PETSc","text":"","category":"section"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"The first and most straightforward in terms of programmatic changes is extending the problem to 3D. For this extension, we consider the following setup for the boundary conditions:","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"(Image: )\nFigure 4: The setup for the three-dimensional minimum thermal compliance problem.","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"We use a unit cube for the bounding domain D with 50^3 elements. This corresponds to changing lines 5-7 in the above script to","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"xmax=ymax=zmax=1.0                                      # Domain size\ndom = (0,xmax,0,ymax,0,zmax)                            # Bounding domain\nel_size = (100,100,100)                                 # Mesh partition size","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"To apply the boundary conditions per Figure 4, we also adjust the boundary indicator functions on lines 10-13 to","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"f_Γ_N(x) = (x[1] ≈ xmax) &&                             # Γ_N indicator function\n  (ymax/2-ymax*prop_Γ_N/2 - eps() <= x[2] <= ymax/2+ymax*prop_Γ_N/2 + eps()) &&\n  (zmax/2-zmax*prop_Γ_N/2 - eps() <= x[3] <= zmax/2+zmax*prop_Γ_N/2 + eps())\nf_Γ_D(x) = (x[1] ≈ 0.0) &&                              # Γ_D indicator function\n  (x[2] <= ymax*prop_Γ_D + eps() || x[2] >= ymax-ymax*prop_Γ_D - eps()) &&\n  (x[3] <= zmax*prop_Γ_D + eps() || x[3] >= zmax-zmax*prop_Γ_D - eps())","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"We adjust the output path on line 25 to be","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"path = \"./results/tut1_3d/\"                             # Output path","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"Finally, we adjust the finite difference parameters on lines 17-18 to","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"max_steps = floor(Int,minimum(el_size)/3)               # Max steps for advection\ntol = 1/(2order^2)/minimum(el_size)           # Advection tolerance","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"<details><summary>Script 2: combining the above gives (click me!)</summary>","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"using Gridap, GridapTopOpt\n\n# FE parameters\norder = 1                                               # Finite element order\nxmax=ymax=zmax=1.0                                      # Domain size\ndom = (0,xmax,0,ymax,0,zmax)                            # Bounding domain\nel_size = (100,100,100)                                 # Mesh partition size\nprop_Γ_N = 0.2                                          # Γ_N size parameter\nprop_Γ_D = 0.2                                          # Γ_D size parameter\nf_Γ_N(x) = (x[1] ≈ xmax) &&                             # Γ_N indicator function\n  (ymax/2-ymax*prop_Γ_N/2 - eps() <= x[2] <= ymax/2+ymax*prop_Γ_N/2 + eps()) &&\n  (zmax/2-zmax*prop_Γ_N/2 - eps() <= x[3] <= zmax/2+zmax*prop_Γ_N/2 + eps())\nf_Γ_D(x) = (x[1] ≈ 0.0) &&                              # Γ_D indicator function\n  (x[2] <= ymax*prop_Γ_D + eps() || x[2] >= ymax-ymax*prop_Γ_D - eps()) &&\n  (x[3] <= zmax*prop_Γ_D + eps() || x[3] >= zmax-zmax*prop_Γ_D - eps())\n# FD parameters\nγ = 0.1                                                 # HJ equation time step coefficient\nγ_reinit = 0.5                                          # Reinit. equation time step coefficient\nmax_steps = floor(Int,minimum(el_size)/3)               # Max steps for advection\ntol = 1/(2order^2)/minimum(el_size)           # Advection tolerance\n# Problem parameters\nκ = 1                                                   # Diffusivity\ng = 1                                                   # Heat flow in\nvf = 0.4                                                # Volume fraction constraint\nlsf_func = initial_lsf(4,0.2)                           # Initial level set function\niter_mod = 10                                           # Output VTK files every 10th iteration\npath = \"./results/tut1_3d/\"                             # Output path\nmkpath(path)                                            # Create path\n# Model\nmodel = CartesianDiscreteModel(dom,el_size);\nupdate_labels!(1,model,f_Γ_D,\"Gamma_D\")\nupdate_labels!(2,model,f_Γ_N,\"Gamma_N\")\n# Triangulation and measures\nΩ = Triangulation(model)\nΓ_N = BoundaryTriangulation(model,tags=\"Gamma_N\")\ndΩ = Measure(Ω,2*order)\ndΓ_N = Measure(Γ_N,2*order)\n# Spaces\nreffe = ReferenceFE(lagrangian,Float64,order)\nV = TestFESpace(model,reffe;dirichlet_tags=[\"Gamma_D\"])\nU = TrialFESpace(V,0.0)\nV_φ = TestFESpace(model,reffe)\nV_reg = TestFESpace(model,reffe;dirichlet_tags=[\"Gamma_N\"])\nU_reg = TrialFESpace(V_reg,0)\n# Level set and interpolator\nφh = interpolate(lsf_func,V_φ)\ninterp = SmoothErsatzMaterialInterpolation(η = 2*maximum(get_el_Δ(model)))\nI,H,DH,ρ = interp.I,interp.H,interp.DH,interp.ρ\n# Weak formulation\na(u,v,φ,dΩ,dΓ_N) = ∫((I ∘ φ)*κ*∇(u)⋅∇(v))dΩ\nl(v,φ,dΩ,dΓ_N) = ∫(g*v)dΓ_N\nstate_map = AffineFEStateMap(a,l,U,V,V_φ,U_reg,φh,dΩ,dΓ_N)\n# Objective and constraints\nJ(u,φ,dΩ,dΓ_N) = ∫((I ∘ φ)*κ*∇(u)⋅∇(u))dΩ\ndJ(q,u,φ,dΩ,dΓ_N) = ∫(κ*∇(u)⋅∇(u)*q*(DH ∘ φ)*(norm ∘ ∇(φ)))dΩ\nvol_D = sum(∫(1)dΩ)\nC(u,φ,dΩ,dΓ_N) = ∫(((ρ ∘ φ) - vf)/vol_D)dΩ\ndC(q,u,φ,dΩ,dΓ_N) = ∫(-1/vol_D*q*(DH ∘ φ)*(norm ∘ ∇(φ)))dΩ\npcfs = PDEConstrainedFunctionals(J,[C],state_map,analytic_dJ=dJ,analytic_dC=[dC])\n# Velocity extension\nα = 4*maximum(get_el_Δ(model))\na_hilb(p,q) =∫(α^2*∇(p)⋅∇(q) + p*q)dΩ\nvel_ext = VelocityExtension(a_hilb,U_reg,V_reg)\n# Finite difference scheme\nscheme = FirstOrderStencil(length(el_size),Float64)\nls_evo = HamiltonJacobiEvolution(scheme,model,V_φ,tol,max_steps)\n# Optimiser\noptimiser = AugmentedLagrangian(pcfs,ls_evo,vel_ext,φh;γ,γ_reinit,verbose=true,constraint_names=[:Vol])\n# Solve\nfor (it,uh,φh) in optimiser\n  data = [\"phi\"=>φh,\"H(phi)\"=>(H ∘ φh),\"|nabla(phi)|\"=>(norm ∘ ∇(φh)),\"uh\"=>uh]\n  iszero(it % iter_mod) && (writevtk(Ω,path*\"struc_$it\",cellfields=data);GC.gc())\n  write_history(path*\"/history.txt\",get_history(optimiser))\nend\n# Final structure\nit = get_history(optimiser).niter; uh = get_state(pcfs)\nwritevtk(Ω,path*\"struc_$it\",cellfields=[\"phi\"=>φh,\n  \"H(phi)\"=>(H ∘ φh),\"|nabla(phi)|\"=>(norm ∘ ∇(φh)),\"uh\"=>uh])","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"</details>","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"At this stage the problem will not be possible to run as we're using a standard LU solver. For this reason we now consider adjusting Script 2 to use an iterative solver provided by PETSc. We rely on the GridapPETSc satellite package to utilise PETSc. This provides the necessary structures to efficiently interface with the linear and nonlinear solvers provided by the PETSc library. To call GridapPETSc we change line 1 of Script 2 to","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"using Gridap, GridapPETSc, SparseMatricesCSR, GridapTopOpt","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"We also use SparseMatricesCSR as PETSc is based on the SparseMatrixCSR datatype. We then replace line 52 and 63 with","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"# State map\nTm = SparseMatrixCSR{0,PetscScalar,PetscInt}\nTv = Vector{PetscScalar}\nstate_map = AffineFEStateMap(\n  a,l,U,V,V_φ,U_reg,φh,dΩ,dΓ_N;\n  assem_U = SparseMatrixAssembler(Tm,Tv,U,V),\n  assem_adjoint = SparseMatrixAssembler(Tm,Tv,V,U),\n  assem_deriv = SparseMatrixAssembler(Tm,Tv,U_reg,U_reg),\n  ls = PETScLinearSolver(),adjoint_ls = PETScLinearSolver()\n)","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"and","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"vel_ext = VelocityExtension(\n    a_hilb, U_reg, V_reg;\n    assem = SparseMatrixAssembler(Tm,Tv,U_reg,V_reg),\n    ls = PETScLinearSolver()\n  )","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"respectively. Here we specify that the SparseMatrixAssembler should be based on the SparseMatrixCSR datatype along with the globals PetscScalar and PetscInt. We then set the linear solver, adjoint solver, and linear solver for the velocity extension to be the PETScLinearSolver(). The PETScLinearSolver is a wrapper for the PETSc solver as specified by the solver options (see below).","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"Finally, we wrap the entire script in a function and call it inside a GridapPETSc.with block. This ensures that PETSc is safely initialised. This should take the form","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"using Gridap, GridapPETSc, SparseMatricesCSR, GridapTopOpt\n\nfunction main()\n  ...\nend\n\nsolver_options = \"-pc_type gamg -ksp_type cg -ksp_error_if_not_converged true\n  -ksp_converged_reason -ksp_rtol 1.0e-12\"\nGridapPETSc.with(args=split(solver_options)) do\n  main()\nend","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"We utilise a conjugate gradient method with geometric algebraic multigrid preconditioner using the solver_options string. This should match the PETSc database keys (see documentation).","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"<details><summary>Script 3: combining the above gives (click me!)</summary>","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"using Gridap, GridapPETSc, SparseMatricesCSR, GridapTopOpt\n\nfunction main()\n  # FE parameters\n  order = 1                                               # Finite element order\n  xmax=ymax=zmax=1.0                                      # Domain size\n  dom = (0,xmax,0,ymax,0,zmax)                            # Bounding domain\n  el_size = (100,100,100)                                 # Mesh partition size\n  prop_Γ_N = 0.2                                          # Γ_N size parameter\n  prop_Γ_D = 0.2                                          # Γ_D size parameter\n  f_Γ_N(x) = (x[1] ≈ xmax) &&                             # Γ_N indicator function\n    (ymax/2-ymax*prop_Γ_N/2 - eps() <= x[2] <= ymax/2+ymax*prop_Γ_N/2 + eps()) &&\n    (zmax/2-zmax*prop_Γ_N/2 - eps() <= x[3] <= zmax/2+zmax*prop_Γ_N/2 + eps())\n  f_Γ_D(x) = (x[1] ≈ 0.0) &&                              # Γ_D indicator function\n    (x[2] <= ymax*prop_Γ_D + eps() || x[2] >= ymax-ymax*prop_Γ_D - eps()) &&\n    (x[3] <= zmax*prop_Γ_D + eps() || x[3] >= zmax-zmax*prop_Γ_D - eps())\n  # FD parameters\n  γ = 0.1                                                 # HJ equation time step coefficient\n  γ_reinit = 0.5                                          # Reinit. equation time step coefficient\n  max_steps = floor(Int,minimum(el_size)/3)               # Max steps for advection\n  tol = 1/(2order^2)/minimum(el_size)           # Advection tolerance\n  # Problem parameters\n  κ = 1                                                   # Diffusivity\n  g = 1                                                   # Heat flow in\n  vf = 0.4                                                # Volume fraction constraint\n  lsf_func = initial_lsf(4,0.2)                           # Initial level set function\n  iter_mod = 10                                           # Output VTK files every 10th iteration\n  path = \"./results/tut1_3d_petsc/\"                       # Output path\n  mkpath(path)                                            # Create path\n  # Model\n  model = CartesianDiscreteModel(dom,el_size);\n  update_labels!(1,model,f_Γ_D,\"Gamma_D\")\n  update_labels!(2,model,f_Γ_N,\"Gamma_N\")\n  # Triangulation and measures\n  Ω = Triangulation(model)\n  Γ_N = BoundaryTriangulation(model,tags=\"Gamma_N\")\n  dΩ = Measure(Ω,2*order)\n  dΓ_N = Measure(Γ_N,2*order)\n  # Spaces\n  reffe = ReferenceFE(lagrangian,Float64,order)\n  V = TestFESpace(model,reffe;dirichlet_tags=[\"Gamma_D\"])\n  U = TrialFESpace(V,0.0)\n  V_φ = TestFESpace(model,reffe)\n  V_reg = TestFESpace(model,reffe;dirichlet_tags=[\"Gamma_N\"])\n  U_reg = TrialFESpace(V_reg,0)\n  # Level set and interpolator\n  φh = interpolate(lsf_func,V_φ)\n  interp = SmoothErsatzMaterialInterpolation(η = 2*maximum(get_el_Δ(model)))\n  I,H,DH,ρ = interp.I,interp.H,interp.DH,interp.ρ\n  # Weak formulation\n  a(u,v,φ,dΩ,dΓ_N) = ∫((I ∘ φ)*κ*∇(u)⋅∇(v))dΩ\n  l(v,φ,dΩ,dΓ_N) = ∫(g*v)dΓ_N\n  # State map\n  Tm = SparseMatrixCSR{0,PetscScalar,PetscInt}\n  Tv = Vector{PetscScalar}\n  state_map = AffineFEStateMap(\n    a,l,U,V,V_φ,U_reg,φh,dΩ,dΓ_N;\n    assem_U = SparseMatrixAssembler(Tm,Tv,U,V),\n    assem_adjoint = SparseMatrixAssembler(Tm,Tv,V,U),\n    assem_deriv = SparseMatrixAssembler(Tm,Tv,U_reg,U_reg),\n    ls = PETScLinearSolver(),adjoint_ls = PETScLinearSolver()\n  )\n  # Objective and constraints\n  J(u,φ,dΩ,dΓ_N) = ∫((I ∘ φ)*κ*∇(u)⋅∇(u))dΩ\n  dJ(q,u,φ,dΩ,dΓ_N) = ∫(κ*∇(u)⋅∇(u)*q*(DH ∘ φ)*(norm ∘ ∇(φ)))dΩ\n  vol_D = sum(∫(1)dΩ)\n  C(u,φ,dΩ,dΓ_N) = ∫(((ρ ∘ φ) - vf)/vol_D)dΩ\n  dC(q,u,φ,dΩ,dΓ_N) = ∫(-1/vol_D*q*(DH ∘ φ)*(norm ∘ ∇(φ)))dΩ\n  pcfs = PDEConstrainedFunctionals(J,[C],state_map,analytic_dJ=dJ,analytic_dC=[dC])\n  # Velocity extension\n  α = 4*maximum(get_el_Δ(model))\n  a_hilb(p,q) =∫(α^2*∇(p)⋅∇(q) + p*q)dΩ\n  vel_ext = VelocityExtension(\n    a_hilb, U_reg, V_reg;\n    assem = SparseMatrixAssembler(Tm,Tv,U_reg,V_reg),\n    ls = PETScLinearSolver()\n  )\n  # Finite difference scheme\n  scheme = FirstOrderStencil(length(el_size),Float64)\n  ls_evo = HamiltonJacobiEvolution(scheme,model,V_φ,tol,max_steps)\n  # Optimiser\n  optimiser = AugmentedLagrangian(pcfs,ls_evo,vel_ext,φh;γ,γ_reinit,verbose=true,constraint_names=[:Vol])\n  # Solve\n  for (it,uh,φh) in optimiser\n    data = [\"phi\"=>φh,\"H(phi)\"=>(H ∘ φh),\"|nabla(phi)|\"=>(norm ∘ ∇(φh)),\"uh\"=>uh]\n    iszero(it % iter_mod) && (writevtk(Ω,path*\"struc_$it\",cellfields=data);GC.gc())\n    write_history(path*\"/history.txt\",get_history(optimiser))\n  end\n  # Final structure\n  it = get_history(optimiser).niter; uh = get_state(pcfs)\n  writevtk(Ω,path*\"struc_$it\",cellfields=[\"phi\"=>φh,\n    \"H(phi)\"=>(H ∘ φh),\"|nabla(phi)|\"=>(norm ∘ ∇(φh)),\"uh\"=>uh])\nend\n\nsolver_options = \"-pc_type gamg -ksp_type cg -ksp_error_if_not_converged true\n  -ksp_converged_reason -ksp_rtol 1.0e-12\"\nGridapPETSc.with(args=split(solver_options)) do\n  main()\nend","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"</details>","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"We can run this script and visualise the initial and final structures using Paraview:","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"(Image: )\nFigure 5: Visualisation of initial structure (left) and final structure (right) for Script 3 using the isovolume with varphileq0.","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/#Serial-to-MPI","page":"Minimum thermal compliance","title":"Serial to MPI","text":"","category":"section"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"Script 3 contains no parallelism to enable further speedup or scalability. To enable MPI-based computing we rely on the tools implemented in PartitionedArrays and GridapDistributed. Further information regarding these packages and how they interface with GridapTopOpt can be found here. To add these packages we adjust the first line of our script:","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"using Gridap, GridapPETSc, GridapDistributed, PartitionedArrays, SparseMatricesCSR, GridapTopOpt","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"Before we change any parts of the function main, we adjust the end of the script to safely launch MPI inside a Julia do block. We replace lines 95-99 in Script 3 with","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"with_mpi() do distribute\n  mesh_partition = (2,2,2)\n  solver_options = \"-pc_type gamg -ksp_type cg -ksp_error_if_not_converged true\n    -ksp_converged_reason -ksp_rtol 1.0e-12\"\n  GridapPETSc.with(args=split(solver_options)) do\n    main(mesh_partition,distribute)\n  end\nend","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"We use mesh_partition = (2,2,2) to set the number of partitions of the Cartesian mesh in each axial direction. For this example we end up with a total of 8 partitions. We then pass main two arguments: mesh_partition and distribute. We use these to to create MPI ranks at the start of main:","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"function main(mesh_partition,distribute)\n  ranks = distribute(LinearIndices((prod(mesh_partition),)))\n  ...","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"We then adjust lines 28-31 as follows:","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"  path = \"./results/tut1_3d_petsc_mpi/\"                   # Output path\n  i_am_main(ranks) && mkpath(path)                        # Create path\n  # Model\n  model = CartesianDiscreteModel(ranks,mesh_partition,dom,el_size);","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"The function i_am_main returns true only on the first processor. This function is useful for ensuring certain operations only happen once instead of several times across each executable. In addition, we now create a partitioned Cartesian model using CartesianDiscreteModel(ranks,mesh_partition,dom,el_size). Finally, we adjust line 82 to ensure that verbosity only happens on the first processors:","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"optimiser = AugmentedLagrangian(pcfs,ls_evo,vel_ext,φh;\n  γ,γ_reinit,verbose=i_am_main(ranks),constraint_names=[:Vol])","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"That's it! These are the only changes that are necessary to run your application using MPI.","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"<details><summary>Script 4: combining the above gives (click me!)</summary>","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"using Gridap, GridapPETSc, GridapDistributed, PartitionedArrays, SparseMatricesCSR, GridapTopOpt\n\nfunction main(mesh_partition,distribute)\n  ranks = distribute(LinearIndices((prod(mesh_partition),)))\n  # FE parameters\n  order = 1                                               # Finite element order\n  xmax=ymax=zmax=1.0                                      # Domain size\n  dom = (0,xmax,0,ymax,0,zmax)                            # Bounding domain\n  el_size = (100,100,100)                                 # Mesh partition size\n  prop_Γ_N = 0.2                                          # Γ_N size parameter\n  prop_Γ_D = 0.2                                          # Γ_D size parameter\n  f_Γ_N(x) = (x[1] ≈ xmax) &&                             # Γ_N indicator function\n    (ymax/2-ymax*prop_Γ_N/2 - eps() <= x[2] <= ymax/2+ymax*prop_Γ_N/2 + eps()) &&\n    (zmax/2-zmax*prop_Γ_N/2 - eps() <= x[3] <= zmax/2+zmax*prop_Γ_N/2 + eps())\n  f_Γ_D(x) = (x[1] ≈ 0.0) &&                              # Γ_D indicator function\n    (x[2] <= ymax*prop_Γ_D + eps() || x[2] >= ymax-ymax*prop_Γ_D - eps()) &&\n    (x[3] <= zmax*prop_Γ_D + eps() || x[3] >= zmax-zmax*prop_Γ_D - eps())\n  # FD parameters\n  γ = 0.1                                                 # HJ equation time step coefficient\n  γ_reinit = 0.5                                          # Reinit. equation time step coefficient\n  max_steps = floor(Int,minimum(el_size)/3)               # Max steps for advection\n  tol = 1/(2order^2)/minimum(el_size)           # Advection tolerance\n  # Problem parameters\n  κ = 1                                                   # Diffusivity\n  g = 1                                                   # Heat flow in\n  vf = 0.4                                                # Volume fraction constraint\n  lsf_func = initial_lsf(4,0.2)                           # Initial level set function\n  iter_mod = 10                                           # Output VTK files every 10th iteration\n  path = \"./results/tut1_3d_petsc_mpi/\"                   # Output path\n  i_am_main(ranks) && mkpath(path)                        # Create path\n  # Model\n  model = CartesianDiscreteModel(ranks,mesh_partition,dom,el_size);\n  update_labels!(1,model,f_Γ_D,\"Gamma_D\")\n  update_labels!(2,model,f_Γ_N,\"Gamma_N\")\n  # Triangulation and measures\n  Ω = Triangulation(model)\n  Γ_N = BoundaryTriangulation(model,tags=\"Gamma_N\")\n  dΩ = Measure(Ω,2*order)\n  dΓ_N = Measure(Γ_N,2*order)\n  # Spaces\n  reffe = ReferenceFE(lagrangian,Float64,order)\n  V = TestFESpace(model,reffe;dirichlet_tags=[\"Gamma_D\"])\n  U = TrialFESpace(V,0.0)\n  V_φ = TestFESpace(model,reffe)\n  V_reg = TestFESpace(model,reffe;dirichlet_tags=[\"Gamma_N\"])\n  U_reg = TrialFESpace(V_reg,0)\n  # Level set and interpolator\n  φh = interpolate(lsf_func,V_φ)\n  interp = SmoothErsatzMaterialInterpolation(η = 2*maximum(get_el_Δ(model)))\n  I,H,DH,ρ = interp.I,interp.H,interp.DH,interp.ρ\n  # Weak formulation\n  a(u,v,φ,dΩ,dΓ_N) = ∫((I ∘ φ)*κ*∇(u)⋅∇(v))dΩ\n  l(v,φ,dΩ,dΓ_N) = ∫(g*v)dΓ_N\n  # State map\n  Tm = SparseMatrixCSR{0,PetscScalar,PetscInt}\n  Tv = Vector{PetscScalar}\n  state_map = AffineFEStateMap(\n    a,l,U,V,V_φ,U_reg,φh,dΩ,dΓ_N;\n    assem_U = SparseMatrixAssembler(Tm,Tv,U,V),\n    assem_adjoint = SparseMatrixAssembler(Tm,Tv,V,U),\n    assem_deriv = SparseMatrixAssembler(Tm,Tv,U_reg,U_reg),\n    ls = PETScLinearSolver(),adjoint_ls = PETScLinearSolver()\n  )\n  # Objective and constraints\n  J(u,φ,dΩ,dΓ_N) = ∫((I ∘ φ)*κ*∇(u)⋅∇(u))dΩ\n  dJ(q,u,φ,dΩ,dΓ_N) = ∫(κ*∇(u)⋅∇(u)*q*(DH ∘ φ)*(norm ∘ ∇(φ)))dΩ\n  vol_D = sum(∫(1)dΩ)\n  C(u,φ,dΩ,dΓ_N) = ∫(((ρ ∘ φ) - vf)/vol_D)dΩ\n  dC(q,u,φ,dΩ,dΓ_N) = ∫(-1/vol_D*q*(DH ∘ φ)*(norm ∘ ∇(φ)))dΩ\n  pcfs = PDEConstrainedFunctionals(J,[C],state_map,analytic_dJ=dJ,analytic_dC=[dC])\n  # Velocity extension\n  α = 4*maximum(get_el_Δ(model))\n  a_hilb(p,q) =∫(α^2*∇(p)⋅∇(q) + p*q)dΩ\n  vel_ext = VelocityExtension(\n    a_hilb, U_reg, V_reg;\n    assem = SparseMatrixAssembler(Tm,Tv,U_reg,V_reg),\n    ls = PETScLinearSolver()\n  )\n  # Finite difference scheme\n  scheme = FirstOrderStencil(length(el_size),Float64)\n  ls_evo = HamiltonJacobiEvolution(scheme,model,V_φ,tol,max_steps)\n  # Optimiser\n  optimiser = AugmentedLagrangian(pcfs,ls_evo,vel_ext,φh;\n    γ,γ_reinit,verbose=i_am_main(ranks),constraint_names=[:Vol])\n  # Solve\n  for (it,uh,φh) in optimiser\n    data = [\"phi\"=>φh,\"H(phi)\"=>(H ∘ φh),\"|nabla(phi)|\"=>(norm ∘ ∇(φh)),\"uh\"=>uh]\n    iszero(it % iter_mod) && (writevtk(Ω,path*\"struc_$it\",cellfields=data);GC.gc())\n    write_history(path*\"/history.txt\",get_history(optimiser))\n  end\n  # Final structure\n  it = get_history(optimiser).niter; uh = get_state(pcfs)\n  writevtk(Ω,path*\"struc_$it\",cellfields=[\"phi\"=>φh,\n    \"H(phi)\"=>(H ∘ φh),\"|nabla(phi)|\"=>(norm ∘ ∇(φh)),\"uh\"=>uh])\nend\n\nwith_mpi() do distribute\n  mesh_partition = (2,2,2)\n  solver_options = \"-pc_type gamg -ksp_type cg -ksp_error_if_not_converged true\n    -ksp_converged_reason -ksp_rtol 1.0e-12\"\n  GridapPETSc.with(args=split(solver_options)) do\n    main(mesh_partition,distribute)\n  end\nend","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"</details>","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"We can then run this script by calling mpiexecjl using bash:","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"mpiexecjl -n 8 julia tut1_3d_petsc_mpi.jl","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"This gives the same final result as the previous script.","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/#Nonlinear-thermal-conductivity","page":"Minimum thermal compliance","title":"Nonlinear thermal conductivity","text":"","category":"section"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"Our final extension considers two-dimensional nonlinear thermal conductivity problem:","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"beginaligned\n-nabla(kappa(u)nabla u) = 0textin Omega\nkappa(u)nabla ucdotboldsymboln = gtexton Gamma_N\nkappa(u)nabla ucdotboldsymboln = 0texton partialOmegasetminusGamma_N\nu = 0texton Gamma_D\nendaligned","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"where kappa(u)=kappa_0expxi u. The weak formulation for this problem with relaxation over the computational domain is: Find uin H^1_Gamma_D(D) such that R(uvvarphi)=0 for all vin H^1_Gamma_D(D) where","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"R(uvvarphi) = int_DI(varphi)kappa(u)boldsymbolnablaucdotboldsymbolnablavmathrmdboldsymbolx - int_Gamma_Ngvmathrmdboldsymbolx","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"As we're considering a 2D problem, we consider modifications of Script 1 as follows. First, we introduce a nonlinear diffusivity by replacing line 20 with","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"κ(u) = exp(-u)                                          # Diffusivity","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"We then replace the a and l on line 48 and 49 by the residual R given by","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"R(u,v,φ,dΩ,dΓ_N) = ∫((I ∘ φ)*(κ ∘ u)*∇(u)⋅∇(v))dΩ - ∫(g*v)dΓ_N","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"In addition we replace the AffineFEStateMap on line 50 with a NonlinearFEStateMap. This enables automatic differentiation when the forward problem is nonlinear.","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"state_map = NonlinearFEStateMap(R,U,V,V_φ,U_reg,φh,dΩ,dΓ_N)","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"This by default implements a standard NewtonSolver from GridapSolvers while utilising an LU solver for intermediate linear solves involving the Jacobian. As with other FEStateMap types, this constructor can optionally take assemblers and different solvers (e.g., PETSc solvers).","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"Next, we replace the objective functional on line 52 with","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"J(u,φ,dΩ,dΓ_N) = ∫((I ∘ φ)*(κ ∘ u)*∇(u)⋅∇(u))dΩ","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"For this problem we utilise automatic differentiation as the analytic calculation of the sensitivity is somewhat involved. We therefore remove line 53 and replace line 57 with","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"pcfs = PDEConstrainedFunctionals(J,[C],state_map,analytic_dC=[dC])","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"Notice that the argument analytic_dJ=... has been removed, this enables the AD capability. We now have everything we need to run a nonlinear problem.","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"<details><summary>Script 5: combining the above gives (click me!)</summary>","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"using Gridap, GridapTopOpt\n\n# FE parameters\norder = 1                                               # Finite element order\nxmax = ymax = 1.0                                       # Domain size\ndom = (0,xmax,0,ymax)                                   # Bounding domain\nel_size = (200,200)                                     # Mesh partition size\nprop_Γ_N = 0.2                                          # Γ_N size parameter\nprop_Γ_D = 0.2                                          # Γ_D size parameter\nf_Γ_N(x) = (x[1] ≈ xmax &&                              # Γ_N indicator function\n  ymax/2-ymax*prop_Γ_N/2 - eps() <= x[2] <= ymax/2+ymax*prop_Γ_N/2 + eps())\nf_Γ_D(x) = (x[1] ≈ 0.0 &&                               # Γ_D indicator function\n  (x[2] <= ymax*prop_Γ_D + eps() || x[2] >= ymax-ymax*prop_Γ_D - eps()))\n# FD parameters\nγ = 0.1                                                 # HJ equation time step coefficient\nγ_reinit = 0.5                                          # Reinit. equation time step coefficient\nmax_steps = floor(Int,minimum(el_size)/10)              # Max steps for advection\ntol = 1/(5order^2)/minimum(el_size)          # Advection tolerance\n# Problem parameters\nκ(u) = exp(-u)                                          # Diffusivity\ng = 1                                                   # Heat flow in\nvf = 0.4                                                # Volume fraction constraint\nlsf_func = initial_lsf(4,0.2)                           # Initial level set function\niter_mod = 10                                           # Output VTK files every 10th iteration\npath = \"./results/tut1_nonlinear/\"                      # Output path\nmkpath(path)                                            # Create path\n# Model\nmodel = CartesianDiscreteModel(dom,el_size);\nupdate_labels!(1,model,f_Γ_D,\"Gamma_D\")\nupdate_labels!(2,model,f_Γ_N,\"Gamma_N\")\n# Triangulation and measures\nΩ = Triangulation(model)\nΓ_N = BoundaryTriangulation(model,tags=\"Gamma_N\")\ndΩ = Measure(Ω,2*order)\ndΓ_N = Measure(Γ_N,2*order)\n# Spaces\nreffe = ReferenceFE(lagrangian,Float64,order)\nV = TestFESpace(model,reffe;dirichlet_tags=[\"Gamma_D\"])\nU = TrialFESpace(V,0.0)\nV_φ = TestFESpace(model,reffe)\nV_reg = TestFESpace(model,reffe;dirichlet_tags=[\"Gamma_N\"])\nU_reg = TrialFESpace(V_reg,0)\n# Level set and interpolator\nφh = interpolate(lsf_func,V_φ)\ninterp = SmoothErsatzMaterialInterpolation(η = 2*maximum(get_el_Δ(model)))\nI,H,DH,ρ = interp.I,interp.H,interp.DH,interp.ρ\n# Weak formulation\nR(u,v,φ,dΩ,dΓ_N) = ∫((I ∘ φ)*(κ ∘ u)*∇(u)⋅∇(v))dΩ - ∫(g*v)dΓ_N\nstate_map = NonlinearFEStateMap(R,U,V,V_φ,U_reg,φh,dΩ,dΓ_N)\n# Objective and constraints\nJ(u,φ,dΩ,dΓ_N) = ∫((I ∘ φ)*(κ ∘ u)*∇(u)⋅∇(u))dΩ\nvol_D = sum(∫(1)dΩ)\nC(u,φ,dΩ,dΓ_N) = ∫(((ρ ∘ φ) - vf)/vol_D)dΩ\ndC(q,u,φ,dΩ,dΓ_N) = ∫(-1/vol_D*q*(DH ∘ φ)*(norm ∘ ∇(φ)))dΩ\npcfs = PDEConstrainedFunctionals(J,[C],state_map,analytic_dC=[dC])\n# Velocity extension\nα = 4*maximum(get_el_Δ(model))\na_hilb(p,q) =∫(α^2*∇(p)⋅∇(q) + p*q)dΩ\nvel_ext = VelocityExtension(a_hilb,U_reg,V_reg)\n# Finite difference scheme\nscheme = FirstOrderStencil(length(el_size),Float64)\nls_evo = HamiltonJacobiEvolution(scheme,model,V_φ,tol,max_steps)\n# Optimiser\noptimiser = AugmentedLagrangian(pcfs,ls_evo,vel_ext,φh;γ,γ_reinit,verbose=true,constraint_names=[:Vol])\n# Solve\nfor (it,uh,φh) in optimiser\n  data = [\"phi\"=>φh,\"H(phi)\"=>(H ∘ φh),\"|nabla(phi)|\"=>(norm ∘ ∇(φh)),\"uh\"=>uh]\n  iszero(it % iter_mod) && (writevtk(Ω,path*\"struc_$it\",cellfields=data);GC.gc())\n  write_history(path*\"/history.txt\",get_history(optimiser))\nend\n# Final structure\nit = get_history(optimiser).niter; uh = get_state(pcfs)\nwritevtk(Ω,path*\"struc_$it\",cellfields=[\"phi\"=>φh,\n  \"H(phi)\"=>(H ∘ φh),\"|nabla(phi)|\"=>(norm ∘ ∇(φh)),\"uh\"=>uh])","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"</details>","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"Running this problem until convergence gives a final result of","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"Iteration:  95 | L=1.6554e-01, J=1.6570e-01, Vol=-2.8836e-04, γ=7.5000e-02","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"with the optimised domain Omega given by","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"(Image: )\nFigure 6: Visualisation of Omega using the isovolume with varphileq0.","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"A 3D example of a nonlinear thermal conductivity problem can be found under scripts/MPI/3d_nonlinear_thermal_compliance_ALM.jl.","category":"page"},{"location":"deprecated/tutorials/minimum_thermal_compliance/#References","page":"Minimum thermal compliance","title":"References","text":"","category":"section"},{"location":"deprecated/tutorials/minimum_thermal_compliance/","page":"Minimum thermal compliance","title":"Minimum thermal compliance","text":"Z. Guo, X. Cheng, and Z. Xia. Least dissipation principle of heat transport potential capacity and its application in heat conduction  optimization. Chinese Science Bulletin, 48(4):406–410, Feb 2003. ISSN 1861-9541. doi: 10.1007/BF03183239.\nC. Zhuang, Z. Xiong, and H. Ding. A level set method for topology optimization of heat conduction problem under multiple load cases. Computer Methods in Applied Mechanics and Engineering, 196(4–6):1074–1084, Jan 2007. ISSN 00457825. doi: 10.1016/j.cma.2006.08.005.\nAllaire G, Jouve F, Toader AM (2004) Structural optimization using sensitivity analysis and a level-set method. Journal of Computational Physics 194(1):363–393. doi: 10.1016/j.jcp.2003.09.032\nAllaire G, Dapogny C, Jouve F (2021) Shape and topology optimization, vol 22, Elsevier, p 1–132. doi: 10.1016/bs.hna.2020.10.004\nOsher S, Fedkiw R (2006) Level Set Methods and Dynamic Implicit Surfaces, 1st edn. Applied Mathematical Sciences, Springer Science & Business Media. doi: 10.1007/b98879\nNocedal J, Wright SJ (2006) Numerical optimization, 2nd edn. Springer series in operations research, Springer, New York. doi: 10.1007/978-0-387-40065-5","category":"page"},{"location":"reference/velext/#Velocity-extension","page":"Velocity extension","title":"Velocity extension","text":"","category":"section"},{"location":"reference/velext/","page":"Velocity extension","title":"Velocity extension","text":"Modules = [GridapTopOpt]\nPages = [\"VelocityExtension.jl\"]","category":"page"},{"location":"reference/velext/#GridapTopOpt.VelocityExtension","page":"Velocity extension","title":"GridapTopOpt.VelocityExtension","text":"struct VelocityExtension{A,B}\n\nWrapper to hold a stiffness matrix and a cache for the Hilbertian extension-regularisation. See Allaire et al. 2022 (link).\n\nThe Hilbertian extension-regularisation method involves solving an  identification problem over a Hilbert space H on D with  inner product langlecdotcdotrangle_H:  Find g_Omegain H such that langle g_Omegawrangle_H =-J^prime(Omega)(wboldsymboln) forall win H\n\nThis provides two benefits: \n\nIt naturally extends the shape sensitivity from partialOmega  onto the bounding domain D; and\nensures a descent direction for J(Omega) with additional regularity  (i.e., H as opposed to L^2(partialOmega))\n\nProperties\n\nK::A: The discretised inner product over H.\ncache::B: Cached objects used for project!\n\n\n\n\n\n","category":"type"},{"location":"reference/velext/#GridapTopOpt.VelocityExtension-Tuple{Function, Gridap.FESpaces.FESpace, Gridap.FESpaces.FESpace}","page":"Velocity extension","title":"GridapTopOpt.VelocityExtension","text":"VelocityExtension(biform,U_reg,V_reg;assem,ls)\n\nCreate an instance of VelocityExtension given a bilinear form biform, trial space U_reg, and test space V_reg.\n\nOptional\n\nassem: A matrix assembler\nls::LinearSolver: A linear solver\n\n\n\n\n\n","category":"method"},{"location":"reference/velext/#GridapTopOpt.project!-Tuple{VelocityExtension, AbstractVector}","page":"Velocity extension","title":"GridapTopOpt.project!","text":"project!(vel_ext::VelocityExtension,dF::AbstractVector) -> dF\n\nProject shape derivative dF onto a function space described by the vel_ext.\n\n\n\n\n\n","category":"method"},{"location":"deprecated/usage/petsc/#PETSc","page":"PETSc","title":"PETSc","text":"","category":"section"},{"location":"getting-started/#Getting-started","page":"Getting Started","title":"Getting started","text":"","category":"section"},{"location":"getting-started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"GridapTopOpt.jl and additional dependencies can be installed in an existing Julia environment using the package manager. This can be accessed in the Julia REPL (read-eval–print loop) by pressing ]. We then add the required packages via:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"pkg> add GridapTopOpt, Gridap, GridapDistributed, GridapPETSc, GridapSolvers, PartitionedArrays, SparseMatricesCSR","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Once installed, serial driver scripts can be run immediately, whereas parallel problems also require an MPI installation.","category":"page"},{"location":"getting-started/#MPI","page":"Getting Started","title":"MPI","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"For basic users, MPI.jl provides such an implementation and a Julia wrapper for mpiexec - the MPI executor. This is installed via:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"pkg> add MPI\njulia> using MPI\njulia> MPI.install_mpiexecjl()","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Once the mpiexecjl wrapper has been added to the system PATH, MPI scripts can be executed in a terminal via","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"mpiexecjl -n P julia  main.jl","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"where main is a driver script, P denotes the number of processors.","category":"page"},{"location":"getting-started/#PETSc","page":"Getting Started","title":"PETSc","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"In GridapTopOpt.jl we rely on the GridapPETSc.jl satellite package to interface with the linear and nonlinear solvers provided by the PETSc (Portable, Extensible Toolkit for Scientific Computation) library. For basic users these solvers are provided by GridapPETSc.jl with no additional work.","category":"page"},{"location":"getting-started/#Advanced-installation","page":"Getting Started","title":"Advanced installation","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"For more advanced installations, such as use of a custom MPI/PETSc installation on a HPC cluster, we refer the reader to the discussion for GridapPETSc.jl and the configuration page for MPI.jl.","category":"page"},{"location":"getting-started/#Usage-and-tutorials","page":"Getting Started","title":"Usage and tutorials","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"In order to get familiar with the library we recommend following the numerical examples described in:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Zachary J. Wegert, Jordi Manyer, Connor Mallon, Santiago Badia, and Vivien J. Challis (2024). \"GridapTopOpt.jl: A scalable computational toolbox for level set-based topology optimisation\". In preparation.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"In addition, there are several driver scripts available in /scripts/..","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"More general tutorials for familiarising ones self with Gridap are available via the Gridap Tutorials.","category":"page"},{"location":"getting-started/#Known-issues","page":"Getting Started","title":"Known issues","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"PETSc's GAMG preconditioner breaks for split Dirichlet DoFs (e.g., x constrained while y free for a single node). There is no simple fix for this. We recommend instead using MUMPS or another preconditioner for this case.\nCurrently, our implementation of automatic differentiation does not support multiplication and division of optimisation functionals. We plan to add this in a future release of GridapTopOpt.jl – Issue #38.\nAnalytic gradient breaks in parallel for integrals of certain measures – Issue #46","category":"page"},{"location":"reference/io/#IO","page":"IO","title":"IO","text":"","category":"section"},{"location":"reference/io/","page":"IO","title":"IO","text":"In GridapTopOpt, the usual IO from Gridap is available. In addition, we also implement the below IO for convenience.","category":"page"},{"location":"reference/io/#Optimiser-history","page":"IO","title":"Optimiser history","text":"","category":"section"},{"location":"reference/io/","page":"IO","title":"IO","text":"GridapTopOpt.write_history","category":"page"},{"location":"reference/io/#GridapTopOpt.write_history","page":"IO","title":"GridapTopOpt.write_history","text":"write_history(path::String,h::OptimiserHistory;ranks=nothing)\n\nWrite the contents of an OptimiserHistory object to a path. Provide MPI ranks when running in parallel.\n\n\n\n\n\n","category":"function"},{"location":"reference/io/#Object-IO-in-serial","page":"IO","title":"Object IO in serial","text":"","category":"section"},{"location":"reference/io/","page":"IO","title":"IO","text":"GridapTopOpt.save\nGridapTopOpt.load\nGridapTopOpt.load!","category":"page"},{"location":"reference/io/#GridapTopOpt.save","page":"IO","title":"GridapTopOpt.save","text":"save(filename::AbstractString, x)\n\nSave an object x to filename as a JLD2 file.\n\nNote: To save in MPI mode, use psave.\n\n\n\n\n\n","category":"function"},{"location":"reference/io/#GridapTopOpt.load","page":"IO","title":"GridapTopOpt.load","text":"load(filename::AbstractString)\n\nLoad an object stored in a JLD2 file at filename.\n\nNote: To load in MPI mode, use pload.\n\n\n\n\n\n","category":"function"},{"location":"reference/io/#GridapTopOpt.load!","page":"IO","title":"GridapTopOpt.load!","text":"load!(filename::AbstractString, x)\n\nLoad an object stored in a JLD2 file at filename and copy its contents to x.\n\nNote: To load! in MPI mode, use pload!.\n\n\n\n\n\n","category":"function"},{"location":"reference/io/#Object-IO-in-parallel","page":"IO","title":"Object IO in parallel","text":"","category":"section"},{"location":"reference/io/","page":"IO","title":"IO","text":"GridapTopOpt.psave\nGridapTopOpt.pload\nGridapTopOpt.pload!","category":"page"},{"location":"reference/io/#GridapTopOpt.psave","page":"IO","title":"GridapTopOpt.psave","text":"psave(filename::AbstractString, x)\n\nSave a partitioned object x to a directory dir as a set of JLD2 files corresponding to each part.\n\n\n\n\n\n","category":"function"},{"location":"reference/io/#GridapTopOpt.pload","page":"IO","title":"GridapTopOpt.pload","text":"pload(dir::AbstractString, ranks::AbstractArray{<:Integer})\n\nLoad a partitioned object stored in a set of JLD2 files in directory dir indexed by MPI ranks ranks.\n\n\n\n\n\n","category":"function"},{"location":"reference/io/#GridapTopOpt.pload!","page":"IO","title":"GridapTopOpt.pload!","text":"pload!(dir::AbstractString, x)\n\nLoad a partitioned object stored in a set of JLD2 files in directory dir and copy contents to the equivilent object x.\n\n\n\n\n\n","category":"function"},{"location":"deprecated/tutorials/inverse_homogenisation/#Inverse-homogenisation","page":"Inverse homogenisation","title":"Inverse homogenisation","text":"","category":"section"},{"location":"deprecated/dev/shape_der/#Shape-derivative-versus-Gâteaux-derivative-in-\\varphi","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"","category":"section"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"The shape derivative of J^prime(Omega) can be defined as the Fréchet derivative under a mapping tildeOmega = (boldsymbolI+boldsymboltheta)(Omega) at boldsymbol0 with","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"J(tildeOmega)=J(Omega)+J^prime(Omega)(boldsymboltheta)+o(lVertboldsymbolthetarVert)","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"Consider some illustrative examples. First suppose that J_1(Omega)=int_Omega f(boldsymbolx)mathrmdboldsymbolx, then","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"J_1(tildeOmega)=int_tildeOmegaf(tildeboldsymbolx)mathrmdboldsymbolx=int_Omegaf(boldsymbolx+boldsymboltheta)leftlvertfracpartialboldsymboltildexpartialboldsymbolxrightrvertmathrmdboldsymbolx==J(Omega)+int_partialOmegaf(boldsymbolx)boldsymbolthetacdotboldsymbolnmathrmds+","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"So, for this simple case J_1^prime(Omega)(boldsymboltheta)=int_partialOmegaf(boldsymbolx)boldsymbolthetacdotboldsymbolnmathrmds(star) For a surface integral J_2(Omega)=int_partialOmega f(boldsymbolx)mathrmds, one finds in a similar way J_2^prime(Omega)(boldsymboltheta)=int_partialOmega(fnablacdotboldsymboln+nabla fcdotboldsymboln)boldsymbolthetacdotboldsymbolnmathrmds","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"Suppose that we attribute a signed distance function varphiDrightarrowmathbbR to our domain Omegasubset D with barOmega=lbrace boldsymbolxvarphi(boldsymbolx)leq0rbrace and Omega^complement=lbrace boldsymbolxvarphi(boldsymbolx)0rbrace. We can then define a smooth characteristic function chi_epsilonmathbbRrightarrowepsilon1 as chi_epsilon(varphi)=(1-H(varphi))+epsilon H(varphi) where H is a smoothed Heaviside function with smoothing radius eta, and epsilonll1 allows for an ersatz material approximation. Of course, epsilon can be taken as zero depending on the considered integral and/or computational regime. We can now rewrite J_1 over the computational domain D as J_1Omega(varphi)=int_D chi_epsilon(varphi)f(boldsymbolx)mathrmdboldsymbolx. Considering the directional derivative of J_1Omega under a variation tildevarphi=varphi+sv gives","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"J_1Omega^prime(varphi)(v)=fracmathrmdmathrmds J_1Omega(varphi+sv)rvert_s=0=int_D vchi_epsilon^prime(varphi)f(boldsymbolx)mathrmdboldsymbolx","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"or","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"J_1Omega^prime(varphi)(v)=int_D (epsilon-1)vH^prime(varphi)f(boldsymbolx)mathrmdboldsymbolx","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"The final result of course does not yet match (star). Over a fixed computational domain we may relax integrals to be over all of D via mathrmds = H(varphi)lvertnablavarphirvertmathrmdboldsymbolx. In addition suppose we take boldsymboltheta=-vboldsymboln. Then (star) can be rewritten as","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"J_1^prime(Omega)(-vboldsymboln)=-int_Dvf(boldsymbolx)H(varphi)lvertnablavarphirvertmathrmds","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"As varphi is a signed distance function we have lvertnablavarphirvert=1 for DsetminusSigma where Sigma is the skeleton of Omega and Omega^complement. Furthermore, H(varphi) provides support only within a band of partialOmega.","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"tip: Result I\nTherefore, we have that almost everywherehuge J_1^prime(Omega)(-vboldsymboln) - J_1Omega^prime(varphi)(v)huge=O(epsilon)with equaility as epsilonrightarrow0.","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"This is not the case when we consider applying the same process to a surface integral such as J_2(Omega). In this case, we can never recover nabla f under a variation of varphi. For argument sake we can take J_2Omega(varphi)=int_D f(boldsymbolx)H(varphi)lvertnablavarphirvertmathrmdboldsymbolx. Then a variation in varphi gives","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"J_2Omega^prime(varphi)(v)=int_D f(boldsymbolx)left(H^primeprime(varphi)lvertnablavarphirvert v + H^prime(varphi)fracnabla vcdotnabla varphilvertnablavarphirvertright)mathrmdboldsymbolx","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"On the other hand, relaxing the shape derivative of J_2 in the same way as above gives","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"J_2^prime(Omega)(-vboldsymboln)=int_D-left(fnablacdotfracnablavarphilvertnablavarphirvert+nabla fcdotfracnablavarphilvertnablavarphirvertright)vH(varphi)lvertnablavarphirvertmathrmdboldsymbolx","category":"page"},{"location":"deprecated/dev/shape_der/#Adding-PDE-constraints","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Adding PDE constraints","text":"","category":"section"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"Consider Omegasubset D with J(Omega)=int_Omega j(boldsymbolu)mathrmdboldsymbolx+int_Gamma_N l_1(boldsymbolu)mathrmds+int_Gamma_R l_2(boldsymbolu)mathrmds where boldsymbolu satisfies","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"beginaligned\n-mathrmdiv(boldsymbolCvarepsilon(boldsymbolu)) = boldsymbolftext on Omega \nboldsymbolu = boldsymbol0text on Gamma_D\nboldsymbolCvarepsilon(boldsymbolu)boldsymboln = boldsymbol0text on Gamma_0\nboldsymbolCvarepsilon(boldsymbolu)boldsymboln = boldsymbolgtext on Gamma_N\nboldsymbolCvarepsilon(boldsymbolu)boldsymboln = -boldsymbolw(boldsymbolu)text on Gamma_R\nendaligned","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"In the above boldsymbolvarepsilon is the strain tensor, boldsymbolC is the stiffness tensor, Gamma_0 = partialOmegasetminus(Gamma_DcupGamma_NcupGamma_R), and Gamma_D, Gamma_N, Gamma_R are required to be fixed.","category":"page"},{"location":"deprecated/dev/shape_der/#Shape-derivative","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative","text":"","category":"section"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"Let us first consider the shape derivative of J. Disregarding embedding inside the computational domain D, the above strong form can be written in weak form as:","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"quad Find boldsymboluin H^1_Gamma_D(Omega)^d such that","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"int_Omega boldsymbolCvarepsilon(boldsymbolu)boldsymbolvarepsilon(boldsymbolv)mathrmdboldsymbolx+int_Gamma_Rboldsymbolw(boldsymbolu)cdotboldsymbolvmathrmds=int_Omega boldsymbolfcdotboldsymbolvmathrmdboldsymbolx+int_Gamma_Nboldsymbolgcdotboldsymbolvmathrmdsforall boldsymbolvin H^1_Gamma_D(Omega)^d","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"Following Céa's formal adjoint method we introduce the following Lagrangian","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"beginaligned\nmathcalL(Omegaboldsymbolvboldsymbolq)=int_Omega j(boldsymbolv)mathrmdboldsymbolx+int_Gamma_N l_1(boldsymbolv)mathrmds+int_Gamma_R l_2(boldsymbolv)mathrmds+int_Omega boldsymbolCvarepsilon(boldsymbolv)boldsymbolvarepsilon(boldsymbolq)mathrmdboldsymbolx\n+int_Gamma_Rboldsymbolw(boldsymbolv)cdotboldsymbolqmathrmds-int_Omega boldsymbolfcdotboldsymbolqmathrmdboldsymbolx-int_Gamma_Nboldsymbolgcdotboldsymbolqmathrmds\n-int_Gamma_DboldsymbolqcdotboldsymbolCvarepsilon(boldsymbolv)boldsymboln+boldsymbolvcdotboldsymbolCvarepsilon(boldsymbolq)boldsymbolnmathrmds\nendaligned","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"where boldsymbolvboldsymbolqin H^1(mathbbR^d)^d. Requiring stationarity of the Lagrangian and taking a partial derivative of mathcalL with respect to boldsymbolq in the direction boldsymbolphiin H^1(mathbbR^d)^d gives","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"beginaligned\n0=fracpartialmathcalLpartialboldsymbolq(boldsymbolphi)=int_Omega boldsymbolCvarepsilon(boldsymbolv)boldsymbolvarepsilon(boldsymbolphi)mathrmdboldsymbolx+int_Gamma_Rboldsymbolw(boldsymbolv)cdotboldsymbolphimathrmds-int_Omega boldsymbolfcdotboldsymbolphimathrmdboldsymbolx-int_Gamma_Nboldsymbolgcdotboldsymbolphimathrmds\nquad-int_Gamma_DboldsymbolphicdotboldsymbolCvarepsilon(boldsymbolv)boldsymboln+boldsymbolvcdotboldsymbolCvarepsilon(boldsymbolphi)boldsymbolnmathrmds\n=int_Omegaboldsymbolphicdot(-mathrmdiv(boldsymbolCvarepsilon(boldsymbolu))-boldsymbolf)mathrmdboldsymbolx+int_Gamma_Rboldsymbolphicdot(boldsymbolCvarepsilon(boldsymbolv)boldsymboln+boldsymbolw(boldsymbolv))mathrmds\nquad+int_Gamma_Nboldsymbolphicdot(boldsymbolCvarepsilon(boldsymbolv)boldsymboln-boldsymbolg)mathrmds-int_Gamma_DboldsymbolvcdotboldsymbolCvarepsilon(boldsymbolphi)boldsymbolnmathrmds+int_Gamma_0boldsymbolphicdotboldsymbolCvarepsilon(boldsymbolv)boldsymbolnmathrmds\nendaligned","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"after applying integration by parts. Under a suitable variations of boldsymbolphi, the state equation and boundary conditions are generated as required. In other words, boldsymbolv is given by the solution boldsymbolu to the equations of state. We can derive the adjoint equation by again requiring stationarity of the Lagrangian and taking a partial derivative of mathcalL with respect to boldsymbolv in the direction boldsymbolphiin H^1(mathbbR^d)^d. This gives","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"beginaligned\n0=fracpartialmathcalLpartialboldsymbolv(boldsymbolphi)=int_Omega boldsymbolphicdot j^prime(boldsymbolv)mathrmdboldsymbolx+int_Gamma_N boldsymbolphicdot l_1^prime(boldsymbolv)mathrmds+int_Gamma_R boldsymbolphicdot l_2^prime(boldsymbolv)mathrmds+int_Omega boldsymbolCvarepsilon(boldsymbolphi)boldsymbolvarepsilon(boldsymbolq)mathrmdboldsymbolx\nquad+int_Gamma_Rboldsymbolphicdot w^prime(boldsymbolv)cdotboldsymbolqmathrmds-int_Gamma_DboldsymbolqcdotboldsymbolCvarepsilon(boldsymbolphi)boldsymboln+boldsymbolphicdotboldsymbolCvarepsilon(boldsymbolq)boldsymbolnmathrmds\n=int_Omega boldsymbolphicdot(-mathrmdiv(boldsymbolCvarepsilon(boldsymbolq))-j^prime(boldsymbolv))mathrmdboldsymbolx+int_Gamma_N boldsymbolphicdot (boldsymbolCvarepsilon(boldsymbolq)boldsymboln+l_1^prime(boldsymbolv))mathrmds\nquad+int_Gamma_R boldsymbolphicdot (boldsymbolCvarepsilon(boldsymbolq)boldsymboln+w^prime(boldsymbolv)cdotboldsymbolq+l_2^prime(boldsymbolv))mathrmds-int_Gamma_DboldsymbolqcdotboldsymbolCvarepsilon(boldsymbolphi)boldsymbolnmathrmds\nquad+int_Gamma_0boldsymbolphicdotboldsymbolCvarepsilon(boldsymbolq)boldsymbolnmathrmds\nendaligned","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"where integration by parts has been applied. The adjoint equations are then generated under suitable variations of boldsymbolphi, while the previous result boldsymbolv=boldsymbolu implies that we can identify a unique boldsymbolq=boldsymbollambda that satisfies stationaity. In particular,","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"beginaligned\n-mathrmdiv(boldsymbolCvarepsilon(boldsymbollambda)) = j^prime(boldsymbolu)text on Omega \nboldsymbollambda = boldsymbol0text on Gamma_D\nboldsymbolCvarepsilon(boldsymbollambda)boldsymboln = boldsymbol0 text on Gamma_0\nboldsymbolCvarepsilon(boldsymbollambda)boldsymboln = -l_1^prime(boldsymbolu)text on Gamma_N\nboldsymbolCvarepsilon(boldsymbollambda)boldsymboln = -w^prime(boldsymbolu)cdotboldsymbollambda-l_2^prime(boldsymbolu) text on Gamma_R\nendaligned","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"The shape derivative of J(Omega)=mathcalL(Omegaboldsymboluboldsymbollambda) then follows by application of the chainrule along with the shape derivative results for J_1 and J_2 above:","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"beginaligned\nJ^prime(Omega)(boldsymboltheta)=fracpartialmathcalLpartialOmega(Omegaboldsymboluboldsymbollambda)(boldsymboltheta)+cancelfracpartialmathcalLpartialboldsymbolv(Omegaboldsymboluboldsymbollambda)(boldsymbolu^prime(boldsymboltheta))+cancelfracpartialmathcalLpartialboldsymbolq(Omegaboldsymboluboldsymbollambda)(boldsymbollambda^prime(boldsymboltheta))\n=int_Gamma_0 (boldsymbolCvarepsilon(boldsymbolu)boldsymbolvarepsilon(boldsymbollambda)+j(boldsymbolu) -boldsymbolfcdotboldsymbollambda)boldsymbolthetacdotboldsymbolnmathrmds\nendaligned","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"As required. Note that in the above, we have used that boldsymbolthetacdotboldsymboln=0 on Gamma_N, Gamma_R, and Gamma_D.","category":"page"},{"location":"deprecated/dev/shape_der/#Gâteaux-derivative-in-\\varphi","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Gâteaux derivative in varphi","text":"","category":"section"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"Let us now return to derivatives of J with respect to varphi over the whole computational domain. As previously, suppose that we rewrite J as","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"hatmathcalJ(varphi)=int_D (1-H(varphi))j(boldsymbolu)mathrmdboldsymbolx+int_Gamma_N l_1(boldsymbolu)mathrmds+int_Gamma_R l_2(boldsymbolu)mathrmds","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"where boldsymbolu satisfies the state equations as previously with relaxation over the whole computational domain D as","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"beginaligned\n-mathrmdiv(chi_epsilon(varphi)boldsymbolCvarepsilon(boldsymbolu)) = (1-H(varphi))boldsymbolftext on D \nboldsymbolu = boldsymbol0text on Gamma_D\nchi_epsilon(varphi)boldsymbolCvarepsilon(boldsymbolu)boldsymboln = boldsymbol0text on Gamma_0\nchi_epsilon(varphi)boldsymbolCvarepsilon(boldsymbolu)boldsymboln = boldsymbolgtext on Gamma_N\nchi_epsilon(varphi)boldsymbolCvarepsilon(boldsymbolu)boldsymboln = -boldsymbolw(boldsymbolu)text on Gamma_R\nendaligned","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"and admits a weak form: Find boldsymboluin H^1_Gamma_D(Omega)^d such that","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"int_D chi_epsilon(varphi)boldsymbolCvarepsilon(boldsymbolu)boldsymbolvarepsilon(boldsymbolv)mathrmdboldsymbolx+int_Gamma_Rboldsymbolw(boldsymbolu)cdotboldsymbolvmathrmds=int_D(1-H(varphi))boldsymbolfcdotboldsymbolvmathrmdboldsymbolx+int_Gamma_Nboldsymbolgcdotboldsymbolvmathrmdsforall boldsymbolvin H^1_Gamma_D(Omega)^d","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"At this stage it is important to note that this is almost verbatim as the case without relaxation over D. Indeed, we may follow Céa's method as previously with only a minor adjustment to the Lagrangian that relaxes it over D:","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"beginaligned\nhatmathcalL(varphiboldsymbolvboldsymbolq)=int_D (1-H(varphi))j(boldsymbolv)mathrmdboldsymbolx+int_Gamma_N l_1(boldsymbolv)mathrmds+int_Gamma_R l_2(boldsymbolv)mathrmds+int_Dchi_epsilon(varphi)boldsymbolCvarepsilon(boldsymbolv)boldsymbolvarepsilon(boldsymbolq)mathrmdboldsymbolx\n+int_Gamma_Rboldsymbolw(boldsymbolv)cdotboldsymbolqmathrmds-int_D (1-H(varphi)) boldsymbolfcdotboldsymbolqmathrmdboldsymbolx-int_Gamma_Nboldsymbolgcdotboldsymbolqmathrmds\n-int_Gamma_Dboldsymbolqcdotchi_epsilon(varphi)boldsymbolCvarepsilon(boldsymbolv)boldsymboln+boldsymbolvcdotchi_epsilon(varphi)boldsymbolCvarepsilon(boldsymbolq)boldsymbolnmathrmds\nendaligned","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"As a result the partial derivatives of hatmathcalL in boldsymbolv and boldsymbolq are the same as previously up to relaxation over D, i.e.,","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"beginaligned\n0=fracpartialhatmathcalLpartialboldsymbolq(boldsymbolphi)=int_Dboldsymbolphicdot(-mathrmdiv(chi_epsilon(varphi)boldsymbolCvarepsilon(boldsymbolu))-(1-H(varphi))boldsymbolf)mathrmdboldsymbolx+int_Gamma_Rboldsymbolphicdot(chi_epsilon(varphi)boldsymbolCvarepsilon(boldsymbolv)boldsymboln+boldsymbolw(boldsymbolv))mathrmds\nquad+int_Gamma_Nboldsymbolphicdot(chi_epsilon(varphi)boldsymbolCvarepsilon(boldsymbolv)boldsymboln-boldsymbolg)mathrmds-int_Gamma_Dboldsymbolvcdotchi_epsilon(varphi)boldsymbolCvarepsilon(boldsymbolphi)boldsymbolnmathrmds+int_Gamma_0boldsymbolphicdotchi_epsilon(varphi)boldsymbolCvarepsilon(boldsymbolv)boldsymbolnmathrmds\nendaligned","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"and","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"beginaligned\n0=fracpartialhatmathcalLpartialboldsymbolv(boldsymbolphi)=int_D boldsymbolphicdot(-mathrmdiv(chi_epsilon(varphi)boldsymbolCvarepsilon(boldsymbolq))-(1-H(varphi))j^prime(boldsymbolv))mathrmdboldsymbolx+int_Gamma_N boldsymbolphicdot (chi_epsilon(varphi)boldsymbolCvarepsilon(boldsymbolq)boldsymboln+l_1^prime(boldsymbolv))mathrmds\nquad+int_Gamma_R boldsymbolphicdot (chi_epsilon(varphi)boldsymbolCvarepsilon(boldsymbolq)boldsymboln+w^prime(boldsymbolv)cdotboldsymbolq+l_2^prime(boldsymbolv))mathrmds-int_Gamma_Dboldsymbolqcdotchi_epsilon(varphi)boldsymbolCvarepsilon(boldsymbolphi)boldsymbolnmathrmds\nquad+int_Gamma_0boldsymbolphicdotchi_epsilon(varphi)boldsymbolCvarepsilon(boldsymbolq)boldsymbolnmathrmds\nendaligned","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"Therefore, we may identify boldsymbolv=boldsymbolu and boldsymbolq=boldsymbollambda where the latter satisfies the adjoint equation","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"beginaligned\n-mathrmdiv(chi_epsilon(varphi)boldsymbolCvarepsilon(boldsymbollambda)) = (1-H(varphi))j^prime(boldsymbolu)text on Omega \nboldsymbollambda = boldsymbol0text on Gamma_D\nchi_epsilon(varphi)boldsymbolCvarepsilon(boldsymbollambda)boldsymboln = boldsymbol0 text on Gamma_0\nchi_epsilon(varphi)boldsymbolCvarepsilon(boldsymbollambda)boldsymboln = -l_1^prime(boldsymbolu)text on Gamma_N\nchi_epsilon(varphi)boldsymbolCvarepsilon(boldsymbollambda)boldsymboln = -w^prime(boldsymbolu)cdotboldsymbollambda-l_2^prime(boldsymbolu) text on Gamma_R\nendaligned","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"This exactly as previously up to relaxation over D. Finally, The derivative of hatJ(varphi)=hatmathcalL(varphiboldsymboluboldsymbollambda) then follows by application of the chainrule as previously:","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"beginaligned\nhatJ^prime(varphi)(v)=fracpartialhatmathcalLpartialvarphi(varphiboldsymboluboldsymbollambda)(v)+cancelfracpartialhatmathcalLpartialboldsymbolv(varphiboldsymboluboldsymbollambda)(boldsymbolu^prime(v))+cancelfracpartialhatmathcalLpartialboldsymbolq(varphiboldsymboluboldsymbollambda)(boldsymbollambda^prime(v))\n=int_D v(chi^prime_epsilon(varphi)boldsymbolCvarepsilon(boldsymbolu)boldsymbolvarepsilon(boldsymbollambda)+(-H^prime(varphi))j(boldsymbolu)- (-H^prime(varphi))boldsymbolfcdotboldsymbollambda)mathrmdboldsymbolx\n=-int_D v(boldsymbolCvarepsilon(boldsymbolu)boldsymbolvarepsilon(boldsymbollambda)+j(boldsymbolu)- boldsymbolfcdotboldsymbollambda)H^prime(varphi)mathrmdboldsymbolx+epsilonint_D vboldsymbolCvarepsilon(boldsymbolu)boldsymbolvarepsilon(boldsymbollambda)H^prime(varphi)mathrmdboldsymbolx\nendaligned","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"where we have used that v=0 on Gamma_D as previously. As previously taking boldsymboltheta=vboldsymboln and relaxing the shape derivative of J over D with a signed distance function varphi yields:","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"tip: Result II\nhuge J^prime(Omega)(vboldsymboln) - hatmathcalJ^prime(varphi)(v)huge=O(epsilon)","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"As required.","category":"page"},{"location":"deprecated/dev/shape_der/#What-is-not-captured-by-a-Gâteaux-derivative-at-\\varphi?","page":"Shape derivative versus Gâteaux derivative in varphi","title":"What is not captured by a Gâteaux derivative at varphi?","text":"","category":"section"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"Owing to a fixed computational regime we do not capture a variation of the domain Omega in varphi, so the Gâteaux derivative of certain types of functionals in this context will not match the shape derivative. For example, in the discussion above the shape derivative of J_2 and the Gâteaux derivative of J_2Omega fail to match even in the relaxed setting. Regardless of this, accurate resolution of J_2 is difficult owing to the appearance of mean curvature. This problem is further exacerbated when a discretisation of the boundary is not available.","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"In addition, functionals of the signed distance function posed over the whole bounding domain D admit a special structure under shape differentiation (Paper). Such cases are not captured by a Gâteaux derivative at varphi under relaxation.","category":"page"},{"location":"deprecated/dev/shape_der/","page":"Shape derivative versus Gâteaux derivative in varphi","title":"Shape derivative versus Gâteaux derivative in varphi","text":"note: Note\nIn future, we plan to implement CellFEM via GridapEmbedded in GridapTopOpt. This will enable Gâteaux derivative of the mappingvarphi mapsto int_Omega(varphi)f(varphi)mathrmdboldsymbolx + int_Omega(varphi)^complementf(varphi)mathrmdboldsymbolxWe expect this to rectify the discussion above.","category":"page"},{"location":"deprecated/tutorials/inverter_mechanism/#Inverter-mechanism","page":"Inverter mechanism","title":"Inverter mechanism","text":"","category":"section"},{"location":"reference/levelsetevolution/#LevelSetEvolution","page":"LevelSetEvolution","title":"LevelSetEvolution","text":"","category":"section"},{"location":"reference/levelsetevolution/","page":"LevelSetEvolution","title":"LevelSetEvolution","text":"In GridapTopOpt, the level set is evolved and reinitialised using a LevelSetEvolution method. The most standard of these is the Hamilton-Jacobi evolution equation solved using a first order upwind finite difference scheme. A forward Euler in time method is provided below via HamiltonJacobiEvolution <: LevelSetEvolution along with an upwind finite difference stencil for the spatial discretisation via FirstOrderStencil.","category":"page"},{"location":"reference/levelsetevolution/","page":"LevelSetEvolution","title":"LevelSetEvolution","text":"This can be extended in several ways. For example, higher order spatial stencils can be implemented by extending the Stencil interface below. In addition, more advanced ODE solvers could be implemented (e.g., Runge–Kutta methods) or entirely different level set evolution methods by extending the LevelSetEvolution interface below.","category":"page"},{"location":"reference/levelsetevolution/#HamiltonJacobiEvolution","page":"LevelSetEvolution","title":"HamiltonJacobiEvolution","text":"","category":"section"},{"location":"reference/levelsetevolution/","page":"LevelSetEvolution","title":"LevelSetEvolution","text":"GridapTopOpt.HamiltonJacobiEvolution\nGridapTopOpt.HamiltonJacobiEvolution(stencil::GridapTopOpt.Stencil,model,space,tol=1.e-3,max_steps=100,max_steps_reinit=2000)\nGridapTopOpt.evolve!\nGridapTopOpt.reinit!\nGridapTopOpt.get_dof_Δ(m::HamiltonJacobiEvolution)","category":"page"},{"location":"reference/levelsetevolution/#GridapTopOpt.HamiltonJacobiEvolution","page":"LevelSetEvolution","title":"GridapTopOpt.HamiltonJacobiEvolution","text":"struct HamiltonJacobiEvolution{O}\n\nA standard forward Euler in time finite difference method for solving the  Hamilton-Jacobi evolution equation and reinitialisation equation  on order O finite elements in serial or parallel. \n\nBased on the scheme by Osher and Fedkiw (link).\n\nParameters\n\nstencil::Stencil: Spatial finite difference stencil for a single step HJ  equation and reinitialisation equation.\nmodel: A CartesianDiscreteModel.\nspace: FE space for level-set function\nperm: A permutation vector\nparams: Tuple of additional params\ncache: Stencil cache\n\n\n\n\n\n","category":"type"},{"location":"reference/levelsetevolution/#GridapTopOpt.HamiltonJacobiEvolution-2","page":"LevelSetEvolution","title":"GridapTopOpt.HamiltonJacobiEvolution","text":"HamiltonJacobiEvolution(stencil::Stencil,model,space,tol,max_steps,max_steps_reinit)\n\nCreate an instance of HamiltonJacobiEvolution given a stencil, model, FE space, and  additional optional arguments. This automatically creates the DoF permutation to handle high-order finite elements. \n\n\n\n\n\n","category":"type"},{"location":"reference/levelsetevolution/#GridapTopOpt.evolve!","page":"LevelSetEvolution","title":"GridapTopOpt.evolve!","text":"evolve!(::LevelSetEvolution,φ,args...)\n\nEvolve the level set function φ according to an evolution method LevelSetEvolution.\n\n\n\n\n\nevolve!(::Stencil,φ,vel,Δt,Δx,isperiodic,caches) -> φ\n\nSingle finite difference step of the Hamilton-Jacobi evoluation equation for a given Stencil. \n\n\n\n\n\nevolve!(s::HamiltonJacobiEvolution{O},φ,vel,γ) where O\n\nSolve the Hamilton-Jacobi evolution equation using the HamiltonJacobiEvolution.\n\nHamilton-Jacobi evolution equation\n\nfracpartialphipartial t + V(boldsymbolx)lVertboldsymbolnablaphirVert = 0\n\nwith phi(0boldsymbolx)=phi_0(boldsymbolx) and boldsymbolxin Dtin(0T).\n\nArguments\n\ns::HamiltonJacobiEvolution{O}: Method\nφ: level set function as a vector of degrees of freedom\nvel: the normal velocity as a vector of degrees of freedom\nγ: coeffient on the time step size.\n\n\n\n\n\n","category":"function"},{"location":"reference/levelsetevolution/#GridapTopOpt.reinit!","page":"LevelSetEvolution","title":"GridapTopOpt.reinit!","text":"reinit!(::LevelSetEvolution,φ,args...)\n\nReinitialise the level set function φ according to an evolution method LevelSetEvolution.\n\n\n\n\n\nreinit!(::Stencil,φ_new,φ,vel,Δt,Δx,isperiodic,caches) -> φ\n\nSingle finite difference step of the reinitialisation equation for a given Stencil.\n\n\n\n\n\nreinit!(s::HamiltonJacobiEvolution{O},φ,γ) where O\n\nSolve the reinitialisation equation using the HamiltonJacobiEvolution.\n\nReinitialisation equation\n\nfracpartialphipartial t + mathrmsign(phi_0)(lVertboldsymbolnablaphirVert-1) = 0\n\nwith phi(0boldsymbolx)=phi_0(boldsymbolx) and boldsymbolxin Dtin(0T).\n\nArguments\n\ns::HamiltonJacobiEvolution{O}: Method\nφ: level set function as a vector of degrees of freedom\nγ: coeffient on the time step size.\n\n\n\n\n\n","category":"function"},{"location":"reference/levelsetevolution/#GridapTopOpt.get_dof_Δ-Tuple{HamiltonJacobiEvolution}","page":"LevelSetEvolution","title":"GridapTopOpt.get_dof_Δ","text":"get_dof_Δ(m::HamiltonJacobiEvolution)\n\nReturn the distance betweem degree of freedom\n\n\n\n\n\n","category":"method"},{"location":"reference/levelsetevolution/#Spatial-stencils-for-HamiltonJacobiEvolution","page":"LevelSetEvolution","title":"Spatial stencils for HamiltonJacobiEvolution","text":"","category":"section"},{"location":"reference/levelsetevolution/","page":"LevelSetEvolution","title":"LevelSetEvolution","text":"GridapTopOpt.FirstOrderStencil","category":"page"},{"location":"reference/levelsetevolution/#GridapTopOpt.FirstOrderStencil","page":"LevelSetEvolution","title":"GridapTopOpt.FirstOrderStencil","text":"struct FirstOrderStencil{D,T} <: Stencil end\n\nA first order upwind difference scheme based on Osher and Fedkiw  (link).\n\n\n\n\n\n","category":"type"},{"location":"reference/levelsetevolution/#Custom-Stencil","page":"LevelSetEvolution","title":"Custom Stencil","text":"","category":"section"},{"location":"reference/levelsetevolution/","page":"LevelSetEvolution","title":"LevelSetEvolution","text":"GridapTopOpt.Stencil\nGridapTopOpt.evolve!(::GridapTopOpt.Stencil,φ,vel,Δt,Δx,isperiodic,caches)\nGridapTopOpt.reinit!(::GridapTopOpt.Stencil,φ_new,φ,vel,Δt,Δx,isperiodic,caches)\nGridapTopOpt.allocate_caches(::GridapTopOpt.Stencil,φ,vel)\nGridapTopOpt.check_order","category":"page"},{"location":"reference/levelsetevolution/#GridapTopOpt.Stencil","page":"LevelSetEvolution","title":"GridapTopOpt.Stencil","text":"abstract type Stencil\n\nFinite difference stencil for a single step of the Hamilton-Jacobi  evolution equation and reinitialisation equation.\n\nYour own spatial stencil can be implemented by extending the methods below.\n\n\n\n\n\n","category":"type"},{"location":"reference/levelsetevolution/#GridapTopOpt.evolve!-Tuple{GridapTopOpt.Stencil, Vararg{Any, 6}}","page":"LevelSetEvolution","title":"GridapTopOpt.evolve!","text":"evolve!(::Stencil,φ,vel,Δt,Δx,isperiodic,caches) -> φ\n\nSingle finite difference step of the Hamilton-Jacobi evoluation equation for a given Stencil. \n\n\n\n\n\n","category":"method"},{"location":"reference/levelsetevolution/#GridapTopOpt.reinit!-Tuple{GridapTopOpt.Stencil, Vararg{Any, 7}}","page":"LevelSetEvolution","title":"GridapTopOpt.reinit!","text":"reinit!(::Stencil,φ_new,φ,vel,Δt,Δx,isperiodic,caches) -> φ\n\nSingle finite difference step of the reinitialisation equation for a given Stencil.\n\n\n\n\n\n","category":"method"},{"location":"reference/levelsetevolution/#GridapTopOpt.allocate_caches-Tuple{GridapTopOpt.Stencil, Any, Any}","page":"LevelSetEvolution","title":"GridapTopOpt.allocate_caches","text":"allocate_caches(::Stencil,φ,vel)\n\nAllocate caches for a given Stencil.\n\n\n\n\n\n","category":"method"},{"location":"reference/levelsetevolution/#GridapTopOpt.check_order","page":"LevelSetEvolution","title":"GridapTopOpt.check_order","text":"check_order(::Stencil,order)\n\nThrow error if insufficient reference element order to implement stencil in parallel.\n\n\n\n\n\n","category":"function"},{"location":"reference/levelsetevolution/#Custom-LevelSetEvolution","page":"LevelSetEvolution","title":"Custom LevelSetEvolution","text":"","category":"section"},{"location":"reference/levelsetevolution/","page":"LevelSetEvolution","title":"LevelSetEvolution","text":"To implement a custom level set evolution method, we can extend the methods below. For example, one could consider Reaction-Diffusion-based evolution of the level set function. This can be solved with a finite element method and so we can implement a new type that inherits from LevelSetEvolution independently of the Stencil types.","category":"page"},{"location":"reference/levelsetevolution/","page":"LevelSetEvolution","title":"LevelSetEvolution","text":"GridapTopOpt.LevelSetEvolution\nGridapTopOpt.evolve!(::GridapTopOpt.LevelSetEvolution,φ,args...)\nGridapTopOpt.reinit!(::GridapTopOpt.LevelSetEvolution,φ,args...)\nGridapTopOpt.get_dof_Δ(::GridapTopOpt.LevelSetEvolution)","category":"page"},{"location":"reference/levelsetevolution/#GridapTopOpt.LevelSetEvolution","page":"LevelSetEvolution","title":"GridapTopOpt.LevelSetEvolution","text":"abstract type LevelSetEvolution\n\nYour own evolution method can be implemented by implementing  concrete functionality of the below.\n\n\n\n\n\n","category":"type"},{"location":"reference/levelsetevolution/#GridapTopOpt.evolve!-Tuple{GridapTopOpt.LevelSetEvolution, Any, Vararg{Any}}","page":"LevelSetEvolution","title":"GridapTopOpt.evolve!","text":"evolve!(::LevelSetEvolution,φ,args...)\n\nEvolve the level set function φ according to an evolution method LevelSetEvolution.\n\n\n\n\n\n","category":"method"},{"location":"reference/levelsetevolution/#GridapTopOpt.reinit!-Tuple{GridapTopOpt.LevelSetEvolution, Any, Vararg{Any}}","page":"LevelSetEvolution","title":"GridapTopOpt.reinit!","text":"reinit!(::LevelSetEvolution,φ,args...)\n\nReinitialise the level set function φ according to an evolution method LevelSetEvolution.\n\n\n\n\n\n","category":"method"},{"location":"reference/levelsetevolution/#GridapTopOpt.get_dof_Δ-Tuple{GridapTopOpt.LevelSetEvolution}","page":"LevelSetEvolution","title":"GridapTopOpt.get_dof_Δ","text":"get_dof_Δ(::LevelSetEvolution)\n\nReturn the distance betweem degree of freedom\n\n\n\n\n\n","category":"method"},{"location":"reference/optimisers/#Optimisers","page":"Optimisers","title":"Optimisers","text":"","category":"section"},{"location":"reference/optimisers/","page":"Optimisers","title":"Optimisers","text":"In GridapTopOpt we implement optimisation algorithms as iterators that inherit from an abstract type Optimiser. A concrete Optimiser implementation, say OptEg, then implements iterate(m::OptEg) ↦ (var,state) and iterate(m::OptEg,state) ↦ (var,state), where var and state are the available items in the outer loop and internal state of the iterator, respectively. As a result we can iterate over the object m=OptEg(...) using for var in m. The benefit of this implementation is that the internals of the optimisation method can be hidden in the source code while the explicit for loop is still visible to the user. The body of the loop can then be used for auxiliary operations such as writing the optimiser history and other files.","category":"page"},{"location":"reference/optimisers/","page":"Optimisers","title":"Optimisers","text":"The below describes the implemented optimisers along with the OptimiserHistory type. Custom optimisers can be implemented by creating types that inherit from Optimiser and extending the interfaces in Custom optimiser.","category":"page"},{"location":"reference/optimisers/#Lagrangian-and-Augmented-Lagrangian-method","page":"Optimisers","title":"Lagrangian & Augmented Lagrangian method","text":"","category":"section"},{"location":"reference/optimisers/","page":"Optimisers","title":"Optimisers","text":"Modules = [GridapTopOpt]\nPages = [\"Optimisers/AugmentedLagrangian.jl\"]","category":"page"},{"location":"reference/optimisers/#GridapTopOpt.AugmentedLagrangian","page":"Optimisers","title":"GridapTopOpt.AugmentedLagrangian","text":"struct AugmentedLagrangian <: Optimiser\n\nAn augmented Lagrangian method based on Nocedal and Wright, 2006 (link). Note that this method will function as a Lagrangian method if no constraints are defined in problem::PDEConstrainedFunctionals.\n\nParameters\n\nproblem::PDEConstrainedFunctionals: The objective and constraint setup.\nls_evolver::LevelSetEvolution: Solver for the evolution and reinitisation equations.\nvel_ext::VelocityExtension: The velocity-extension method for extending  shape sensitivities onto the computational domain.\nhistory::OptimiserHistory{Float64}: Historical information for optimisation problem.\nconverged::Function: A function to check optimiser convergence. \nhas_oscillations::Function: A function to check for oscillations.\nparams::NamedTuple: Optimisation parameters.\n\nThe has_oscillations function has been added to avoid oscillations in the  iteration history. By default this uses a mean zero crossing algorithm as implemented in ChaosTools. Oscillations checking can be disabled by taking has_oscillations = (args...) -> false.\n\n\n\n\n\n","category":"type"},{"location":"reference/optimisers/#GridapTopOpt.AugmentedLagrangian-Union{Tuple{N}, Tuple{PDEConstrainedFunctionals{N}, GridapTopOpt.LevelSetEvolution, VelocityExtension, Any}} where N","page":"Optimisers","title":"GridapTopOpt.AugmentedLagrangian","text":"AugmentedLagrangian(\n  problem    :: PDEConstrainedFunctionals{N},\n  ls_evolver :: LevelSetEvolution,\n  vel_ext    :: VelocityExtension,\n  φ0;\n  Λ_max = 10^10, ζ = 1.1, update_mod = 5, γ = 0.1, γ_reinit = 0.5, os_γ_mult = 0.75,\n  maxiter = 1000, verbose=false, constraint_names = map(i -> Symbol(\"C_$i\"),1:N),\n  converged::Function = default_al_converged, debug = false,\n  has_oscillations::Function = default_has_oscillations\n) where {N,O}\n\nCreate an instance of AugmentedLagrangian with several adjustable defaults.\n\nRequired\n\nproblem::PDEConstrainedFunctionals: The objective and constraint setup.\nls_evolver::LevelSetEvolution: Solver for the evolution and reinitisation equations.\nvel_ext::VelocityExtension: The velocity-extension method for extending  shape sensitivities onto the computational domain.\nφ0: An initial level-set function defined as a FEFunction or GridapDistributed equivilent.\n\nOptional defaults\n\nγ = 0.1: Initial coeffient on the time step size for solving the Hamilton-Jacobi evolution equation.\nγ_reinit = 0.5: Coeffient on the time step size for solving the reinitisation equation.\nζ = 1.1: Increase multiplier on Λ every update_mod iterations.\nΛ_max = 5.0: Maximum value on any entry in Λ.\nupdate_mod = 5: Number of iterations before increasing Λ.\nreinit_mod = 1: How often we solve reinitialisation equation.\nmaxiter = 1000: Maximum number of algorithm iterations.\nverbose=false: Verbosity flag.\nconstraint_names = map(i -> Symbol(\"C_$i\"),1:N): Constraint names for history output.\nhas_oscillations::Function = default_has_oscillations: Function to check for oscillations  in the history.\ninitial_parameters::Function = default_al_init_params: Function to generate initial λ, Λ. This can be replaced to inject different λ and Λ, for example.\nos_γ_mult = 0.75: Decrease multiplier for γ when has_oscillations returns true\nconverged::Function = default_hp_converged: Convergence criteria.\ndebug = false: Debug flag.\n\n\n\n\n\n","category":"method"},{"location":"reference/optimisers/#Hilbertian-projection-method","page":"Optimisers","title":"Hilbertian projection method","text":"","category":"section"},{"location":"reference/optimisers/","page":"Optimisers","title":"Optimisers","text":"Modules = [GridapTopOpt]\nPages = [\"Optimisers/HilbertianProjection.jl\"]","category":"page"},{"location":"reference/optimisers/#GridapTopOpt.HilbertianProjection","page":"Optimisers","title":"GridapTopOpt.HilbertianProjection","text":"struct HilbertianProjection <: Optimiser\n\nA Hilbertian projection method as described by Wegert et al., 2023 (link).\n\nParameters\n\nproblem::PDEConstrainedFunctionals{N}: The objective and constraint setup.\nls_evolver::LevelSetEvolution: Solver for the evolution and reinitisation equations.\nvel_ext::VelocityExtension: The velocity-extension method for extending shape sensitivities onto the computational domain.\nprojector::HilbertianProjectionMap: Sensitivity information projector\nhistory::OptimiserHistory{Float64}: Historical information for optimisation problem.\nconverged::Function: A function to check optimiser convergence.\nhas_oscillations::Function: A function to check for oscillations.\nparams::NamedTuple: Optimisation parameters.\n\n\n\n\n\n","category":"type"},{"location":"reference/optimisers/#GridapTopOpt.HilbertianProjection-Union{Tuple{N}, Tuple{PDEConstrainedFunctionals{N}, GridapTopOpt.LevelSetEvolution, VelocityExtension, Any}} where N","page":"Optimisers","title":"GridapTopOpt.HilbertianProjection","text":"HilbertianProjection(\n  problem :: PDEConstrainedFunctionals{N},\n  ls_evolver :: LevelSetEvolution,\n  vel_ext :: VelocityExtension,\n  φ0;\n  orthog = HPModifiedGramSchmidt(),\n  λ=0.5, α_min=0.1, α_max=1.0, γ=0.1, γ_reinit=0.5,\n  ls_max_iters = 10, ls_δ_inc = 1.1, ls_δ_dec = 0.7,\n  ls_ξ = 0.0025, ls_ξ_reduce_coef = 0.1, ls_ξ_reduce_abs_tol = 0.01,\n  ls_γ_min = 0.001, ls_γ_max = 0.1,\n  maxiter = 1000, verbose=false, constraint_names = map(i -> Symbol(\"C_$i\"),1:N),\n  converged::Function = default_hp_converged, debug = false\n) where {N}\n\nCreate an instance of HilbertianProjection with several adjustable defaults including the orthogonalisation method. By default the later is HPModifiedGramSchmidt.\n\nRequired\n\nproblem::PDEConstrainedFunctionals{N}: The objective and constraint setup.\nls_evolver::LevelSetEvolution: Solver for the evolution and reinitisation equations.\nvel_ext::VelocityExtension: The velocity-extension method for extending shape sensitivities onto the computational domain.\nφ0: An initial level-set function defined as a FEFunction or GridapDistributed equivilent.\n\nAlgorithm defaults\n\nγ = 0.1: Initial coeffient on the time step size for solving the Hamilton-Jacobi evolution equation.\nγ_reinit = 0.5: Coeffient on the time step size for solving the reinitisation equation.\nmaxiter = 1000: Maximum number of algorithm iterations.\nverbose=false: Verbosity flag.\nconstraint_names = map(i -> Symbol(\"C_$i\"),1:N): Constraint names for history output.\nconverged::Function = default_hp_converged: Convergence criteria.\nhas_oscillations::Function = (ls_enabled ? (args...)->false : default_has_oscillations: By default this is disabled when a line search in enabled.\nos_γ_mult = 0.5: Decrease multiplier for γ when has_oscillations returns true\ndebug = false: Debug flag.\nα_min ∈ [0,1] = 0.1: Controls lower bound on on the projected objective descent coefficent. α_min = 1 ignores the objective function and instead solves a constraint satisfaction problem.\nα_max ∈ [0,1] = 1.0: Controls the upper bound on the projected objective descent coeffient. Typically this shouldn't change unless wanting to approach the optimum 'slower'.\nλ = 0.5: The rate of contraint decrease.\n\nNote that in practice we usually only adjust α_min to control the balance between improving the objective or constraints.\n\nLine search defaults\n\nls_enabled = true: Set whether a line search is used.\nls_max_iters = 10: Maximum number of line search iterations.\nls_δ_inc = 1.1: Increase multiplier for γ on acceptance.\nls_δ_dec = 0.7: Decrease multiplier for γ on rejection.\nls_ξ = 1.0: Line search tolerance for objective reduction.\nls_ξ_reduce_coef = 0.0025: Coeffient on ls_ξ if constraints within tolerance (see below).\nls_ξ_reduce_abs_tol = 0.01: Tolerance on constraints to reduce ls_ξ via ls_ξ_reduce_coef.\nls_γ_min = 0.001: Minimum coeffient on the time step size for solving the HJ evolution equation.\nls_γ_max = 0.1: Maximum coeffient on the time step size for solving the HJ evolution equation.\n\nA more concervative evolution of the boundary can be achieved by decreasing ls_γ_max.\n\nnote: Note\nThe line search has been adjusted so that it is only enforced once the constraints are within a set tolerance. This generally leads to better optimisation histories, especially for problems where constraints are far from saturation and the objective must decrease to improve the constraints.This can be set to always be enfored by taking ls_ξ = 0.0025 and ls_ξ_reduce_coef = 0.1.\n\n\n\n\n\n","category":"method"},{"location":"reference/optimisers/","page":"Optimisers","title":"Optimisers","text":"Modules = [GridapTopOpt]\nPages = [\"Optimisers/OrthogonalisationMaps.jl\"]","category":"page"},{"location":"reference/optimisers/#GridapTopOpt.HPModifiedGramSchmidt","page":"Optimisers","title":"GridapTopOpt.HPModifiedGramSchmidt","text":"HPModifiedGramSchmidt\n\nHigh performance modified Gram-Schmidt. Based on Algorithm 6 in this paper.\n\n\n\n\n\n","category":"type"},{"location":"reference/optimisers/#GridapTopOpt.OrthogonalisationMap","page":"Optimisers","title":"GridapTopOpt.OrthogonalisationMap","text":"OrthogonalisationMap\n\n\n\n\n\n","category":"type"},{"location":"reference/optimisers/#Optimiser-history","page":"Optimisers","title":"Optimiser history","text":"","category":"section"},{"location":"reference/optimisers/","page":"Optimisers","title":"Optimisers","text":"GridapTopOpt.OptimiserHistory\nGridapTopOpt.OptimiserHistorySlice","category":"page"},{"location":"reference/optimisers/#GridapTopOpt.OptimiserHistory","page":"Optimisers","title":"GridapTopOpt.OptimiserHistory","text":"mutable struct OptimiserHistory{T}\n\nTrack historical information on optimisation problem iteration history.\n\nParameters\n\nniter::Int: Current iteration number\nkeys::Vector{Symbol}: Vector of symbols associated to values\nvalues::Dict{Symbol,Vector{T}}: Dictionary of vectors associated to keys\nbundles::Dict{Symbol,Vector{Symbol}}: Groups of symbols (e.g., a group of constraints)\nverbose::SolverVerboseLevel: Verbosity level\nmaxiter::Int: Maximum number of iterations.\n\nBehaviour\n\nIndexing at a specific iteration returns an OptimiserHistorySlice.\nIndexing with a key returns all values of that key\nIndexing with a key and iteration returns value/s of the key at the iteration.\n\n\n\n\n\n","category":"type"},{"location":"reference/optimisers/#GridapTopOpt.OptimiserHistorySlice","page":"Optimisers","title":"GridapTopOpt.OptimiserHistorySlice","text":"struct OptimiserHistorySlice{T} end\n\nA read-only wrapper of OptimiserHistory for IO display of iteration history at a specific iteration.\n\n\n\n\n\n","category":"type"},{"location":"reference/optimisers/#Custom-optimiser","page":"Optimisers","title":"Custom optimiser","text":"","category":"section"},{"location":"reference/optimisers/","page":"Optimisers","title":"Optimisers","text":"GridapTopOpt.Optimiser\nGridapTopOpt.iterate(::GridapTopOpt.Optimiser)\nGridapTopOpt.iterate(::GridapTopOpt.Optimiser,state)\nGridapTopOpt.get_history(::GridapTopOpt.Optimiser)\nGridapTopOpt.converged(::GridapTopOpt.Optimiser)","category":"page"},{"location":"reference/optimisers/#GridapTopOpt.Optimiser","page":"Optimisers","title":"GridapTopOpt.Optimiser","text":"abstract type Optimiser\n\nOptimisers in GridapTopOpt.jl are implemented as iterators. Your own optimiser can be implemented by implementing concrete functionality of the below.\n\n\n\n\n\n","category":"type"},{"location":"reference/optimisers/#Base.iterate-Tuple{GridapTopOpt.Optimiser}","page":"Optimisers","title":"Base.iterate","text":"Base.iterate(::Optimiser)\n\nReturn tuple of first iteration state for Optimiser.\n\n\n\n\n\n","category":"method"},{"location":"reference/optimisers/#Base.iterate-Tuple{GridapTopOpt.Optimiser, Any}","page":"Optimisers","title":"Base.iterate","text":"Base.iterate(::Optimiser,state)\n\nReturn tuple of next iteration state given current state for Optimiser.\n\n\n\n\n\n","category":"method"},{"location":"reference/optimisers/#GridapTopOpt.get_history-Tuple{GridapTopOpt.Optimiser}","page":"Optimisers","title":"GridapTopOpt.get_history","text":"get_history(::Optimiser) :: OptimiserHistory\n\nGet OptimiserHistory from Optimiser.\n\n\n\n\n\n","category":"method"},{"location":"reference/optimisers/#GridapTopOpt.converged-Tuple{GridapTopOpt.Optimiser}","page":"Optimisers","title":"GridapTopOpt.converged","text":"converged(::Optimiser)\n\nReturn a Bool that is true if the Optimiser has converged, otherwise false.\n\n\n\n\n\n","category":"method"},{"location":"reference/utilities/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"reference/utilities/#Ersatz-material-interpolation","page":"Utilities","title":"Ersatz material interpolation","text":"","category":"section"},{"location":"reference/utilities/","page":"Utilities","title":"Utilities","text":"GridapTopOpt.SmoothErsatzMaterialInterpolation","category":"page"},{"location":"reference/utilities/#GridapTopOpt.SmoothErsatzMaterialInterpolation","page":"Utilities","title":"GridapTopOpt.SmoothErsatzMaterialInterpolation","text":"struct SmoothErsatzMaterialInterpolation{M<:Vector{<:Number},N<:Vector{<:Number}}\n\nA wrapper holding parameters and methods for interpolating an integrand across a single boundary partialOmega.\n\nE.g., int fmathrmdOmega = int I(varphi)fmathrmdD where Omegasubset D is described by a level-set function varphi and I is an indicator function.\n\nProperties\n\nη::M: the interpolation or smoothing radius across ∂Ω\nϵ::M: the ersatz material density\nH: a smoothed Heaviside function\nDH: the derivative of H\nI: an indicator function\nρ: a function describing the volume density of Omega (e.g., mathrmVol(Omega) = int rho(varphi))mathrmdD)\n\nNote\n\nWe store η and ϵ as length-one vectors so that updating these values propagates through H, DH, etc.\nTo update η and/or ϵ in an instance m, take m.η .= <VALUE>.\nA conviencence constructor is provided to create an instance given η<:Number and ϵ<:Number.\n\n\n\n\n\n","category":"type"},{"location":"reference/utilities/#Mesh-labelling","page":"Utilities","title":"Mesh labelling","text":"","category":"section"},{"location":"reference/utilities/","page":"Utilities","title":"Utilities","text":"GridapTopOpt.update_labels!","category":"page"},{"location":"reference/utilities/#GridapTopOpt.update_labels!","page":"Utilities","title":"GridapTopOpt.update_labels!","text":"update_labels!(e::Int,model,f_Γ::Function,name::String)\n\nGiven a tag number e, a CartesianDiscreteModel or DistributedDiscreteModel model, an indicator function f_Γ, and a string name, label the corresponding vertices, edges, and faces as name.\n\nNote: f_Γ must recieve a Vector and return a Boolean depending on whether it indicates Γ\n\n\n\n\n\n","category":"function"},{"location":"reference/utilities/#Helpers","page":"Utilities","title":"Helpers","text":"","category":"section"},{"location":"reference/utilities/","page":"Utilities","title":"Utilities","text":"GridapTopOpt.initial_lsf\nGridapTopOpt.isotropic_elast_tensor\nGridapTopOpt.get_el_Δ","category":"page"},{"location":"reference/utilities/#GridapTopOpt.initial_lsf","page":"Utilities","title":"GridapTopOpt.initial_lsf","text":"initial_lsf(ξ,a;b)\n\nGenerate a function f according to f(x) = -1/4 ∏ᵢ(cos(ξπ(xᵢ-bᵢ))) - a/4 where x is a vector with components xᵢ.\n\n\n\n\n\n","category":"function"},{"location":"reference/utilities/#GridapTopOpt.isotropic_elast_tensor","page":"Utilities","title":"GridapTopOpt.isotropic_elast_tensor","text":"isotropic_elast_tensor(D::Int,E::M,v::M)\n\nGenerate an isotropic SymFourthOrderTensorValue given a dimension D, Young's modulus E, and Poisson's ratio v.\n\n\n\n\n\n","category":"function"},{"location":"reference/utilities/#GridapTopOpt.get_el_Δ","page":"Utilities","title":"GridapTopOpt.get_el_Δ","text":"get_el_Δ(model)\n\nGiven a CartesianDiscreteModel or DistributedDiscreteModel that is uniform, return the element size as a tuple.\n\n\n\n\n\n","category":"function"},{"location":"deprecated/tutorials/minimum_elastic_compliance/#Minimum-elastic-compliance","page":"Minimum elastic compliance","title":"Minimum elastic compliance","text":"","category":"section"},{"location":"deprecated/usage/ad/#Automatic-Differentiation","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"","category":"section"},{"location":"#GridapTopOpt.jl","page":"Home","title":"GridapTopOpt.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for GridapTopOpt.jl!","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GridapTopOpt.jl is computational toolbox for level set-based topology optimisation implemented in Julia and the Gridap package ecosystem. The core design principle of GridapTopOpt.jl is to provide an extendable framework for solving optimisation problems in serial or parallel with a high-level programming interface and automatic differentiation. See the following publication for further details:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Zachary J. Wegert, Jordi Manyer, Connor Mallon, Santiago Badia, and Vivien J. Challis (2024). \"GridapTopOpt.jl: A scalable Julia toolbox for level set-based topology optimisation\". arXiv:2405.10478.","category":"page"},{"location":"#How-to-use-this-documentation","page":"Home","title":"How to use this documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The first step for new users is to visit the Getting Started page.\nA set of tutorials are available as part of the above paper.\nThe detailed documentation is in the Reference section.","category":"page"},{"location":"#Julia-educational-resources","page":"Home","title":"Julia educational resources","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A basic knowledge of the Julia programming language is needed to use the GridapTopOpt.jl package. Here, one can find a list of resources to get started with this programming language.","category":"page"},{"location":"","page":"Home","title":"Home","text":"First steps to learn Julia form the Gridap wiki page.\nOfficial webpage docs.julialang.org\nOfficial list of learning resources julialang.org/learning","category":"page"},{"location":"deprecated/usage/getting-started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"deprecated/usage/getting-started/#Known-issues","page":"Getting started","title":"Known issues","text":"","category":"section"},{"location":"deprecated/usage/getting-started/","page":"Getting started","title":"Getting started","text":"PETSc's GAMG preconditioner breaks for split Dirichlet DoFs (e.g., x constrained while y free for a single node). There is no simple fix for this. We recommend instead using MUMPS or another preconditioner for this case.\nThere is a memory leak in Julia (ver>1.9) IO that affects write_vtk. This is a known problem and for now we occasionally use gc(). This will hopefully be fixed in an upcoming release. ","category":"page"}]
}
